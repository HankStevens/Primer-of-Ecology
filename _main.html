<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Primer of Ecology with R</title>
  <meta name="description" content="Primer of Ecology with R" />
  <meta name="generator" content="bookdown #bookdown:version# and GitBook 2.6.7" />

  <meta property="og:title" content="Primer of Ecology with R" />
  <meta property="og:type" content="book" />
  
  
  
  <meta name="github-repo" content="HankStevens/Primer-of-Ecology" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Primer of Ecology with R" />
  
  
  

<meta name="author" content="Hank Stevens" />


<meta name="date" content="2020-08-20" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<!--bookdown:link_prev-->
<!--bookdown:link_next-->
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script>


<style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



<!--bookdown:title:start-->
<div id="header">
<h1 class="title">Primer of Ecology with R</h1>
<p class="author"><em>Hank Stevens</em></p>
<p class="date"><em>2020-08-20</em></p>
</div>
<!--bookdown:title:end-->

<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul>
<li><a href="#preface">Preface</a></li>
<li><a href="#references"><span class="toc-section-number">1</span> References</a></li>
<li><a href="#theory"><span class="toc-section-number">2</span> Theory in Ecology</a><ul>
<li><a href="#examples-of-theories"><span class="toc-section-number">2.1</span> Examples of theories</a><ul>
<li><a href="#hierarchy-theory"><span class="toc-section-number">2.1.1</span> Hierarchy theory</a></li>
<li><a href="#a-general-theory-of-ecology"><span class="toc-section-number">2.1.2</span> A general theory of ecology</a></li>
<li><a href="#efficient-theory"><span class="toc-section-number">2.1.3</span> Efficient theory</a></li>
</ul></li>
<li><a href="#metabolic_scaling"><span class="toc-section-number">2.2</span> An example: Metabolic Theory of Ecology</a><ul>
<li><a href="#body-size-dependence"><span class="toc-section-number">2.2.1</span> Body-size dependence</a></li>
<li><a href="#temperature-dependence"><span class="toc-section-number">2.2.2</span> Temperature dependence</a></li>
</ul></li>
<li><a href="#power-law-scaling-implies-constant-relative-differences"><span class="toc-section-number">2.3</span> Power law scaling implies constant relative differences</a></li>
</ul></li>
<li><a href="#oft"><span class="toc-section-number">3</span> Optimal Foraging</a><ul>
<li><a href="#a-prey-model"><span class="toc-section-number">3.1</span> A prey model</a><ul>
<li><a href="#our-intuition"><span class="toc-section-number">3.1.1</span> Our intuition</a></li>
<li><a href="#mathematical-support"><span class="toc-section-number">3.1.2</span> Mathematical support</a></li>
</ul></li>
<li><a href="#the-patch-model"><span class="toc-section-number">3.2</span> The patch model</a></li>
<li><a href="#a-simulation-of-a-prey-model"><span class="toc-section-number">3.3</span> A simulation of a prey model</a><ul>
<li><a href="#lab-exercise"><span class="toc-section-number">3.3.1</span> Lab exercise</a></li>
</ul></li>
</ul></li>
<li><a href="#expo"><span class="toc-section-number">4</span> Simple density-independent growth</a><ul>
<li><a href="#discrete-growth-rates-of-fruit-flies-in-my-kitchen"><span class="toc-section-number">4.1</span> Discrete growth rates of fruit flies in my kitchen</a></li>
<li><a href="#fruit-flies-with-continuous-overlapping-generations"><span class="toc-section-number">4.2</span> Fruit flies with continuous overlapping generations</a></li>
<li><a href="#properties-of-geometric-and-exponential-growth"><span class="toc-section-number">4.3</span> Properties of geometric and exponential growth</a><ul>
<li><a href="#average-growth-rate"><span class="toc-section-number">4.3.1</span> Average growth rate</a></li>
</ul></li>
<li><a href="#modeling-with-data-simulated-dynamics"><span class="toc-section-number">4.4</span> Modeling with Data: Simulated Dynamics</a><ul>
<li><a href="#data-based-approaches"><span class="toc-section-number">4.4.1</span> Data-based approaches</a></li>
<li><a href="#creating-and-visualizing-the-data"><span class="toc-section-number">4.4.2</span> Creating and visualizing the data</a></li>
<li><a href="#one-simulation"><span class="toc-section-number">4.4.3</span> One simulation</a></li>
<li><a href="#multiple-simulations"><span class="toc-section-number">4.4.4</span> Multiple simulations</a></li>
<li><a href="#a-distribution-of-possible-futures"><span class="toc-section-number">4.4.5</span> A distribution of possible futures</a></li>
<li><a href="#analyzing-results"><span class="toc-section-number">4.4.6</span> Analyzing results</a></li>
<li><a href="#inferring-processes-underlying-growth-rate"><span class="toc-section-number">4.4.7</span> Inferring processes underlying growth rate</a></li>
</ul></li>
</ul></li>
<li><a href="#DID"><span class="toc-section-number">5</span> Density-independent Demography</a><ul>
<li><a href="#a-two-stage-matrix-model"><span class="toc-section-number">5.1</span> A two stage matrix model</a></li>
<li><a href="#a-brief-primer-on-matrices"><span class="toc-section-number">5.2</span> A brief primer on matrices</a></li>
<li><a href="#decomposing-a"><span class="toc-section-number">5.3</span> Decomposing <strong>A</strong></a></li>
<li><a href="#a-three-stage-model"><span class="toc-section-number">5.4</span> A three stage model</a></li>
<li><a href="#projection"><span class="toc-section-number">5.5</span> Projection</a></li>
<li><a href="#analyzing-the-transition-matrix"><span class="toc-section-number">5.6</span> Analyzing the transition matrix</a><ul>
<li><a href="#eigenanalysis"><span class="toc-section-number">5.6.1</span> Eigenanalysis</a></li>
<li><a href="#finite-rate-of-increase"><span class="toc-section-number">5.6.2</span> Finite rate of increase</a></li>
<li><a href="#stable-stage-distribution"><span class="toc-section-number">5.6.3</span> Stable stage distribution</a></li>
<li><a href="#calculating-the-stable-stage-distribution"><span class="toc-section-number">5.6.4</span> Calculating the stable stage distribution</a></li>
<li><a href="#reproductive-value"><span class="toc-section-number">5.6.5</span> Reproductive value</a></li>
<li><a href="#sensitivity-and-elasticity"><span class="toc-section-number">5.6.6</span> Sensitivity and elasticity</a></li>
</ul></li>
<li><a href="#r-packges-for-demography"><span class="toc-section-number">5.7</span> R packges for demography</a></li>
<li><a href="#exploring-a-real-population"><span class="toc-section-number">5.8</span> Exploring a real population</a></li>
</ul></li>
<li><a href="#references"><span class="toc-section-number">6</span> References</a></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Primer of Ecology with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->
<div id="preface" class="section level1 unnumbered">
<h1>Preface</h1>

<p>In spite of the presumptuous title, my goals for this book are modest. I wrote it as</p>
<ul>
<li>the manual I wish I had in graduate school, and</li>
<li>a primer for our graduate course in Population and Community Ecology at Miami University.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></li>
</ul>
<p>It is my hope that readers can enjoy the  and ignore the R code, if they care to. Toward this end, I tried to make the code easy to ignore, by either putting boxes around it, or simply concentrating code in some sections and keeping it out of other sections.</p>
<p>It is also my hope that ecologists interested in learning R will have a rich yet gentle introduction to this amazing programming language. Toward that end, I have included some useful functions in an R package called . Like nearly all R packages, it is available through the R projects repositories, the CRAN mirrors. See the Appendix for an introduction to the R language.</p>
<p>I have a hard time learning something on my own, unless I can  something with the material. Learning ecology is no different, and I find that my students and I learn theory best when we write down formulae, manipulate them, and explore consequences of rearrangement. This typically starts with copying down, verbatim, an expression in a book or paper. Therefore, I encourage readers to take pencil to paper, and fingers to keyboard, and copy expressions they see in this book. After that, make sure that what I have done is correct by trying some of the same rearrangements and manipulations I have done. In addition, try things that aren’t in the book — have fun.</p>

<p>For centuries, musicians and composers have learned their craft in part by  to works of others. Physical embodiment of the musical notes and their sequences helped them learn composition. I have it on great authority that most theoreticians (and other mathematicians) do the same thing — they start by copying down mathematical expressions. This physical process helps get the content under their skin and through their skull. I encourage you to do the same. Whether otherwise indicated or not, let the first assigned problem at the end of each chapter be to copy down, with a pencil and paper, the mathematical expression presented in that chapter. In my own self-guided learning, I have often taken this simple activity for granted and have discounted its value — to my own detriment. I am not surprised how often students also take this activity for granted, and similarly suffer the consequences.  the logic of something is not always enough — sometimes we have to actually  the logic for ourselves.</p>
<p>Using a text editor (such as the simple one in the R GUI) is one of the huge benefits of using R. Using a text editor to write code and to make extensive comments to yourself (and others!) makes R  interactive. You interact with yourself by putting your thoughts on (virtual) paper, highlighting concepts and details you learn along the way, and documenting clearly what it is you have done. The code and the comments are two halves of the whole. Your comments also allow you to interact with others in a very complete way. You cannot realistically and reliably interact with others unless you put something in writing. If you use an application that is a pure GUI, you would have to describe the buttons you click and be absolutely certain that you leave nothing out and that you can actually communicate what you did. By writing and commenting code, you can send your scripts to anyone (your students, employees, boss, regulatory agency, collaborators).</p>

<p>It may be useful to compare this book to others of a similar ilk. This book bears its closest similarities to two other wonderful primers: Gotelli’s , and Roughgarden’s . I am more familiar with these books than any other introductory texts, and I am greatly indebted to these authors for their contributions to my education and the discipline as a whole.</p>
<p>My book, geared toward graduate students, includes more advanced material than Gotelli’s primer, but most of the ecological topics are similar. I attempt to start in the same place (e.g., ``What is geometric growth?’’), but I develop many of the ideas much further. Unlike Gotelli, I do not cover life tables at all, but rather, I devote an entire chapter to . I include a chapter on community structure and diversity, including , , , and , as well as . My book also includes code to implement most of the ideas, whereas Gotelli’s primer does not.</p>
<p>This book also differs from Roughgarden’s primer, in that I use the Open Source R programming language, rather than Matlab, and I do not cover physiology or evolution. My philosphical approach is similar, however, as I tend to ``talk’’ to the reader, and we fall down the rabbit hole together.</p>
<p>Aside from Gotelli and Roughgarden’s books, this book bears similarity in content to several other wonderful introductions to mathematical ecology or biology. I could have cited repeatedly (and in some places did so) the following: Ellner and Guckenheimer (2006), Gurney and Nisbet (1998), Kingsland (1985), MacArthur (1972), Magurran (2004), May (2001), Morin (1999), Otto and Day (2006), and Vandermeer and Goldberg (2007). Still others exist, but I have not yet had the good fortune to dig too deeply into them.</p>

<p>I am indebted to Scott Meiners and his colleagues for their generous sharing of data, metadata, and statistical summaries from the Buell-Small Succession Study (<a href="http://www.ecostudies.org/bss/" class="uri">http://www.ecostudies.org/bss/</a>), a 50<span class="math inline">\(+\)</span> year study of secondary succession (supported in part by NSF grant DEB-0424605) in the North American temperate deciduous forest biome. I would like to thank Stephen Ellner for Ross’s Bombay death data and for R code and insight over the past few years. I am also indebted to Tom Crist and his colleagues for sharing some of their moth data (work supported by The Nature Conservancy Ecosystem Research Program
NSF DEB-0235369).</p>
<p>I am grateful for the generosity of early reviewers and readers, each of whom has contributed much to the quality of this work: Jeremy Ash, Tom Crist, David Gorchov, Raphael Herrera-Herrera, Thomas Petzoldt, James Vonesh, as well as several anonymous reviewers, and the students of our Population and Community Ecology class. I am also grateful for the many conversations and emails shared with four wonderful mathematicians and theoreticians: Jayanth Banavar, Ben bolker, Stephen Ellner, Amit Shukla, and Steve Wright — I never have a conversation with these people without learning something. I have been particularly fortunate to have team-taught Population and Community Ecology at Miami University with two wonderful scientists and educators, Davd Gorchov and Thomas Crist. Only with this experience, of working closely with these colleagues, have I been able to attempt this book. It should go without saying, but I will emphasis, that the mistakes in this book are mine, and there would be many more but for the sharp eyes and insightful minds of many other people.</p>
<p>I am also deeply indebted to the R Core Development Team for creating, maintaining and pushing forward the R programming language and environment . Like the air I breathe, I cannot imagine my (professional) life without it. I would especially like to thank Friedrich Leisch for the development of , which makes literate programming easy . Because I rely on Aquamacs, ESS, , and a host of other Open Source programs, I am deeply grateful to those who create and distribute these amazing tools.</p>
<p>A few other R packages bear special mention. First, Ben Bolker’s text  and packages for modeling ecological data ( and ) are broadly applicable. Second, Thomas Petzoldt’s and Karsten Rinke’s  package provides a general computational architecture for ecological models, and implements many wonderful examples . Much of what is done in this primer (especially in chapters 1, 3–6, 8) can be done with , and sometimes done better. Third, Robin Hankin’s  package is an excellent resource for exploring ecological neutral theory (chapter 10) . Last, I re lied heavily on the   and  packages .</p>
<p>Last, and most importantly, I would like to thank those to whom this book is dedicated, whose love and senses of humor make it all worthwhile.</p>
</div>
<div id="references" class="section level1">
<h1><span class="header-section-number">1</span> References</h1>
<!--chapter:end:index.Rmd-->
</div>
<div id="theory" class="section level1">
<h1><span class="header-section-number">2</span> Theory in Ecology</h1>
<p>In this chapter, we introduce a perspective on ecological theory, and provide an example of an efficient theory, metabolic scaling.</p>
<p><em>Scientific theory</em> is a body of knowledge that provides an organized and mechanistic view of how the world works <span class="citation">(Scheiner <a href="#ref-Scheiner2010" role="doc-biblioref">2010</a>)</span>. Theories concerning gravity, general relativity, and evolution by natural selection provide structured ways of connecting observations, patterns, and processes that provide insight into why the world is the way it is. This stands in stark contrast to the colloquial use of <em>theory</em> that implies a lack of knowledge, as when someone says “oh, that’s just a theory”, referring to a guess without much evidence. Scientific theory is a set of explanations whose validity has been tested repeatedly by experiments and new data.</p>
<div id="examples-of-theories" class="section level2">
<h2><span class="header-section-number">2.1</span> Examples of theories</h2>
<p>Ecology has lots of theories, of all different types. Below I discuss some which may be prevalent, important, useful, or some combination.</p>
<div id="hierarchy-theory" class="section level3">
<h3><span class="header-section-number">2.1.1</span> Hierarchy theory</h3>
<p>An early and persistent organizing theory in ecology is based on <em>hierarchy theory</em> <span class="citation">(O’Neill et al. <a href="#ref-ONeill1986" role="doc-biblioref">1986</a>; Rose et al. <a href="#ref-Rose2017" role="doc-biblioref">2017</a>, and references therein)</span>. It posits that ecological systems are structured <em>hierachically</em>, such that each entity comprises subunits. For instance, an entity such as a population of big bluestem grass (<em>Andropogon gerardii</em>) is part of a larger ecology community of many species. The population of big bluestem comprises subpopulations separated in space, a subpopulation comprises separate individuals, that each individual comprises multiple ramets and a set of organ systems and tissues, which comprise different cell types. This theory posits that each entity gives rise to emergent properties to the hierarchical level above it, and influences processes within each smaller sub-entity in the hierachical level below it. As a disciplinary organizing principle, this approach structures nearly all of the ecology curriculum.</p>
<p>Hierarchy theory gets more complicated when the levels of a hierarchy start to include fundamentally different types of entities. The big bluestem hierarchy above included only biotic components–a individual is part of a population which is part of a community of individuals of multiple species, and is made up of organ systems and tissues. Ecology, however, includes both the biotic and the abiotic parts of environments. An ecosystem includes a community of species, but also the nutrients, water, light, and other abiotic components, along with the spatial arrangement of all of these things.</p>
<p>Different hierarchies are useful for different questions. An individual organism can play very different roles in different hierarchies. Consider and individual bunch grass. To understand how a population evolves, we need to count individuals within a population, because evolutionary fitness is tracked by the number of independent reproductive units. In contrast, to understand competitive interactions, it may be much more important to weigh the biomass of groups of individuals in a population, because biomass is more closely related of resource uptake.</p>
</div>
<div id="a-general-theory-of-ecology" class="section level3">
<h3><span class="header-section-number">2.1.2</span> A general theory of ecology</h3>
<p>Good scientific theories exist within a hierarchy of disciplinary knowledge <span class="citation">(Scheiner and Willig <a href="#ref-Scheiner2011" role="doc-biblioref">2011</a>)</span>. They explain phenomena within a <em>domain</em> of knowledge which is organized around <em>principles</em> and <em>assumptions</em>. Scheiner and Willig posit a theory of biology that explains phenomena relating to the “diversity and complexity of living systems”. One of the ten principles on which this theory depends is that “the cell is the fundamental unit of life”. Subsumed within their theory of biology is the theory of cells whose domain is “cells and the causes of their structure, function, and variation.” This theory in turn is based on principles and has theories to organize our understanding of cells and what cells do.</p>
<p><em>Models</em> are specific and explicit manifestations of more general theories. In this book, we focus on popular mathematical models that are specific manifestions of theories of ecology.</p>
<p><span class="citation">Scheiner and Willig (<a href="#ref-Scheiner2011" role="doc-biblioref">2011</a>)</span> propose a theory of ecology, some of which we cover in this book. Here is part of this theory:</p>
<p><strong>The General Theory of Ecology</strong></p>
<p><strong>Domain:</strong> The spatial and temporal pattern of the distribution and abundance of organisms, including causes and consequences.</p>
<p><strong>Principles:</strong></p>
<ol style="list-style-type: decimal">
<li>Organisms are distributed in space and time in a heterogeneous manner.</li>
<li>Organisms interact with their abiotic and biotic environments.</li>
<li>Variation in the characteristics of organisms results in heterogeneity of ecological patterns and processes.</li>
<li>The distributions of organisms and their interactions depend on contingencies.</li>
<li>Environmental conditions as perceived by organisms are heterogeneous in space and time.</li>
<li>Resources as perceived by organisms are finite and heterogeneous in space and time.</li>
<li>Birth and death rates are a consequence of interactions with the abiotic and biotic environment.</li>
<li>The ecological properties of species are the result of evolution.</li>
</ol>
<p>These principles constitute what we know is true about ecological systems. Some of these principles provide the focus for a single chapter while other principles apply broadly to many chapters in this book.</p>
<p><span class="newthought">Here is my own perspective</span> on a general theory of ecology:</p>
<p><em>Domain:</em> The house of life<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>: its constituent entities, causes, and consequences.</p>
<p><em>Principles:</em></p>
<ol style="list-style-type: decimal">
<li>Entities<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> are open systems with inputs and outputs.</li>
<li>Entities have internal complexity.</li>
<li>Entities include self-replicating components (living elements).</li>
<li>Entities interact via inputs, outputs, and behavior.</li>
<li>Rates of change, including inputs and outputs, are influenced directly by physical factors: space, temperature, and concentration.</li>
</ol>
<p>You will see elements of these principles throughout this book as well.</p>
</div>
<div id="efficient-theory" class="section level3">
<h3><span class="header-section-number">2.1.3</span> Efficient theory</h3>
<p><span class="citation">Marquet et al. (<a href="#ref-Marquet2014" role="doc-biblioref">2014</a>)</span> argue that the best theories are those which are <em>efficient</em>. Such theories tend to be <em>based on first principles</em>, which are observations and laws that are fundamental assumptions in a scientific domain. In biology, such principles can include the laws of thermodynamics, and mathematical properties such as the central limit theorem. Theories built upon first principles are thus well-grounded in reality as we understand it and lead logically to refinements. Marquet and his colleagues also claim that efficient theory is <em>expressed in mathematics</em>. Mathematics is a universal language that is unamibiguous. It forces us to be as clear as possible about what we mean when we state a theory.<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> Last, efficient theories are those that make a <em>large number of predictions using only a small number of free parameters</em>.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> Examples of efficient theories we cover in this book include metabolic scaling, exponential growth, density dependence, and ecological neutral theory.</p>
<p>Marquet et al. and Scheiner and Willig emphasize slightly different features of the definition of “theory”. Scheiner and Willig emphasize relatively broad ideas that are well-supported by experiments and repeated observation. Marquet and colleagues tend to mean something fairly specific and narrow, typically something that can be expressed mathematically. Scheiner and Willig might refer to such theory as constitutive theory or even simply a model.</p>
<p>Next, I describe the Metabolic Theory of Ecology. This theory is based on first principles, and its central tenets are expressed mathematically. It’s core equation has a very small number of free parameters (fitted constants) and makes a very large number of testable predictions. Parts of this theory are supported by a very large number of observations. It fits everyone’s definition of theory.</p>
</div>
</div>
<div id="metabolic_scaling" class="section level2">
<h2><span class="header-section-number">2.2</span> An example: Metabolic Theory of Ecology</h2>
<p>Metabolic rate is central to how rapidly individuals forage for, consume and use resources, reproduce and die. The <em>metabolic theory of ecology</em> <span class="citation">(Brown et al. <a href="#ref-Brown:2004wa" role="doc-biblioref">2004</a>)</span> is a well-supported body of knowledge about the underlying mechanisms, and the resulting profound and wide-ranging consequences for populations and ecosystems.</p>
<p>Body size and temperature are fundamental properties of organisms and the environment. The study of how body shape and body processes scale with body size is <em>allometry</em>. Because body size affects metabolic rate, body size indirectly helps determine population growth rates and how species interact with each other. Temperature affects how molecules vigorously molecules vibrate and move, and so increasing temperature tends to speed up chemical reactions. As metabolism is really just a complex network of biochemical reactions, temperature influences metabolic rate.</p>
<p>The core of this theory is expressed in a simple mathematical equation that describes how body size and temperature govern metabolic rate.</p>
<div id="body-size-dependence" class="section level3">
<h3><span class="header-section-number">2.2.1</span> Body-size dependence</h3>
<p>There is a profoundly simple and general rule describing the effect of interspecific variation in body size on metabolism.<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> This biological law is referred to as the Kleiber law <span class="citation">(Kleiber <a href="#ref-Kleiber1932" role="doc-biblioref">1932</a>)</span>, or <em>quarter power scaling</em> <span class="citation">(Brown et al. <a href="#ref-Brown:2004wa" role="doc-biblioref">2004</a>)</span>. When we compare the basal (i.e. resting) metabolic rates of different species, across a wide range of body sizes spanning many orders of magnitude, we find that</p>
<p><em>whole-organism resting metabolic rate increases with organism mass raised to the three-quarter power</em>, or,</p>
<p><span class="math display">\[
B = aM^{z} \quad;\quad z = 3/4
\]</span></p>
<p>In this equation, <span class="math inline">\(B\)</span> is basal, or resting, metabolic rate, <span class="math inline">\(M\)</span> is body mass, <span class="math inline">\(a\)</span> is a proportionality constant, and <span class="math inline">\(z\)</span> is the <em>power law scaling coefficient</em>. The proportionality constant <span class="math inline">\(a\)</span> varies depending on the type of organism such as arthropods, fish, or mammals. Plants scale in the same manner <span class="citation">(Niklas and Enquist <a href="#ref-Niklas2001" role="doc-biblioref">2001</a>)</span>, although size or mass is a little trickier to measure. The scaling coefficient, <span class="math inline">\(z\)</span>, is the seemingly magical constant that many have argued does not vary substantially among different types of organisms.</p>
<p>Ecologists typically describe metabolism-mass relations and other power law behavior using logarithmic scales. When we do that, power law relations become linear. Using our rules for exponents and logarithms, metabolic scaling becomes
<span class="math display">\[ \log B = \log a + z\log M\]</span>
so that <span class="math inline">\(\log B\)</span> increases linearly with <span class="math inline">\(\log M\)</span> with a slope of <span class="math inline">\(3/4\)</span>. Our brains can process and compare linear relations much more easily than curvilinear ones.</p>
<p>Here we plot the curvilinear relation in R using <code>curve()</code> in the <code>graphics</code> package of R that is included in the base installation as one of the core packages. The function <code>curve()</code> can plot any curve that be expressed as a function of <code>x</code>. Below, we draw a curve of a dotted 1:1 line for comparison, and then <em>add</em> the power function <span class="math inline">\(x^{3/4}\)</span>.</p>
<div class="figure">
<img src="figs/MTE34-1.png" alt="Metabolic rate increases predictably with species body sizes." width="75%" />
<p class="caption">
(#fig:MTE34)Metabolic rate increases predictably with species body sizes.
</p>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">## using curve, let your variable be &#39;x&#39;.</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">curve</span>(<span class="dv">1</span><span class="op">*</span>x, <span class="dt">from =</span> <span class="fl">.01</span>, <span class="dt">to=</span><span class="dv">100</span>, <span class="dt">ylab =</span> <span class="st">&quot;Metabolic rate (B)&quot;</span>,</span>
<span id="cb1-3"><a href="#cb1-3"></a>      <span class="dt">xlab=</span><span class="st">&quot;Body mass (M)&quot;</span>, <span class="dt">lty=</span><span class="dv">3</span>)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">curve</span>(x<span class="op">^</span>(<span class="dv">3</span><span class="op">/</span><span class="dv">4</span>), <span class="dt">from =</span> <span class="fl">.01</span>, <span class="dt">to =</span> <span class="dv">100</span>, <span class="dt">add=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<p>To help us grasp the implications of this, let’s consider <em>mass-specific</em> metabolic rates. “Mass-specific” means on a per-gram basis.<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> Mass-specific metabolic rate is basal metabolic rate of an individual divided by its mass, or <span class="math inline">\(B/M\)</span>.</p>
<p>The mass-specific metabolic rate allows us to compare directly, for example, the metabolic rate of a cell in a shrew vs. a cell in an elephant. Which cell is burning fuel faster?</p>
<p>We can estimate this from the above metabolic scaling principle and the using rules exponents
<span class="math display">\[ \frac{B}{M} = a \frac{M^z}{M^1} = a M^{z-1} = aM^{-1/4}\]</span>
From this, we now have the rule that</p>
<p><em>mass-specific metabolic rate declines with organisms mass raised to the negative one quater power</em></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>eq1 =<span class="st"> </span><span class="cf">function</span>(M, a){a<span class="op">*</span>M<span class="op">^-</span><span class="fl">0.25</span>} <span class="co"># create the function, F(M)</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">ggplot</span>(<span class="dt">data=</span><span class="kw">data.frame</span>(<span class="dt">x=</span><span class="kw">c</span>(<span class="fl">0.1</span>, <span class="dv">100</span>)), <span class="kw">aes</span>(<span class="dt">x=</span>x) ) <span class="op">+</span><span class="st"> </span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="st">  </span><span class="kw">stat_function</span>(<span class="dt">fun=</span>eq1, <span class="dt">geom=</span><span class="st">&quot;line&quot;</span>, <span class="dt">args=</span><span class="kw">list</span>(<span class="dt">a=</span><span class="dv">1</span>)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Mass (M)&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;Mass-specific metabolic rate (B/M)&quot;</span>)</span></code></pre></div>
<div class="figure">
<img src="figs/MTE-MS-1.png" alt="Mass-specific metabolic rate declines predictably with species body sizes." width="75%" />
<p class="caption">
(#fig:MTE-MS)Mass-specific metabolic rate declines predictably with species body sizes.
</p>
</div>
<p>Over the years, there has been heated debate about (i) the precise value of the scaling coefficient <span class="math inline">\(z\)</span>, and (ii) the underlying mechanism. Early arguments suggested that <span class="math inline">\(z \approx 2/3\)</span> because the rate heat dissipation scales with the amount surface area. Why <span class="math inline">\(2/3\)</span>?</p>
<p>Let’s envision the volume of an organism having three linear dimensions, so the volume scales to the cube of linear dimensions, while the surface area scales to the square of these linear dimensions,<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>
<span class="math display">\[V \propto L^3\]</span>
<span class="math display">\[A \propto L^2\]</span>
The early explanation was that metabolic rate, <span class="math inline">\(B\)</span>, scales linearly with area,
<span class="math display">\[B \propto A^1 \propto L^2\]</span>.
With substitution we get,
<span class="math display">\[L^2 \propto V^z \propto (L^3)^z\]</span>
implying that the exponents <span class="math inline">\(2 = 3z\)</span> or <span class="math inline">\(z=2/3\)</span>, so we get,
<span class="math display">\[B=V^{2/3}\]</span>,
and, for the most part, mass scales linearly with volume for mammals or any other such group.</p>
<p>This early theory was because it started with first principles (heat dissipation and geometry) and resulted in the prediction of a single parameter. It could then be used to make predictions about how metabolic rate scales with body mass. Metabolic rate governs a huge amount of biology and ecology, including resource consumption rates, lifespan, and maximum population growth rates. Therefore, this theory and this model could be powerful tools for understanding the world and making testable predictions.</p>
<p>The above model is good because it could be tested. That is what has been done, and scientists found that there was a consistent mismatch between observations and the theory. Investigators showed that the value of the exponent appeared closer to 3/4 raher than 2/3. In the 1990s, a group including Jim Brown and Geoffrey West <span class="citation">(West, Brown, and Enquist <a href="#ref-West1997" role="doc-biblioref">1997</a>)</span> proposed an underlying mechanism that explained why it should be 3/4. They assumed that organisms must</p>
<ul>
<li>distribute resources from a single source through a branching, fractal-like, space-filling network to all parts of the body,</li>
<li>the size of the smallest branch ( a capillary) was the same for organisms of all sizes.</li>
<li>the energy required to distribute the resources must be minimized, that less energy-efficient designs would be lost through natural selection.</li>
</ul>
<p>The prediction that resulted from these assumptions was that the exponent would be 3/4. This theory and model begin with different first principles and makes a different prediction.</p>
<p>Soon Jayanth Banavar and his colleagues offered an alternative <span class="citation">(Banavar, Maritan, and Rinaldo <a href="#ref-Banavar1999" role="doc-biblioref">1999</a>; Banavar et al. <a href="#ref-Banavar2002" role="doc-biblioref">2002</a>)</span>, arguing that the assumption of the fractal-like network was not correct, and in any event, was not necessary and did not apply to all organisms. They proposed different theory with less restrictive assumptions and found nonetheless that the exponent was also predicted to be 3/4.</p>
<p>At the base of all these arguments is the geometry of the resource distribution system. All organisms take in limiting resources and have to distribute those resources to each part of each cell in the body. The key point is that <em>the larger the organism, the greater the portion of the resources are in transit at any instant in time</em>. This leads to an increasingly inefficient system, in which the metabolism of larger organisms has to run more slowly per unit resource:</p>
<p><em>Larger organisms can process more resources per unit time (<span class="math inline">\(B=aM^{3/4}\)</span>), but do so less and less efficiently (<span class="math inline">\(\frac{B}{M}=aM^{-1/4}\)</span>) due to resources in transport.</em></p>
<p>Banavar, Brown and others eventually collaborated to address quarter power scaling in animals in particular which led to additional novel predictions <span class="citation">(Banavar et al. <a href="#ref-Banavar2010" role="doc-biblioref">2010</a>)</span>.</p>
<p>This theory remains a fertile and active area of research <span class="citation">(Glazier <a href="#ref-Glazier2018" role="doc-biblioref">2018</a>)</span>. The interested reader should be careful to distinguish between patterns observed across many species of very different sizes, versus patterns observed in a single species with individuals of different sizes versus other types of patterns. Subtly different patterns may be driven be very different mechanisms.</p>
</div>
<div id="temperature-dependence" class="section level3">
<h3><span class="header-section-number">2.2.2</span> Temperature dependence</h3>
<p>In addition to body size, temperature plays the other key role in regulating metabolic rate. The Arrhenius equation connects the macroscopic property of temperature to the kinetic energy of molecules and the rates they govern. Metabolic rate is proportional to these rate determining processes,
<span class="math display">\[B  = a e^{\frac{-E_a}{kT}}\]</span>
where <span class="math inline">\(a\)</span> is just a constant, <span class="math inline">\(e\)</span> is the exponential, <span class="math inline">\(E_a\)</span> is the average activation energy of rate-limiting enzymes (units, eV), <span class="math inline">\(k\)</span> is Boltzmann’s constant (units eV<span class="math inline">\(\,\)</span>K<span class="math inline">\(^{-1}\)</span>), and <span class="math inline">\(T\)</span> (units deg K). Bolztmann’s constant (<span class="math inline">\(\backsim 8.6 \times 10^-5\)</span><span class="math inline">\(\,\)</span>eV<span class="math inline">\(\,\)</span>K<span class="math inline">\(^{-1}\)</span>) converts the macroscopic property of temperature to kinetic energy of molecules.</p>
<p>Individual biochemical reactions combine to determine basal metabolic rate, so <span class="citation">Gillooly (<a href="#ref-Gillooly2000" role="doc-biblioref">2000</a>)</span> have taken this as a foundation for the metabolic theory of ecology <span class="citation">(Brown et al. <a href="#ref-Brown:2004wa" role="doc-biblioref">2004</a>)</span>. In 2000, they suggested that the average activation energy is approximately <span class="math inline">\(E_a = 0.23\,\)</span>eV . Subsequent work has described this as “temperature sensitivity”, where larger numbers imply that organisms respond more strongly to temperature variation.</p>
<p>The Arrhenius equation is a little more complicated that a simple power law, but not too much. Over the range of biologically relevant temperatures, it is dominated by a largely exponential increase in metabolic rate with increasing temperature (Fig @(fig:arrh)).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># with base R</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co"># base R: curve(10^4*exp(-0.23/(8.5 * 10^-5 *x)), 276, 316), ylab=&quot;B&quot;, xlab=&#39;T&#39;)</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co"># or ggplot2</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co"># the function, with default parameter values</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>eq.t &lt;-<span class="st"> </span><span class="cf">function</span>(t,<span class="dt">a=</span><span class="dv">10</span><span class="op">^</span><span class="dv">4</span>,<span class="dt">E=</span><span class="fl">0.23</span>,<span class="dt">k=</span><span class="fl">8.6</span> <span class="op">*</span><span class="st"> </span><span class="dv">10</span><span class="op">^-</span><span class="dv">5</span>){a<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>E<span class="op">/</span>(k<span class="op">*</span>t))}</span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="co"># the data used in our function</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>temps &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">t=</span><span class="dv">276</span><span class="op">:</span><span class="dv">316</span>)</span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="kw">ggplot</span>(<span class="dt">data=</span>temps, <span class="kw">aes</span>(<span class="dt">x=</span>t)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="co"># set the basic properties of the plot</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="st">  </span><span class="kw">stat_function</span>(<span class="dt">fun=</span>eq.t, <span class="dt">geom=</span><span class="st">&quot;line&quot;</span>) <span class="op">+</span><span class="st"> </span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="co"># set the function to plot</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Temperature (K)&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;Metabolic rate (B)&quot;</span>)  </span></code></pre></div>
<div class="figure">
<img src="figs/arrh-1.png" alt="The effect of body temperature on ectothermic metabolic rates can be approximated with the Arrhenius function, $B = a e^{-E_a/(kT)}$. Here $a = 10^4$, and $E_a = 0.23$. It is similar in shape to a power law with z &gt; 1, over the range of biologically relevant temperatures." width="75%" />
<p class="caption">
(#fig:arrh)The effect of body temperature on ectothermic metabolic rates can be approximated with the Arrhenius function, <span class="math inline">\(B = a e^{-E_a/(kT)}\)</span>. Here <span class="math inline">\(a = 10^4\)</span>, and <span class="math inline">\(E_a = 0.23\)</span>. It is similar in shape to a power law with z &gt; 1, over the range of biologically relevant temperatures.
</p>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># add labels</span></span></code></pre></div>
<p>When we linearize the relation between metabolic rate and temperature, we get
<span class="math display">\[
\begin{aligned}
B &amp;= a e^{\frac{-E_a}{kT}}\\
\log(B) &amp;= \log{a} - E_a\frac{1}{kT}\\
\end{aligned}
\]</span>
where the dependent variable is <span class="math inline">\(1/(kT)\)</span>, <span class="math inline">\(-E_a\)</span> is the slope, and <span class="math inline">\(\log a\)</span> is the intercept. Thus, the negative slope of this relation describes theoretical prediction for the effect of temperature on metabolic rate.</p>
<p><strong>So, there you have it.</strong> The metabolic theory ecology is the algebraic product of body size- and temperature-dependence:
<span class="math display">\[B = a M^{3/4} e^{\frac{-E_a}{kT}}\]</span>
This theory makes quantitative predictions regarding all kinds of ecology phenomena <span class="citation">(Brown et al. <a href="#ref-Brown:2004wa" role="doc-biblioref">2004</a>)</span>, including</p>
<ul>
<li>home range size</li>
<li>population growth</li>
<li>population size</li>
<li>resource uptake</li>
<li>predation and other species interactions, and</li>
<li>ecosystem cycling.</li>
</ul>
<p>Note that these relations are based on first principles of geometry and thermodynamics, and that they depend on only a small number of parameters (<span class="math inline">\(a\)</span>, <span class="math inline">\(-E_a\)</span>, and perhaps <span class="math inline">\(z=3/4\)</span>), and makes a tremendous number of predictions. Therefore, <span class="citation">Marquet et al. (<a href="#ref-Marquet2014" role="doc-biblioref">2014</a>)</span> propose that this is “good” theory, and very <em>efficient</em>.</p>
</div>
</div>
<div id="power-law-scaling-implies-constant-relative-differences" class="section level2">
<h2><span class="header-section-number">2.3</span> Power law scaling implies constant relative differences</h2>
<p>In power law scaling, relative change is constant. That is, a proportional change in one variable results in a proportional change in the other. For instance, when we compare a smaller species to a larger species with <span class="math inline">\(100 \times\)</span> the body mass, we can expect to see metabolic rate increase by <span class="math inline">\(31.6 \times\)</span>, <em>regardless of the mass of the smaller species.</em> For now, we will verify this numerically for some limited cases.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># define body mass and metabolic rate</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>m &lt;-<span class="st"> </span><span class="kw">c</span>(.<span class="dv">01</span>, <span class="dv">1</span>, <span class="dv">100</span>, <span class="dv">10000</span>)</span>
<span id="cb5-3"><a href="#cb5-3"></a>b &lt;-<span class="st"> </span>m<span class="op">^</span>.<span class="dv">75</span></span></code></pre></div>
<p>Now we will divide each mass <span class="math inline">\(i\)</span> by the next smallest mass <span class="math inline">\(i-1\)</span>. We do that using a vector by dividing each mass except the first one, by each mass except the last one.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a><span class="co"># round(x, digits=0) rounds number to zero decimal places</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">round</span>( m[<span class="op">-</span><span class="dv">1</span>]<span class="op">/</span>m[<span class="op">-</span><span class="kw">length</span>(m)], <span class="dt">digits =</span> <span class="dv">0</span>)</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="kw">round</span>( b[<span class="op">-</span><span class="dv">1</span>]<span class="op">/</span>b[<span class="op">-</span><span class="kw">length</span>(b)], <span class="dt">digits =</span> <span class="dv">1</span>)</span></code></pre></div>
When we do these divisions, we see the constant relative change (@ref(tab:relativemb)).
<table>
<caption>
(#tab:relativemb)As we increase mass by a constant multiplier (10x), power law scaling results in a constant proportional change in basal metabolc rate.
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Small
</th>
<th style="text-align:right;">
Med.
</th>
<th style="text-align:right;">
Big
</th>
<th style="text-align:right;">
Huge
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Mass
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
1.00
</td>
<td style="text-align:right;">
100.00
</td>
<td style="text-align:right;">
10000.00
</td>
</tr>
<tr>
<td style="text-align:left;">
Basal.metabolic.rate
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
1.00
</td>
<td style="text-align:right;">
31.62
</td>
<td style="text-align:right;">
1000.00
</td>
</tr>
<tr>
<td style="text-align:left;">
Relative.change.m
</td>
<td style="text-align:right;">
NA
</td>
<td style="text-align:right;">
100.00
</td>
<td style="text-align:right;">
100.00
</td>
<td style="text-align:right;">
100.00
</td>
</tr>
<tr>
<td style="text-align:left;">
relative.change.b
</td>
<td style="text-align:right;">
NA
</td>
<td style="text-align:right;">
31.62
</td>
<td style="text-align:right;">
31.62
</td>
<td style="text-align:right;">
31.62
</td>
</tr>
</tbody>
</table>
<p>We can verify this generally using algebra, not just in the particular case above. We will show that if mass increases by a constant multiplier, metabolic rate will also, regardless of the particular masses involved.</p>
<p>Let mass <span class="math inline">\(m_2\)</span> be greater than mass <span class="math inline">\(m_1\)</span> by a factor of <span class="math inline">\(c\)</span>, so that <span class="math inline">\(m_2 = c m_1\)</span>, and
<span class="math display">\[\frac{m_2}{m_1} = c\]</span>.</p>
<p>We would like to show that the ratio of the metabolic rates <span class="math inline">\(b_2 / b_1\)</span> is also a constant. Since <span class="math inline">\(m_2 = cm_1\)</span>, we can say that
<span class="math display">\[b_1 = a m_1^{3/4}\]</span>
<span class="math display">\[b_2 = a (cm_1)^{3/4} = ac^{3/4}m_1^{3/4}\]</span>
<span class="math display">\[\frac{b_2}{b_1} = \frac{ac^{3/4}m_1^{3/4}}{am_1^{3/4}}\]</span>
When we reduce this fraction, we a left with
<span class="math display">\[\frac{b_2}{b_1} = c^{3/4}\]</span></p>
<p>This shows that with power law scaling, increasing <span class="math inline">\(x\)</span> by a constant <em>multipier</em> (or proportion), <span class="math inline">\(y\)</span> increases by the same proportion raised to that power.</p>
<p>Let’s represent this graphically in a couple of ways, reusing data we made up previously in this chapter. First, we just change the axes themselves, so that the units of the scales are multiples of 10 (often in scientific notation).</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># using base R</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">par</span>(<span class="dt">mar=</span><span class="kw">c</span>(<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">0</span>), <span class="dt">mgp=</span><span class="kw">c</span>(<span class="fl">1.5</span>,.<span class="dv">4</span>,<span class="dv">0</span>) )<span class="co"># set figure margins in &quot;lines&quot;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="kw">curve</span>(x<span class="op">^</span>(<span class="dv">3</span><span class="op">/</span><span class="dv">4</span>), <span class="dt">from =</span> <span class="fl">.01</span>, <span class="dt">to =</span> <span class="dv">100</span>, <span class="dt">log=</span><span class="st">&quot;xy&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;Basal metabolic rate&quot;</span>, <span class="dt">xlab=</span><span class="st">&quot;Mass&quot;</span>)</span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="kw">text</span>(<span class="dv">10</span>, <span class="dv">80</span><span class="op">^</span>.<span class="dv">7</span>, <span class="kw">expression</span>(M<span class="op">^</span><span class="fl">0.75</span>))</span></code></pre></div>
<div class="figure">
<img src="figs/logscale-1.png" alt="changing the scales of the axes to linearize power law relations. Note scales are logarithmic, using the original linear values." width="50%" />
<p class="caption">
(#fig:logscale)changing the scales of the axes to linearize power law relations. Note scales are logarithmic, using the original linear values.
</p>
</div>
<!--chapter:end:01-theory.Rmd-->
</div>
</div>
<div id="oft" class="section level1">
<h1><span class="header-section-number">3</span> Optimal Foraging</h1>
<div class="figure">
<img src="figs/CowieF3.png" alt="Optimal foraging theory (OFT) generates testable quantitative predictions that allow a less ambiguous description and explanation for observed patterns and processes. Here, a simplistic model of Great Tit (Parus major) foraging that includes only gross energy intake underestimates the time spent in patches (dashed). In contrast, a model that includes energetic costs of traveling and searching matches predictions far better (solid).  From Cowie (1977)." width="75%" />
<p class="caption">
(#fig:cowie)Optimal foraging theory (OFT) generates testable quantitative predictions that allow a less ambiguous description and explanation for observed patterns and processes. Here, a simplistic model of Great Tit (Parus major) foraging that includes only gross energy intake underestimates the time spent in patches (dashed). In contrast, a model that includes energetic costs of traveling and searching matches predictions far better (solid). From Cowie (1977).
</p>
</div>
<p>It can be useful to think of natural selection as an optimizing process: phenotypes diversify, winners replicate and losers don’t, and the phenotypes of winners tend to get passed on to the replicants. Therefore, we often assume, as did Dr. Pangloss, that the species that exist now are the best of all possible species, that is, they are of optimal design. And like Dr. Pangloss, we would be woefully mistaken if we stopped there. Nonetheless, optimization, that is, the tendency toward an optimum, helps us generate testable hypotheses and we consider some of these below.</p>
<p>Optimal Foraging Theory (OFT) helps us consider what organisms would do <em>if they foraged optimally.</em> All organisms–plants, fungi, archaea, and even animals–forage, and they are all subject to natural selection. Therefore, their phenotypes work pretty well, but probably not optimally and definitely not optimally for all times and places. Nonetheless, OFT is an efficient theory about the behavior of an organism, in the absence of other complications. Therefore, it allows us to study the relative importance of those “other complications.”</p>
<p>Foraging is a key link between the individual, and communities and ecosystems <span class="citation">(Beckerman, Petchey, and Morin <a href="#ref-Beckerman2010" role="doc-biblioref">2010</a>)</span>. All organisms interact with their environment via consumption, and the choices they make influence population dynamics, species interactions, nutrient cycling, and even the physical structures of terrestrial and aquatic habitats. The text and logic of this chapter rely heavily on <span class="citation">Stephens and Krebs (<a href="#ref-Stephens1986" role="doc-biblioref">1986</a>)</span> and <span class="citation">Ellner (<a href="#ref-Ellner2009" role="doc-biblioref">2009</a>)</span>.</p>
<p>In Scheiner and Willig’s edited volume on <em>The Theory of Ecology</em>, Andy Sih <span class="citation">(Sih <a href="#ref-Sih2011" role="doc-biblioref">2011</a>)</span> proposes that the following propositions form the basis of foraging theory:</p>
<ol style="list-style-type: decimal">
<li>Foraging patterns maximize fitness or a correlate of fitness.</li>
<li>Foraging patterns depend on the range of options available to the forager and on how each available option affects fitness or a correlate of fitness.</li>
<li>Foraging behaviour balances conflicting demands–tradeoffs are important in shaping foraging behaviour.</li>
</ol>
<p>These properties are the outcome of natural selection operating on foraging behavior. Our understanding of foraging itself considers these three features <span class="citation">(Stephens and Krebs <a href="#ref-Stephens1986" role="doc-biblioref">1986</a>)</span>:</p>
<ul>
<li>currency (what is being optimized),</li>
<li>constraints (features of behaviour that limit optimality), and</li>
<li>the resulting decision rules.</li>
</ul>
<p><em>Currency</em> is that quantity that is optimized by the forager. This currency is assumed to be a quantity that limits fitness, such as energy or a particular consumable resource. We measure it as a rate, for instance, as the energy gained per unit time (E/T) or the uptake of a critically limiting resource per unit time (R/T).</p>
<p><em>Constraints</em> are limitations that we assume about organisms. These might include distances between resource patches, the time and costs associated with extracting a resource from a substrate or subduing prey. They also include constraints imposed by other species including competitors and predators. Constraints can get complicated quickly; however, simple quantitative theory makes predictions against which we can evaluate more complicated assumptions.</p>
<p><em>Decision rules</em> are what we ascribed to a forager’s choices. A decision rule concern the probability of attacking prey if encountered, or when to leave one resource patch in order to search for another.</p>
<p>An additional way to think about all this is <em>where, when, and what.</em> A great deal of effort has focused on understanding patch use: <em>where</em> foragers should explore for resources, and <em>when</em> they should give up and go in search of another patch <span class="citation">(Charnov <a href="#ref-Charnov1976b" role="doc-biblioref">1976</a>)</span>. These are <strong>patch use</strong> models, and are based on economic models and the marginal value theorem.</p>
<p>Another avenue of inquiry concerns <em>what</em> animals should eat. For instance, should they go after big prey that may be hard to catch and difficult to subdue, or just snack on what is easy? These are <strong>prey models</strong> or diet models, and attempt to explain why organisms consume <em>what</em> they do.</p>
<p><em>A note on “prey”.</em> All organisms forage for resources. Plants extend branches toward the light, and proliferate leaves and roots into resource rich patches, and rhizomes grow longer faster through resource-poor soils. Bumblebees search for and learn where to find nectar-rich flowers, and wolves hunt in packs to take down large ungulates. Some bacterivorous nanoflagellates intercept particles selectively depending on the perceived nutritional value of particles <span class="citation">(Boenigk et al. <a href="#ref-Boenigk2002" role="doc-biblioref">2002</a>)</span>. So, depending on the forager, its “prey” may be <span class="math inline">\(\mathrm{NO}_{3}^-\)</span> ions, nectar, moose, or bacteria. Therefore, we will refer to these resources variously as prey, prey items, resources, and resource items. Some of these ideas are best handled with patch-based models <span class="citation">(Charnov <a href="#ref-Charnov1976b" role="doc-biblioref">1976</a>)</span> where a “resource patch” is a more intuitive and useful unit.</p>
<p><em>A note on “handle”.</em> All organisms pays costs to consume resources. In OFT, “handle” typically means expending energy an time to attack and subdue prey (predators), proliferate into resource rich areas (plants), exude extra cellular enzymes (fungi); ingest the item(s), and then resume searching.</p>
<div id="a-prey-model" class="section level2">
<h2><span class="header-section-number">3.1</span> A prey model</h2>
<p><em>…in which a forager asks, “should I eat this?”</em><a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a></p>
<p>Let’s start where this field started, with a prey-centered model <span class="citation">(MacArthur and Pianka <a href="#ref-MacArthur1966" role="doc-biblioref">1966</a>; Emlen <a href="#ref-Emlen1966" role="doc-biblioref">1966</a>)</span>.</p>

<p>The goal is to optimize the currency.</p>
<div id="our-intuition" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Our intuition</h3>
<div class="figure">
<img src="figs/foraging_ant2.jpg" alt="The amount of energy, E (y-axis), that is lost and gained by a foraging ant--it may decline slowly over time (x-axis) while searching, and decline quickly while handling a food item. Our ant gains energy when it consumes an item. Below: Our ant. She expends energy while searching for food. Upon encountering a food item, she may choose to 'handle' it (encounters 1 and 3) and gain energy, or not handle it (encounter 2) and save the added cost of handling it." width="100%" />
<p class="caption">
(#fig:ant)The amount of energy, E (y-axis), that is lost and gained by a foraging ant–it may decline slowly over time (x-axis) while searching, and decline quickly while handling a food item. Our ant gains energy when it consumes an item. Below: Our ant. She expends energy while searching for food. Upon encountering a food item, she may choose to ‘handle’ it (encounters 1 and 3) and gain energy, or not handle it (encounter 2) and save the added cost of handling it.
</p>
</div>
<p>It seems reasonable that if a forager encounters food, it should eat it. However, if handling it costs more than the forager gets back in energy, then it isn’t worth it. We might think of this as the ratio as <em>profitability</em>,
<span class="math display">\[\frac{e_i}{h_i}\]</span>
where <span class="math inline">\(e_i\)</span> is the energy in an item of type <span class="math inline">\(i\)</span>, and <span class="math inline">\(h_i\)</span> is the cost of handling said item. If <span class="math inline">\(e_i/h_i&lt;1\)</span>, then it doesn’t make sense to select the item. Further, handling an item means that the forager is <em>not</em> looking for a better food item. This suggests that even if <span class="math inline">\(e_i/h_i&gt;1\)</span>, a forager may not want to handle it if it is likely to soon encounter food items of higher energy content. On top of this, the act of searching may expose a forager to a risk of running into competing foragers, or even being eaten by a bigger forager. Clearly, a forager faces tradeoffs as it searches and when it encounters resources.</p>
</div>
<div id="mathematical-support" class="section level3">
<h3><span class="header-section-number">3.1.2</span> Mathematical support</h3>
<p>One of the reasons to represent ideas mathematically is that we make concrete assumptions, and then the math can tell us what the predictions are. That is what we will do here.</p>
<p>Let’s assume that natural selection tends to maximize the currency as Gain per unit Time, <span class="math inline">\(G/T\)</span>. Our model will use these parameters and variables:</p>
<ul>
<li><span class="math inline">\(i =\)</span> index for prey type</li>
<li><span class="math inline">\(S =\)</span> total time spent <strong>searching</strong> (units = seconds, <span class="math inline">\(s\)</span>).</li>
<li><span class="math inline">\(\lambda_i =\)</span> rate of encounter with prey of type <span class="math inline">\(i\)</span> (units = # encountered/s = <span class="math inline">\(\#/s\)</span>; note this can also be #/area × area/s, if we like)<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a></li>
<li><span class="math inline">\(p_i =\)</span> probability that a forager attacks prey if encountered (units are number handled per number encountered, or #/#; this is a dimensionless parameter)</li>
<li><span class="math inline">\(h_i =\)</span> handling time for an item of type <span class="math inline">\(i\)</span>, (units = s/#).</li>
<li><span class="math inline">\(T =\)</span> <strong>total</strong> elapsed time (units = s)</li>
</ul>
<p>From these definitions we can calculate other important quantities.</p>
<p><strong>Total number of items</strong> encountered of type <span class="math inline">\(i\)</span> is
<span class="math display">\[S \lambda_i\]</span></p>
<p>The units are <span class="math inline">\(s\, \#\,s^{-1} = \#\)</span>.</p>
<p><strong>Total number of type <span class="math inline">\(i\)</span> items handled</strong> is the proportion, <span class="math inline">\(p_i\)</span>, of those encountered that the foragers chooses to go after, or
<span class="math display">\[S\lambda_i p_i\]</span>
The units are <span class="math inline">\(\#\)</span>.</p>
<p><strong>Total time spent handling</strong> all items of type <span class="math inline">\(i\)</span> is
<span class="math display">\[H=S\lambda_i p_i h_i\]</span>
The units are <span class="math inline">\(s\)</span>.<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a></p>
<p><strong>Total elapsed time</strong> is time spent searching plus time spent handling, which is<br />
<span class="math display">\[T=S + \sum_i^n S\lambda_i h_i p_i\]</span>
where we use the summation to add together the total handling times for each prey or resource type <span class="math inline">\(i = \{1,\,2, \ldots ,\,n\}\)</span>.</p>
<p>Let</p>
<ul>
<li><span class="math inline">\(e_i =\)</span> net energetic gain from catching and consuming a single type-i prey item (units = Joules, J). This includes the gross energy of the item minus handling costs plus energy not lost by searching during that time.</li>
<li><span class="math inline">\(c =\)</span> energy cost per unit of time while searching (units = J).</li>
</ul>
<p><strong>Total energy gain</strong> from eating all the items is the number of items of each type <span class="math inline">\(i\)</span> handled times the net amount of energy per item of type <span class="math inline">\(i\)</span>, <span class="math inline">\(e_i\)</span>, <span class="math display">\[\sum_{i=1}^n S\lambda_i p_i e_i\]</span>
where units are <span class="math inline">\(\# (\mathrm{J}/ \#) = \mathrm{J}\)</span>.</p>
<p>Therefore, <strong>rate</strong> of energy intake (J/<span class="math inline">\(s\)</span>) while handling and eating is
<span class="math display">\[\mathrm{intake} = \frac{\sum_{i=1}^n S\lambda_i p_i e_i}{S + \sum_{i=1}^n S\lambda_i h_i p_i}\]</span>
If we then subtract the cost of searching, we arrive at the quantity we want to maximize,
<span class="math display">\[G/T=\frac{\sum_{i=1}^n \lambda_i p_i e_i}{1 + \sum_{i=1}^n \lambda_i p_i h_i}-c\]</span>
A major question in OFT is whether a forager should include a particular prey type. Say we rank the prey types, <span class="math inline">\(i=\{1,2,...,m,...,n\}\)</span>, in terms of energy content, where type <span class="math inline">\(i=1\)</span> has the most energy per item, <span class="math inline">\(i=m\)</span> is intermediate, and type <span class="math inline">\(i=n\)</span> has the least. <em>Which items should a forager include in her diet?</em> Should it be only the most energy-dense, or should it include the second as well, or should it be all of them? Part of the answer rests on the ratio of energy gain versus handling costs, or profitability, <span class="math inline">\(e_i/h_i\)</span>.</p>
<p>If we maximized <span class="math inline">\(G/T\)</span> with respect to <span class="math inline">\(p_j\)</span>, we would be able to determine whether to include item <span class="math inline">\(j\)</span>. Doing so leads to several predictions.</p>
<p><strong>Prediction 1</strong> <em>A less energy-dense item should be added if its net energy content is greater than the realized energy gain from all the other items,</em></p>
<p><span class="math display">\[\begin{equation}
\frac{e_{m+1}}{h_{m+1}} &gt; \frac{\sum_{i=1}^m \lambda_i e_i}{1 + \sum_{i=1}^{m} \lambda_i h_i} (\#eq:preypred1)
\end{equation}\]</span></p>
<p>where the diet already includes items 1-<span class="math inline">\(m\)</span>, and the <em>realized</em> energy content of the diet takes into account average encounter rates of each item type. It means that a foraging will always select a particular type (<span class="math inline">\(p_j =1\)</span>), or never select it (<span class="math inline">\(p_j=0\)</span>); this is known as the “zero-one rule”.</p>
<p><strong>Prediction 2</strong> Foragers will rank prey types by their profitability, <span class="math inline">\(e/h\)</span>.</p>
<p><strong>Prediction 3</strong> When encounter rates increase (as with increasing abundances), selectivity increases. Note that encounter rates are in the right hand side, so as they increase, so will that fraction on the right. That will make it harder for the above inequality to be true, and a forager will be pickier. If you don’t believe it, try this simplified version (Fig. @ref(fig:selectivity)).</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>G.T =<span class="st"> </span><span class="cf">function</span>(lambda, <span class="dt">h=</span><span class="dv">1</span>, <span class="dt">e=</span><span class="dv">1</span>){lambda<span class="op">*</span>e<span class="op">/</span>(<span class="dv">1</span><span class="op">+</span>lambda<span class="op">*</span>h)} <span class="co"># create the function you want</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>myData &lt;-<span class="st"> </span><span class="kw">data.frame</span>( <span class="dt">lambda=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">10</span>) ) <span class="co"># data you need</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="kw">ggplot</span>(<span class="dt">data=</span>myData, <span class="kw">aes</span>(<span class="dt">x=</span>lambda)) <span class="op">+</span><span class="st"> </span><span class="co"># set the basic properties of the plot</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="st">  </span><span class="co"># in the stat_function, we indicate the parameters in our equation.</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="st">  </span><span class="kw">stat_function</span>(<span class="dt">fun=</span>G.T, <span class="dt">geom=</span><span class="st">&quot;line&quot;</span>) <span class="op">+</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="kw">bquote</span>(<span class="kw">over</span>(lambda<span class="op">*</span>e, <span class="dv">1</span> <span class="op">+</span><span class="st"> </span>lambda<span class="op">*</span>h))) <span class="op">+</span><span class="st"> </span><span class="kw">xlab</span>(<span class="kw">bquote</span>(lambda))  <span class="co"># add labels</span></span></code></pre></div>
<div class="figure">
<img src="figs/selectivity-1.png" alt="Selectivity increases with average encounter rates." width="60%" />
<p class="caption">
(#fig:selectivity)Selectivity increases with average encounter rates.
</p>
</div>
<p><strong>Prediction 4</strong> Inclusion of type <span class="math inline">\(m+1\)</span> in the diet does not depend on its encounter rate. Thus, a particular type should be included if the instantaneous net gain of that type is greater than the <em>realized long term average</em> net gain of all the more profitable types. Note that encounter rate appears on the right hand side, but not the left.</p>
<p>So how does this model fair in the real world? Well, the zero-one rule doesn’t work at all; it turns out that for a variety of reasons, foragers do not completely ignore low-profit prey. However, there is great support for the other predictions (above) <span class="citation">(Stephens and Krebs <a href="#ref-Stephens1986" role="doc-biblioref">1986</a>)</span>. Most importantly, in all cases, the theory has provided a clear framework to generate testable predictions from unambiguous assumptions, and that is what we want from efficient theory. The model itself helped guide research, and inclusion of greater complexity has led to deeper understanding of behavior and its consequences for species interactions.</p>
</div>
</div>
<div id="the-patch-model" class="section level2">
<h2><span class="header-section-number">3.2</span> The patch model</h2>
<p><em>…in which omniscient rationale agents roam free.</em></p>
<p>Here the forager asks, “how long should I stay here?” In the simple <em>prey</em> model, a forager searches for and then encounters prey one at a time, makes a decision to consume or not, and then resumes searching. In a simple <em>patch</em> model, a forager searches for and encounters patches one at a time, first consumes resources and then makes a decision to leave or not. Perhaps the single most important prediction of the simple patch model is that a forager should leave a patch when its current rate of energy gain drops down to the average or expected rate of energy gain for the habitat at large.</p>
<p>In what follows, we rely on <span class="citation">Charnov (<a href="#ref-Charnov1976b" role="doc-biblioref">1976</a>)</span>, who applies <em>the marginal-value theorem</em> to explain optimal behavior. Here, as in economics, “marginal value” refers to a rate - the slope of a function. In calculus, this is a derivative. Here, it is the derivative (i.e. slope) of the relation between energy gain and time.</p>
<p>Let’s assume the simplest of all patch models: one patch type, all patches are the same, and they are distributed randomly in the habitat. Assume also that a forager uses time to travel between patches (travel time, <span class="math inline">\(t_t\)</span>) and time searching within a patch (residence time, <span class="math inline">\(t_r\)</span>). A forager encounters patches at random, with a rate of <span class="math inline">\(\lambda\)</span>, and as such, would have a mean time to next encounter of <span class="math inline">\(1/\lambda\)</span>.</p>
The patch is characterisized by its <em>gain function</em> <span class="math inline">\(g(t_r)\)</span> (Fig. @ref(fig:gain)) which is the expected<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>
<em>cumulative net energy gained</em>, given time <span class="math inline">\(t_r\)</span> spent in the patch. The gain function is a cumulative total net amount. We can imagine different types of gain functions.
<div class="figure">
<img src="figs/gain-1.png" alt="Net energy gain as a function of patch residence time may take different forms. Net energy gain increases through time but slows (decelerates) as a greater fraction of the resources in the patch are consumed. The top line (solid) assumes that there are diminishing returns as a patch is depleted, but the forager continues to find resources in excess of metabolic losses. The lower line (dashed) represents the net energy gain that could arise as a patch is depleted more fully and the costs continue unabated." width="75%" />
<p class="caption">
(#fig:gain)Net energy gain as a function of patch residence time may take different forms. Net energy gain increases through time but slows (decelerates) as a greater fraction of the resources in the patch are consumed. The top line (solid) assumes that there are diminishing returns as a patch is depleted, but the forager continues to find resources in excess of metabolic losses. The lower line (dashed) represents the net energy gain that could arise as a patch is depleted more fully and the costs continue unabated.
</p>
</div>
<p><strong>Try this:</strong></p>
<ol style="list-style-type: decimal">
<li>Draw a gain function where the prey remain well hidden at first, but the forager becomes increasingly able to find more and more prey.</li>
<li>Draw a gain function where there is no cost to foraging, and where the forager eventually depletes all the prey.</li>
<li>In one graph, draw two gain functions for a resource rich patch and for a resource poor patch.</li>
</ol>
<p>So, our <em>currency</em> is long-term average energy intake, <span class="math inline">\(R\)</span>, and we want to maximize this. The <em>decision</em> our forager needs to make is how long to stay in a patch. The forager’s <em>constraints</em> share some similarity with the prey model <span class="citation">(Stephens and Krebs <a href="#ref-Stephens1986" role="doc-biblioref">1986</a>)</span>.</p>
<ul>
<li>between-patch travel time and within-patch hunting time are distinct, and …</li>
<li>… independent of each other,</li>
<li>a forager encounters patches sequentially and randomly,</li>
<li>in a given patch, net expected energy gain is a function of time spent in the patch…</li>
<li>…that is zero when <span class="math inline">\(t=0\)</span>, and</li>
<li>…increases with time, but then decelerates</li>
<li>the forager is omniscient - it knows everything about available patches and does not learn anything new as it forages (because it already knows everything).</li>
</ul>
<p>The forager must decide how long to stay in the patch to maximize <span class="math inline">\(R\)</span>. Let
<span class="math display">\[R=\frac{g(t_r)}{t_t + t_r}\]</span>
where <span class="math inline">\(t_t + t_r\)</span> is the total time from leaving one patch, traveling to the next patch, foraging in the second patch, and then leaving the second patch. Think of this as benefit (<span class="math inline">\(g(t)\)</span>) per unit time. This fraction is the slope of the straight line in Fig. @ref(fig:marginal).</p>
<p>Intuitively, we can imagine that the long term average rate of energy gain <span class="math inline">\(R\)</span> is unimodal (hump-shaped) in the following scenario (Fig. @ref(fig:gain)). Upon encountering a patch the forager has no resources and thus <span class="math inline">\(R\)</span> is actually negative due to the costs of traveling to the new patch. As <span class="math inline">\(t_r\)</span> passes and and the forager gains energy (<span class="math inline">\(g(t_r)\)</span> increases), <span class="math inline">\(R\)</span> will increase and become positive. An assumption of the theory (and reality) is that the gain function, <span class="math inline">\(g(t_r)\)</span>, decelerates–the rate of energy intake declines as the patch is depleted. With increasing time in the patch and lower rate of energy intake, <span class="math inline">\(R\)</span> starts to decline.</p>
<p>When <span class="math inline">\(t_r\)</span> is too short, <span class="math inline">\(R\)</span> is not yet maximizes. When <span class="math inline">\(t_r\)</span> is too long, <span class="math inline">\(R\)</span> begins to decline. Because <span class="math inline">\(R\)</span> is hump-shaped, we can use calculus to find its maximum. This will occur when its slope is zero, and the slope of a function, <span class="math inline">\(F\)</span>, is its derivative, <span class="math inline">\(F^\prime\)</span>. If we asssume that travel time is constant, then we can take the partial derivative of <span class="math inline">\(R\)</span> with respect to just the residence time, <span class="math inline">\(t_r\)</span>, <span class="math inline">\(\delta R / \delta t_r\)</span>. First, recall the product rule of differentiation:
<span class="math display">\[F(x) = g(x)f(x)\quad ; \quad F^\prime(x) =f^\prime(x)g(x) +  f(x)g^\prime(x)\]</span>
With that we can find the necessary derivative.
<span class="math display">\[\frac{\delta R}{\delta t_r} = - \frac{1}{(t_t+t_r)^2} g(t_r) + \frac{1}{t_t+t_r}g^\prime(t_r)= g^\prime(t_r) - \frac{g(t_r)}{t_t+t_r}=0\]</span>
Because this derivative equals zero when the slope of the gain function (<span class="math inline">\(g^\prime(t_r)\)</span>) equals <span class="math inline">\(R\)</span>, that tells use that <span class="math inline">\(R\)</span> is maximized at that point. Therefore, it predicts that in order to maximize the long-term average rate, we should stay in a patch until the instantaneous rate, <span class="math inline">\(g^\prime(t_r)\)</span> drops to the long term average rate, <span class="math inline">\(R\)</span> (Fig. @ref(fig:marginal)).</p>
<div class="figure">
<img src="figs/marginal-value.jpg" alt="Energy gain vs. time: The origin is when the forager enters the patch; to the left is time spent traveling from one patch to the next, and to the right is time spent in the patch. The graph represents two different habitats, one in which the patches are easy to get to (habitat 1), and another where it takes more time to get from patch to patch (habitat 2). In all cases, the patches are identical, having the same gain function. The curved line is the gain function, the net energy gain as a function of time spent in the patch. The slope of that curve is the derivative of the gain function. Its slope at any single time point is the instantaneous rate of gain. The two straight lines are the expected gains averaged over time for each habitat as a whole. Lambda is the rate at which a forager randomly encounters patches - because it is a Poisson process, the mean or expected time is 1/lambda. The forager should leave the patch when the instantaneous rate of gain in the patch equals the long term average rate of gain for the habitat as a whole." width="100%" />
<p class="caption">
(#fig:marginal)Energy gain vs. time: The origin is when the forager enters the patch; to the left is time spent traveling from one patch to the next, and to the right is time spent in the patch. The graph represents two different habitats, one in which the patches are easy to get to (habitat 1), and another where it takes more time to get from patch to patch (habitat 2). In all cases, the patches are identical, having the same gain function. The curved line is the gain function, the net energy gain as a function of time spent in the patch. The slope of that curve is the derivative of the gain function. Its slope at any single time point is the instantaneous rate of gain. The two straight lines are the expected gains averaged over time for each habitat as a whole. Lambda is the rate at which a forager randomly encounters patches - because it is a Poisson process, the mean or expected time is 1/lambda. The forager should leave the patch when the instantaneous rate of gain in the patch equals the long term average rate of gain for the habitat as a whole.
</p>
</div>
<p>The simple patch model predicts that when average travel time is greater, foragers will stay longer in a patch. Similarly, the model predicts that when patch quality is lower, foragers stay longer in each patch. Use Fig. @ref(fig:marginal) to construct explanations for these predictions.</p>
<p><strong>Just a starting point</strong></p>
<p>The simple prey and patch models have been extended a great deal to help understand a broad range of foraging situations <span class="citation">(Sih <a href="#ref-Sih2011" role="doc-biblioref">2011</a>)</span>. Simultaneous, rather than sequential, encounters can lead to different predictions. In these cases, energy alone, <span class="math inline">\(e_i\)</span>, rather than profitability, <span class="math inline">\(e_i/h_i\)</span>, may determine prey selection that maximizes the long term mean average rate. Travel time and encounter rates interact with this to explain contrasting situations.</p>
<p>Central place foragers play by slightly different rules <span class="citation">(Stephens and Krebs <a href="#ref-Stephens1986" role="doc-biblioref">1986</a>)</span>. Central place foragers are located in a single location, and remain there. For instance, a parent bird (or dinosaur) finds patches and returns repeatedly to the nest, bringing one or multiple prey items. With parent birds, their fitness depends on offspring viability, and so selection tends to optimize in a manner similar to an organism foraging for themselves. These cases have been built upon patch models, where the question is how to exploit patches that exist at different distances from the nest.</p>
<p>Another example of a central place forager is a spider that acts as a ambush or sit-and-wait predator who remains stationary until a prey item gets close enough to attack. One approach to the spider problem is to consider the distance to the prey as a handling cost and search costs are negligible.</p>
<p>These simple foraging models provide the starting points for a field of inquiry spanning many decades. The interplay between these models, the natural history of species, and experiments have led to greater appreciation of why organisms behave as they do, and the consequences for their evolution and the food webs and ecosystems in which they reside.</p>
<div style="page-break-after: always;"></div>
</div>
<div id="a-simulation-of-a-prey-model" class="section level2">
<h2><span class="header-section-number">3.3</span> A simulation of a prey model</h2>
<p>Next, we embark on a simulation of the simple prey model. We will start with these assumptions:</p>
<ul>
<li>two prey types, <span class="math inline">\(i = {1,2}\)</span></li>
<li>ranked effective energy contents, <span class="math inline">\(e_1 &gt; e_2\)</span></li>
<li>equal handling times, <span class="math inline">\(h_1=h_2=1\)</span></li>
<li>equal relative abundances, <span class="math inline">\(r_1=r_2=0.5\)</span></li>
<li>encounter rates determined by an overall prey encounter rate, <span class="math inline">\(\lambda\)</span>, and the relative abundances where <span class="math inline">\(\lambda_i = \lambda r_i\)</span>.</li>
<li>equal probability of attack if prey is encountered, <span class="math inline">\(p_1=p_2=1\)</span>.</li>
<li>search cost is constant, <span class="math inline">\(c_s=0.01\)</span></li>
</ul>
<p>In addition to these properties, our simulation needs several bookkeeping parameters and variables in order to track the forager energy content. It will need to run for a finite amount of time; we’ll control that with the total search time, <code>Total</code>. Remember that encounter rates are means but that actual encounters are random or stochastic. As a result, our forager may go through lean periods in which their net energy intake is negative.</p>
<p>We need to keep track of total elapsed time, and for each cycle, the search time, search cost, handling time, and energy gain.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>optimal.forager &lt;-<span class="st"> </span><span class="cf">function</span>(</span>
<span id="cb9-2"><a href="#cb9-2"></a>  <span class="dt">e =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">1</span>), <span class="co"># energy content of the prey types</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="dt">h =</span> <span class="kw">c</span>(.<span class="dv">5</span>, <span class="fl">.5</span>), <span class="co"># handling times</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>  <span class="dt">r =</span> <span class="kw">c</span>(.<span class="dv">5</span>, <span class="fl">.5</span>), <span class="co"># relative abundance of prey types: sum(r) = 1</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>  <span class="dt">lambda =</span> <span class="fl">0.4</span>, <span class="co"># overal encounter rate, for all prey combined</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>  <span class="dt">p =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="co"># prob. of attack if encountered</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>  <span class="dt">cs =</span> <span class="fl">0.4</span>, <span class="co"># cost of searching per unit time</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>  <span class="dt">Total =</span> <span class="dv">10</span> <span class="co"># limit to foraging time</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>  ) {</span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="co">###############</span></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="co">### begin foraging</span></span>
<span id="cb9-12"><a href="#cb9-12"></a>ec &lt;-<span class="st"> </span><span class="ot">NULL</span> <span class="co"># an object to tally gains and costs.</span></span>
<span id="cb9-13"><a href="#cb9-13"></a>cycle &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># the cycle count (= search, choose and maybe attack and eat)</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>ct &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># start time of the cyclesan object to tally cycle times.</span></span>
<span id="cb9-15"><a href="#cb9-15"></a>elapsed.time &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># total time spent foraging</span></span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="cf">while</span>( elapsed.time <span class="op">&lt;</span><span class="st"> </span>Total ) {</span>
<span id="cb9-17"><a href="#cb9-17"></a>  <span class="co"># count which search cycle we&#39;re on</span></span>
<span id="cb9-18"><a href="#cb9-18"></a>  (cycle &lt;-<span class="st"> </span>cycle <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</span>
<span id="cb9-19"><a href="#cb9-19"></a>  </span>
<span id="cb9-20"><a href="#cb9-20"></a>  <span class="co"># a random amount of search time, t.s, until it finds something.</span></span>
<span id="cb9-21"><a href="#cb9-21"></a>  (lambda.r &lt;-<span class="st"> </span>lambda <span class="op">*</span><span class="st"> </span>r)</span>
<span id="cb9-22"><a href="#cb9-22"></a>  (ts &lt;-<span class="st"> </span><span class="kw">rexp</span>(<span class="dv">2</span>, <span class="dt">rate=</span>lambda.r))</span>
<span id="cb9-23"><a href="#cb9-23"></a>  <span class="cf">if</span>(ts[<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>ts[<span class="dv">2</span>]) i &lt;-<span class="st"> </span><span class="dv">1</span> <span class="cf">else</span> i &lt;-<span class="st"> </span><span class="dv">2</span></span>
<span id="cb9-24"><a href="#cb9-24"></a>  i</span>
<span id="cb9-25"><a href="#cb9-25"></a>  <span class="co"># cost of searching for that time</span></span>
<span id="cb9-26"><a href="#cb9-26"></a>  (cost.s &lt;-<span class="st"> </span>ts[i] <span class="op">*</span><span class="st"> </span>cs)</span>
<span id="cb9-27"><a href="#cb9-27"></a></span>
<span id="cb9-28"><a href="#cb9-28"></a>  <span class="co"># choose to attack the encountered item with probability p</span></span>
<span id="cb9-29"><a href="#cb9-29"></a>  (gain &lt;-<span class="st"> </span><span class="cf">if</span>(p[i] <span class="op">&gt;</span><span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)){e[i]} <span class="cf">else</span> {<span class="dv">0</span>})</span>
<span id="cb9-30"><a href="#cb9-30"></a>  </span>
<span id="cb9-31"><a href="#cb9-31"></a>  <span class="co"># observed handling time </span></span>
<span id="cb9-32"><a href="#cb9-32"></a>  <span class="cf">if</span>(gain <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> ){</span>
<span id="cb9-33"><a href="#cb9-33"></a>    h.obs &lt;-<span class="st"> </span>h[i]</span>
<span id="cb9-34"><a href="#cb9-34"></a>    h.obs</span>
<span id="cb9-35"><a href="#cb9-35"></a>  } <span class="cf">else</span> {</span>
<span id="cb9-36"><a href="#cb9-36"></a>    h.obs &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb9-37"><a href="#cb9-37"></a>  }</span>
<span id="cb9-38"><a href="#cb9-38"></a>   h.obs</span>
<span id="cb9-39"><a href="#cb9-39"></a> (cycle.time &lt;-<span class="st"> </span>ts[i] <span class="op">+</span><span class="st"> </span>h.obs )</span>
<span id="cb9-40"><a href="#cb9-40"></a> ct &lt;-<span class="st"> </span><span class="kw">c</span>(ct, cycle.time)</span>
<span id="cb9-41"><a href="#cb9-41"></a> (elapsed.time &lt;-<span class="st"> </span>elapsed.time <span class="op">+</span><span class="st"> </span>cycle.time)</span>
<span id="cb9-42"><a href="#cb9-42"></a> (ec &lt;-<span class="st"> </span><span class="kw">c</span>(ec, gain <span class="op">-</span><span class="st"> </span>cost.s))</span>
<span id="cb9-43"><a href="#cb9-43"></a>}</span>
<span id="cb9-44"><a href="#cb9-44"></a>df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">net.e =</span> ec, <span class="dt">cycle.start =</span> <span class="kw">cumsum</span>(ct[<span class="dv">1</span><span class="op">:</span>cycle]))</span>
<span id="cb9-45"><a href="#cb9-45"></a>params &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">e=</span>e, <span class="dt">h=</span>h, <span class="dt">r=</span>r, <span class="dt">lambda=</span>lambda, <span class="dt">p=</span>p, <span class="dt">cs=</span>cs, <span class="dt">Total=</span>Total)</span>
<span id="cb9-46"><a href="#cb9-46"></a>  out &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">N =</span> cycle, <span class="dt">G =</span> <span class="kw">sum</span>(ec), <span class="dt">Tt =</span> <span class="kw">sum</span>(ct), </span>
<span id="cb9-47"><a href="#cb9-47"></a>              <span class="dt">series =</span> df,</span>
<span id="cb9-48"><a href="#cb9-48"></a>              <span class="dt">params =</span> params)</span>
<span id="cb9-49"><a href="#cb9-49"></a>  <span class="kw">return</span>(out)</span>
<span id="cb9-50"><a href="#cb9-50"></a>}</span></code></pre></div>
<p>Here we let the forager forage for 60 minutes and then examine the structure of the output object.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>myOut &lt;-<span class="st"> </span><span class="kw">optimal.forager</span>(<span class="dt">Total=</span><span class="dv">60</span>)</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="kw">str</span>(myOut)</span></code></pre></div>
<pre><code>## List of 5
##  $ N     : num 17
##  $ G     : num 4.09
##  $ Tt    : num 60.8
##  $ series:&#39;data.frame&#39;:	17 obs. of  2 variables:
##   ..$ net.e      : num [1:17] 1.911 1.35 0.551 0.533 1.822 ...
##   ..$ cycle.start: num [1:17] 0 0.723 2.848 4.471 6.137 ...
##  $ params:List of 7
##   ..$ e     : num [1:2] 2 1
##   ..$ h     : num [1:2] 0.5 0.5
##   ..$ r     : num [1:2] 0.5 0.5
##   ..$ lambda: num 0.4
##   ..$ p     : num [1:2] 1 1
##   ..$ cs    : num 0.4
##   ..$ Total : num 60</code></pre>
<ul>
<li>N is the number of foraging cycles</li>
<li>G is net energy gain</li>
<li>Tt is total elapsed time</li>
<li>series is a dataframe with two variables: net.e is energy gain minus search costs for each cycle, and cycle.start is the elapsed time at which each cycle starts</li>
<li>params is a list that includes all the parameters we used in this run</li>
</ul>
<p>Now let’s graph something, because graphs are fun.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">ggplot</span>(myOut<span class="op">$</span>series, <span class="kw">aes</span>(<span class="dt">x=</span>cycle.start, <span class="dt">y=</span><span class="kw">cumsum</span>(net.e))) <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>() </span></code></pre></div>
<div class="figure">
<img src="figs/oft1-1.png" alt="The cumulative energy capital of a forager goes down while searching and handling resource items, but increases each time the prey is assimilated." width="90%" />
<p class="caption">
(#fig:oft1)The cumulative energy capital of a forager goes down while searching and handling resource items, but increases each time the prey is assimilated.
</p>
</div>
<p><em>Use this simulation</em> to help solidify in your own mind predictions of the simple prey model. How should we do that?</p>
<p>What is the prediction we are interested in?</p>
<p>Prediction: Include type 2 if
<span class="math display">\[\begin{equation}
\frac{e_2}{h_2} &gt; \frac{\lambda_1 e_1 }{1 + \lambda_1 h_1} (\#eq:prediction)
\end{equation}\]</span></p>
<div class="figure">
<img src="figs/preypred-1.png" alt="The right hand side of our prediction" width="100%" />
<p class="caption">
(#fig:preypred)The right hand side of our prediction
</p>
</div>
<p>To get a sense of what our prediction @ref(eq:prediction) means, we should graph the righthand quantity as a function of one relevant variable, such as energy content of type 1, or the encounter rate (Fig. @ref(fig:preypred)). The parameters that determined these curves are:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">unlist</span>( myOut<span class="op">$</span>params )</span></code></pre></div>
<pre><code>##     e1     e2     h1     h2     r1     r2 lambda     p1     p2     cs  Total 
##    2.0    1.0    0.5    0.5    0.5    0.5    0.4    1.0    1.0    0.4   60.0</code></pre>
<div id="lab-exercise" class="section level3">
<h3><span class="header-section-number">3.3.1</span> Lab exercise</h3>
<ol style="list-style-type: decimal">
<li>Do these parameter values suggest that our forager should or should not include prey type 1 in her diet?</li>
<li>Create parameter combinations for which the forager (i) should and (ii) should not include prey type 2.</li>
<li>Use the simulation <code>optimal.forager()</code> to confirm your predictions.</li>
</ol>
<!--chapter:end:02-optimal_foraging.Rmd-->
</div>
</div>
</div>
<div id="expo" class="section level1">
<h1><span class="header-section-number">4</span> Simple density-independent growth</h1>
<div class="figure">
<img src="figs/Melospiza1-1.png" alt="Song Sparrow (Melospiza melodia) counts in Darrtown, OH, USA. From  Sauer, J. R., J.E. Hines, and  J. Fallon. 2005. The North American Breeding Bird Survey, Results and Analysis 1966--2004. Version 2005.2. USGS Patuxent Wildlife Research Center, Laurel, MD." width="70%" />
<p class="caption">
(#fig:Melospiza1)Song Sparrow (Melospiza melodia) counts in Darrtown, OH, USA. From Sauer, J. R., J.E. Hines, and J. Fallon. 2005. The North American Breeding Bird Survey, Results and Analysis 1966–2004. Version 2005.2. USGS Patuxent Wildlife Research Center, Laurel, MD.
</p>
</div>
<div class="figure">
<img src="figs/Melospiza2-1.png" alt="Song Sparrow (Melospiza melodia) annual changes in population size as a function of population size." width="70%" />
<p class="caption">
(#fig:Melospiza2)Song Sparrow (Melospiza melodia) annual changes in population size as a function of population size.
</p>
</div>
<p>Between 1966 and 1971, Song Sparrow (<em>Melospiza melodia</em>) abundance in Darrtown, OH, USA, seemed to increase very quickly, perhaps unimpeded by any particular factor (Fig. @ref{fig:Melospiza1}, @ref{fig:Melospiza2}). In an effort to manage this population, we may want to predict its future population size. We may also want to describe its growth rate and population size in terms of mechanisms that could influence its growth rate. We may want to compare its growth and relevant mechanisms to those of other Song Sparrow populations or to other passerine populations. To do this, we start with the simplest of all population phenomena, geometric and exponential growth.</p>
<p>Geometric and exponential growth are examples of <em>density-independent growth</em>. This captures the fundamental process of reproduction (e.g., making seeds or babies) results in a <em>geometric series</em>.<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a> For instance, one cell divides to make two, those two cells each divide to make four, and so on, where reproduction for each cell results in two cells, <em>regardless of how many other cells are in the population</em>—that is what we mean by <em>density-independent</em>. This myopically observed event of reproduction, whether one cell into two, or one plant producing many seeds, is the genesis of a geometric series. Therefore, most models of populations include this
fundamental process of geometric increase. Second, populations can grow in a density-independent fashion when resources are plentiful. It behooves us to start with this simple model because most, more complex population models include this process.</p>
<p><span class="citation">Hastings (<a href="#ref-Hastings2011" role="doc-biblioref">2011</a>)</span> proposes that we can approach single species poulation growth from either a microscopic or macroscopic point of view. The microscopic approach begins with two propositions. The first is that if we know the location, timing, and traits of all individuals, we can predict perfectly population dynamics; the second is that we can never predict dynamics perfectly because births and deaths are fundamentally random and can be described only with probabilities.<a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a> With this microscopic approach, we would seek a very detailed description of individuals and build a complex model to understand the consequences of the characteristics of all these interacting individuals, including the growth of the poppulation.</p>
<p>In this chapter, I choose to start with Hastings’ macroscopic approach. These propositions appear simpler.</p>
<ol style="list-style-type: decimal">
<li>A population grows exponentially in the absence of other forces.</li>
<li>There are forces that can prevent a population from growing exponentially.</li>
</ol>
<p>These are the consequences of the following assumptions.</p>
<ol style="list-style-type: lower-alpha">
<li>all individuals in a population are identical.</li>
<li>there is no migration in or out of the population.
c1. the number of offspring per individual (or the per capita birth and death rates) are constant through time, and …
c2. … independent of the number of individuals in the population.</li>
</ol>
<p>Deviations from these assumptions lead to all of the most interesting parts of single species population dynamics <span class="citation">(Hastings <a href="#ref-Hastings2011" role="doc-biblioref">2011</a>)</span>. The only deviation we play with in this chapter concerns assumption c; we model stochastic variation in population growth rate to investigate extinction risk. It is also worth mentioning that, although propositions 1 and 2 follow from assumptions a-d, they are not strictly necessary <span class="citation">(Hastings <a href="#ref-Hastings2011" role="doc-biblioref">2011</a>)</span>. For instance, individuals need not be identical, and we deal with a big exception in the next chapter where we introduce structured population growth. Also, migration is admissable, provided immigration = emigration and it does not alter growth rates. Nonetheless, other deviations from a. and b. can have very important consequences for single species population dynamics.</p>
<p>Here we define Density-independence<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a> in a real population as a lack of a statistical relation between the density of a population, and its <em>per capita</em> growth rate. The power to detect a significant relation between any two continuous variables depends on those factors which govern statistical power, such as the number of observations, the range of the predictor variable, and the strength of the underlying relation. Therefore, our conclusion, that a particular population exhibits density-independent growth, may be trivial if our sample size is small, with few generations sampled, or if we sampled the population over a very narrow range of densities. Nonetheless, it behooves us to come back to this definition if, or when, we get caught up in the biology of a particular organism.</p>
<p>In this chapter, we’ll introduce density-independent population <em>projection</em>, <em>growth</em>, and <em>per capita growth</em>, for populations with synchronous reproduction (discrete models), and continuous reproduction (continuous models).</p>
<div id="discrete-growth-rates-of-fruit-flies-in-my-kitchen" class="section level2">
<h2><span class="header-section-number">4.1</span> Discrete growth rates of fruit flies in my kitchen</h2>
<p>Summertime, and the living is easy. Fruit flies in my kitchen, and their number’s quite high. Flies love my ripe fruit, and my red wine. They drown in the wine–I am not sure if that is good or bad.</p>
<p>For now, we’ll treat fruit flies as if they grow in discrete generations. This is very common for populatilons that live in seasonal habitats - their reproduction is timed to the season, and they breed altogether in one bout.<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a></p>
<p>I count the number of flies every week, and I find these numbers:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a>t &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="cb15-2"><a href="#cb15-2"></a>N &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">8</span>, <span class="dv">16</span>)</span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="kw">qplot</span>(<span class="dt">x=</span>t, <span class="dt">y=</span>N, <span class="dt">geom=</span><span class="kw">c</span>(<span class="st">&quot;line&quot;</span>, <span class="st">&quot;point&quot;</span>) )</span></code></pre></div>
<p><img src="figs/flies-1.png" width="60%" /></p>
<p>There are several ways we can describe fruit fly population growth. We begin by thinking about the proximate causes of change to population size per unit time: births, immigration, death and emigration (Fig. @ref(fig:fliesi)). Those are the only options, and we state it thus:
<span class="math display">\[\frac{\Delta N}{\Delta t} = \frac{B + I - D - E}{\Delta t}\]</span>
that is, the pop growthe rate<a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a> is determined by the numbers of births, deaths, and migrants per unit time.</p>
<p>Over the past month, I suspect the fruit flies are increasing primarily through reproduction in my kitchen. Clearly, at some point in the past, a fly or two (or three) must have immigrated into my kitchen, either as adults or as eggs or larvae in fruit I brought home (<span class="math inline">\(I&gt;0\)</span>). For now, I will assume fruit fly population dynamics in my kitchen are governed by only births and deaths (<span class="math inline">\(I=E=0\)</span>), so, we have
<span class="math display">\[ \frac{N_{t+1} - N_t}{(t+1) - t}=\frac{\Delta N}{\Delta t}=\frac{B+D}{\Delta t}\]</span>
In this equation, <span class="math inline">\(t\)</span> has a particular time unit, one week, so <span class="math inline">\(t+1\)</span> is one additional week. We refer to a population like this as <em>closed</em>, because it is closed to migration in or out.</p>
<div class="figure">
<img src="figs/fliesi-1.png" alt="The number of fruit flies in my kitchen depends on immigration and emigration, and births and deaths. In the text, we assume that immigration and emigration are zero. All rates are individuals per unit time." width="100%" />
<p class="caption">
(#fig:fliesi)The number of fruit flies in my kitchen depends on immigration and emigration, and births and deaths. In the text, we assume that immigration and emigration are zero. All rates are individuals per unit time.
</p>
</div>
<p>I would like to represent births and deaths as proportions of existing adults. that is, as
<span class="math display">\[B = bN;\quad D=dN\]</span>
This reflects the biological realities that adults produce offspring, and everyone has some chance of dying. The parameter <span class="math inline">\(b\)</span> could be any positive real number, <span class="math inline">\(b \ge 0\)</span>. This model of births reflects the geometric property of reproduction: over a specified time interval <span class="math inline">\(\Delta t\)</span>, an average parent makes <span class="math inline">\(b\)</span> babies. Parameter <span class="math inline">\(d\)</span> is any real number between zero and one, <span class="math inline">\(0 \le d \le 1\)</span>. Both <span class="math inline">\(b\)</span> and <span class="math inline">\(d\)</span> have units of individuals per individual per unit time. They depend on that unit of time.</p>
<p><em>What if offspring die before the next census?</em></p>
<p>Fig. @ref(fig:fliesi) helps us think about these things. Simplifying, we’ll assume births occur first, and then death comes to offspring and adults.</p>
<p>Let’s define a few terms.</p>
<ul>
<li><span class="math inline">\(N_0\)</span>, <span class="math inline">\(N_1\)</span> - the number of flies at the start and after the first time interval.</li>
<li><span class="math inline">\(N^\prime\)</span>, <span class="math inline">\(N^{\prime\prime}\)</span> - distinct values of <span class="math inline">\(N\)</span>, just after births.</li>
<li><span class="math inline">\(\Delta N\)</span> - the <em>change</em> in <span class="math inline">\(N\)</span> from one point in time to another.</li>
<li><span class="math inline">\(t\)</span> is time, so <span class="math inline">\(\Delta t\)</span> is the time interval over which <span class="math inline">\(N\)</span> may change.</li>
</ul>
<p>Let’s match these numbers to what is going on in my kitchen. For my first census count, <span class="math inline">\(t=0\)</span>, I counted the adults and label that number <span class="math inline">\(N_0\)</span>. These adults lay eggs which hatch, larvae and pupae develop, and become adults, giving us a population of <span class="math inline">\(N^\prime = N_0 + bN\)</span></p>
<p>Some of the eggs fail to hatch, and some of the larvae die
before maturing. Many of the adults die as well. If we assume the eggs,
larvae, and adults all die at the same rate, then by the end of one
generation we have <span class="math inline">\(N_1 = dN^\prime = d(N_0 + bN)\)</span>.</p>
<p>Substituting and multiplying we get
<span class="math display">\[ N_1 = N_0 + bN_0 - d\left(N_0 + bN_0\right)\]</span></p>
<p>We see that by the next time point, <span class="math inline">\(t=1\)</span>, the number of fruit flies
should be equal to the number we started with, <span class="math inline">\(N_0\)</span>, plus the number
of new individuals, <span class="math inline">\(bN_0\)</span>, minus the number of original adults that
die, <span class="math inline">\(dN_0\)</span>, and minus the number of new individuals that die, <span class="math inline">\(dbN_0\)</span>.</p>
<p>We can pull all of these parameters together,
<span class="math display">\[ N_1 = N_0 + bN_0 - dN_0 - dbN_0 \]</span>
<span class="math display">\[ N_1 - N_0 =  N_0 \left(b - d - db\right)
= N_0 + r_dN_0 (\#eq:bddb)\]</span></p>
<p>where <span class="math inline">\(r_d = b - d - db\)</span>.</p>
<p>The <em>growth rate</em> of the population is <span class="math inline">\(\Delta N / \Delta t\)</span>, or, at <span class="math inline">\(t=0\)</span>, is
<span class="math display">\[\frac{\Delta N}{\Delta t} = \frac{N_1 - N_0}{t_1-t_0} = \frac{(N_0 + r_dN_0) - N_0}{t_1-t_0} = r_d N_0 \]</span>
If we generalize, we drop the zero, to get <span class="math inline">\(r_dN\)</span>. The <em>per capita</em> population growth rate is <span class="math inline">\(r_dN/N =r_d\)</span>). If our time step were something other than 1, we would also divide by <span class="math inline">\(\Delta t\)</span>.</p>
<p>With the simple census data above, we can
estimate <span class="math inline">\(r_d\)</span> for the first time step.
<span class="math display">\[N_1 = N_0 + r_dN_0=  2 + r_d (2) \implies r_d=1\]</span>
If we know that <span class="math inline">\(r_d\)</span> is constant over time, we can infer a general rule to project the population forward in time an arbitrary number of time steps. We will let <span class="math inline">\(\lambda = 1+r_d\)</span>.
<span class="math display">\[N_1 = N_0 + r_dN_0 = N_0(1 + r_d) = N_0\lambda\]</span>
<span class="math display">\[N_2 = N_1\lambda=  (N_0 \lambda)\lambda\]</span>
<span class="math display">\[N_3 = N_2\lambda=  (N_0 \lambda)\lambda\lambda\]</span>
or simply,
<span class="math display">\[N_t = N_0\lambda^t\]</span></p>
<p>To summarize our model of discrete population growth, we have the following statements:</p>
<p><strong>Projection:</strong>
<span class="math display">\[N_t = N_0\lambda^t\]</span></p>
<p><strong>Population growth rate:</strong>
<span class="math display">\[\frac{\Delta N}{\Delta t} = r_dN; \quad \mathrm{where~} \lambda=1+r_d\]</span></p>
<p><strong>Per capita opulation growth rate:</strong>
<span class="math display">\[\frac{\Delta N}{N\Delta t} = r_d\]</span></p>
<p>At last, we see how this is a model of density-independent growth: per capita growth rate does not include <span class="math inline">\(N\)</span>.</p>
</div>
<div id="fruit-flies-with-continuous-overlapping-generations" class="section level2">
<h2><span class="header-section-number">4.2</span> Fruit flies with continuous overlapping generations</h2>
<p>In the reality that is my kitchen, individual fruit flies are having sex and reproducing on their own schedules. As a population, they breed continuously, so the cohorts re not synchronous. For populations like that, we need to describe instantaneous growth rates, where <span class="math inline">\(\Delta t\)</span> is no longer a fixed period of time, but is an instant, or infinity small.</p>
<p>We return to our example above (Fig. @ref(fig:fliesi)), which we summarize in @ref(eq:bddb). Please take a look at that equation; here we make time explicit so that it appears in the equation. We begin by remembering that <span class="math inline">\(b\)</span> and <span class="math inline">\(d\)</span> have time units.</p>
<ul>
<li>Let <span class="math inline">\(\Delta t\)</span> be a small fraction of <span class="math inline">\(t\)</span>, so that the time step goes from <span class="math inline">\(t\)</span> to <span class="math inline">\(t + \Delta t\)</span>.</li>
<li>As <span class="math inline">\(\Delta t \rightarrow 0\)</span>, <span class="math inline">\(b\)</span> and <span class="math inline">\(d\)</span> need to shrink as well, to <span class="math inline">\(\Delta t b\)</span> and <span class="math inline">\(\Delta t d\)</span>.</li>
<li><span class="math inline">\(dN/dt\)</span> is how we identify the differential equation that is the instantaneous rate of population growth, with lower case <span class="math inline">\(d\)</span> symbolizing infinitesimally small change.</li>
</ul>
<p>We now have to solve for the limit of <span class="math inline">\(\Delta N /\Delta t\)</span> as <span class="math inline">\(\Delta t\)</span> goes to zero.
<span class="math display">\[\frac{dN}{dt}=\lim_{\Delta t \rightarrow 0} \frac{N_{t+\Delta t} - N_t}{\Delta t} = \lim_{\Delta t \rightarrow 0} \frac{\Delta t\,bN_t - \Delta t \,dN_t - \Delta t\, d (\Delta t\, b)N_t}{\Delta t} \]</span>
If we divide through by <span class="math inline">\(\Delta t\)</span> and then let <span class="math inline">\(\Delta t \rightarrow 0\)</span>, we get
<span class="math display">\[\frac{dN}{dt}=\lim_{\Delta t \rightarrow 0} bN_t - dN_t - \Delta t\, d bN_t = bN_t - dN_t=rN\]</span></p>
<p>To arrive at the projection equation for a continuously growing population, we integrate <span class="math inline">\(rN\)</span> with respect to time. Integration is the cumulative summing of <span class="math inline">\(y\)</span> across a range of <span class="math inline">\(x\)</span>. It even uses an exagerated “S” to indicate summation, <span class="math inline">\(\int\)</span>. Here we integrate population growth across time. We start by rearranging
<span class="math display">\[\frac{dN}{dt} = rN \Rightarrow \frac{dN}{N} = r dt\]</span></p>
<p>Now we integrate from <span class="math inline">\(N\)</span> and <span class="math inline">\(r\)</span> from <span class="math inline">\(t=0\)</span> to <span class="math inline">\(t=t\)</span>,
<span class="math display">\[\int_{N_0}^{N_t} \frac{1}{N}dN = \int_{0}^{t}rdt\]</span>
<span class="math display">\[\ln(N_t) - \ln(N_0) = rt - r\,0\]</span>
<span class="math display">\[\ln(N_t) = \ln(N_0) + rt\]</span>
We now exponentiate (<span class="math inline">\(e^x\)</span>) both sides to arrive at our projection equation.
<span class="math display">\[N_t = e^{\ln(N_0) + rt} = N_0 e^{rt}\]</span></p>
<p>To summarize our model of continuous population growth, we have the following statements.</p>
<p><strong>Projection:</strong>
<span class="math display">\[N_t = N_0 e^{rt}\]</span></p>
<p><strong>Population growth rate:</strong>
<span class="math display">\[\frac{dN}{dt} = rN\]</span></p>
<p><strong>Per capita population growth rate:</strong>
<span class="math display">\[\frac{dN}{Ndt} = r\]</span>
Once again, we see why we refer to exponential growth as density-independent: the per capita growth rate does not depend on <span class="math inline">\(N\)</span>.</p>
</div>
<div id="properties-of-geometric-and-exponential-growth" class="section level2">
<h2><span class="header-section-number">4.3</span> Properties of geometric and exponential growth</h2>
<p>Compare the projection equations for geometric and exponential growth. We find that
<span class="math display">\[\lambda = e^{r} \quad ; \quad \ln \lambda = r\]</span>
This gives us a few useful rules of thumb.</p>
<ul>
<li>No change: <span class="math inline">\(r = 0\quad;\quad\lambda =1\)</span></li>
<li>Growing population: <span class="math inline">\(r &gt; 0 \quad;\quad \lambda &gt; 1\)</span></li>
<li>Shrinking population: <span class="math inline">\(r &lt; 0 \quad;\quad \lambda &lt; 1\)</span></li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="co"># Let r take on three values</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>r &lt;-<span class="st"> </span><span class="kw">c</span>( <span class="dv">-1</span>, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co"># Convert to lambda</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="kw">exp</span>(r)</span></code></pre></div>
<pre><code>## [1] 0.3678794 1.0000000 2.7182818</code></pre>
<p><em>Time scaling</em> This is a useful property if we ever want to change time units in a discrete model. We must first <span class="math inline">\(\lambda\)</span> to <span class="math inline">\(r\)</span>, change units in <span class="math inline">\(r\)</span> and convert back to <span class="math inline">\(\lambda\)</span>. For instance, if we find that the annual finite rate of increase for a population of crickets is <span class="math inline">\(\lambda = 1.2\)</span>, we cannot convert that to a monthly rate of <span class="math inline">\(1.2/12 = 0.1\)</span>. Instead we convert to <span class="math inline">\(r\)</span> and back to <span class="math inline">\(\lambda\)</span>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a>lambda &lt;-<span class="st"> </span><span class="fl">1.2</span></span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="co"># Convert lambda to r </span></span>
<span id="cb18-4"><a href="#cb18-4"></a>r &lt;-<span class="st"> </span><span class="kw">log</span>(lambda); r</span></code></pre></div>
<pre><code>## [1] 0.1823216</code></pre>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a><span class="co"># Scale r from year to month</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>r2 &lt;-<span class="st"> </span>r<span class="op">/</span><span class="dv">12</span>; r2</span></code></pre></div>
<pre><code>## [1] 0.01519346</code></pre>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a><span class="co"># Convert back to lambda (per month)</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>lambda2 &lt;-<span class="st"> </span><span class="kw">exp</span>(r2); lambda2</span></code></pre></div>
<pre><code>## [1] 1.015309</code></pre>
<p>This is very, very different than <span class="math inline">\(\lambda/12\)</span>.</p>
<p><em>Doubling time</em> Sometimes we gain a more intuitive grasp of an idea when we convert to a different form of the same relationship. Exponential growth is one of those ideas that can be hard to grasp. A more intuitive way to compare or express exponential grwoth rate is through <em>doubling time</em>, the time required for the population to double in size. For instance, a per capita growth rate of <span class="math inline">\(r = 0.14\,\mathrm{inds}\cdot \mathrm{ind}^{-1} \mathrm{y}^{-1}\)</span> means that the population will double in less than 5 years.</p>
<p>We determine this by letting <span class="math inline">\(N_t = 2N_0\)</span>.
<span class="math display">\[2N_0 = N_0 e^{rt}\]</span>
<span class="math display">\[\ln 2 = rt\]</span>
<span class="math display">\[t =\frac{\ln 2}{r}\]</span></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a><span class="co"># let r be a sequence from </span></span>
<span id="cb24-2"><a href="#cb24-2"></a>r &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.01</span>, <span class="fl">0.05</span>, <span class="fl">0.1</span>, <span class="fl">0.5</span>)</span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="co">#doubling time will be</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="kw">log</span>(<span class="dv">2</span>)<span class="op">/</span>r</span></code></pre></div>
<pre><code>## [1] 69.314718 13.862944  6.931472  1.386294</code></pre>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1"></a><span class="co"># and a picture</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="kw">par</span>(<span class="dt">mgp=</span><span class="kw">c</span>(<span class="fl">1.2</span>, <span class="fl">.2</span>, <span class="dv">0</span>), <span class="dt">mar=</span><span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>), <span class="dt">tcl=</span><span class="op">-</span>.<span class="dv">2</span>)</span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="kw">curve</span>( <span class="kw">log</span>(<span class="dv">2</span>)<span class="op">/</span>x, <span class="dt">xlab=</span><span class="st">&quot;r&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;Doubling time&quot;</span>)</span></code></pre></div>
<div class="figure">
<img src="figs/doubling-1.png" alt="Doubling time is inversely related to the intrinsic rate of increase, r." width="60%" />
<p class="caption">
(#fig:doubling)Doubling time is inversely related to the intrinsic rate of increase, r.
</p>
</div>
<div id="average-growth-rate" class="section level3">
<h3><span class="header-section-number">4.3.1</span> Average growth rate</h3>
<p>In any real data set, such as from a real population of fruit flies or Song Sparrows, <span class="math inline">\(N_{t+1}/N_t\)</span> will vary from year to year. How do we calculate an average growth rate for a fluctuating population?</p>
<p>Let’s consider the case where a population increases and then decreases. For each year, we will calculate the annual rate of increase <span class="math inline">\(R = N_{t+1}/N_t\)</span>, and take the arithmetic average of those rates to see if it makes sense.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a>N &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">15</span>, <span class="dv">15</span>)</span>
<span id="cb27-2"><a href="#cb27-2"></a>R &lt;-<span class="st"> </span>N[<span class="dv">2</span><span class="op">:</span><span class="dv">4</span>]<span class="op">/</span>N[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>]; R</span></code></pre></div>
<pre><code>## [1] 1.5 0.5 1.0</code></pre>
<p>The arithmetic average of those rates is <span class="math inline">\((1.5 + 0.5 + 1.0)/3=1.0\)</span>. If <span class="math inline">\(R=1.0\)</span>, then, on average, the population should stay the same, but it decreased. Why is that?</p>
<p>Let us do the annual time steps explicitly to see what is going on.
<span class="math display">\[N_3 = (N_0 R_0) R_1 R_2\]</span></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1"></a><span class="co"># Remember that we call the first time t=0 and N0, but</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="co"># when coding, these values are the first in a series, so </span></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="co"># N0 is N[1]</span></span>
<span id="cb29-4"><a href="#cb29-4"></a></span>
<span id="cb29-5"><a href="#cb29-5"></a><span class="co"># Now we do the annual changes which should equal N3</span></span>
<span id="cb29-6"><a href="#cb29-6"></a>N[<span class="dv">1</span>]<span class="op">*</span>R[<span class="dv">1</span>]<span class="op">*</span>R[<span class="dv">2</span>]<span class="op">*</span>R[<span class="dv">3</span>]</span></code></pre></div>
<pre><code>## [1] 15</code></pre>
<p>From this calculation, we see that when we start with <span class="math inline">\(N_0=20\)</span> and do the annaul steps, we wind up with a smaller population, even though the arithmetic average is <span class="math inline">\(R_{\mathrm{ave}} = 1\)</span>. How do we calculate an average of numbers that we multiply together?</p>
<p>We want a number <span class="math inline">\(\bar{R}\)</span> such that
<span class="math display">\[\bar{R}^t = R_1R_2\ldots R_t\]</span></p>
<p>To find that, we simply solve for <span class="math inline">\(\bar{R}\)</span>
<span class="math display">\[(\bar{R}^t)^{1/t} =\bar{R} = \left(R_1R_2\ldots R_t\right)^{1/t}\]</span>
We take the <span class="math inline">\(t\)</span>-th root of the product of all the <span class="math inline">\(R\)</span>. This is called the <em>geometric average.</em> Another way of writing this would be to use the product symbol, as in
<span class="math display">\[\bar{R} = \left(\prod_{i=1}^t R_i\right)^{1/t}\]</span></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1"></a>R</span></code></pre></div>
<pre><code>## [1] 1.5 0.5 1.0</code></pre>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1"></a><span class="co">#arithmetic average</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="kw">mean</span>(R)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1"></a><span class="co"># geometric average</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>t &lt;-<span class="st"> </span><span class="kw">length</span>(R); t</span></code></pre></div>
<pre><code>## [1] 3</code></pre>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">prod</span>(R)<span class="op">^</span>(<span class="dv">1</span><span class="op">/</span>t)</span></code></pre></div>
<pre><code>## [1] 0.9085603</code></pre>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1"></a><span class="co"># shows the population should decline</span></span></code></pre></div>
<p>Another way to do the same thing is to take the arithmethic mean of the log-growth rates, and back-transform,</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1"></a><span class="kw">exp</span>( <span class="kw">mean</span>( <span class="kw">log</span>(R) ) )</span></code></pre></div>
<pre><code>## [1] 0.9085603</code></pre>
<p>Now we see the effect of calculating the average growth rate correctly. This leads to a useful rule of thumb: <em>random variation in growth rate suppresses population growth.</em> Here we illustrate that. We start with a growing population.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1"></a>lambda &lt;-<span class="st"> </span><span class="fl">1.01</span> <span class="co"># positive growth rate</span></span>
<span id="cb42-2"><a href="#cb42-2"></a>N0 &lt;-<span class="st"> </span><span class="dv">100</span> <span class="co"># starting N</span></span>
<span id="cb42-3"><a href="#cb42-3"></a>t &lt;-<span class="st"> </span><span class="dv">20</span> <span class="co"># 20 years</span></span>
<span id="cb42-4"><a href="#cb42-4"></a>Nt1 &lt;-<span class="st"> </span>N0<span class="op">*</span>lambda<span class="op">^</span>t; Nt1</span></code></pre></div>
<pre><code>## [1] 122.019</code></pre>
<p>Here <span class="math inline">\(\lambda &gt; 1\)</span>, so the population grows.</p>
<p>Now we do a simulation in which we let <span class="math inline">\(\lambda\)</span> have a mean of 1.01 but allow it to vary randomly.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1"></a><span class="co"># create a vector to hold all N</span></span>
<span id="cb44-2"><a href="#cb44-2"></a>N &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, t); N[<span class="dv">1</span>] &lt;-<span class="st"> </span>N0</span>
<span id="cb44-3"><a href="#cb44-3"></a></span>
<span id="cb44-4"><a href="#cb44-4"></a><span class="co"># create t-1 random lambdas with a mean of 1.01 </span></span>
<span id="cb44-5"><a href="#cb44-5"></a><span class="co"># ranging from 0.41 to 1.61</span></span>
<span id="cb44-6"><a href="#cb44-6"></a><span class="kw">set.seed</span>(<span class="dv">3</span>) <span class="co"># makes the radnom sequence repeatable</span></span>
<span id="cb44-7"><a href="#cb44-7"></a>random.lambda &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dt">n=</span>(t<span class="dv">-1</span>), <span class="dt">min=</span><span class="fl">0.41</span>, <span class="dt">max=</span><span class="fl">1.61</span>)</span>
<span id="cb44-8"><a href="#cb44-8"></a></span>
<span id="cb44-9"><a href="#cb44-9"></a><span class="co"># the geometric mean</span></span>
<span id="cb44-10"><a href="#cb44-10"></a><span class="kw">prod</span>(random.lambda)<span class="op">^</span>(<span class="dv">1</span><span class="op">/</span><span class="kw">length</span>(random.lambda))</span></code></pre></div>
<pre><code>## [1] 1.00105</code></pre>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1"></a><span class="co"># actual simulated projection</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>(t<span class="dv">-1</span>)) { </span>
<span id="cb46-3"><a href="#cb46-3"></a>  N[i<span class="op">+</span><span class="dv">1</span>] &lt;-<span class="st"> </span>N[i] <span class="op">*</span><span class="st"> </span>random.lambda[i]</span>
<span id="cb46-4"><a href="#cb46-4"></a>}</span>
<span id="cb46-5"><a href="#cb46-5"></a></span>
<span id="cb46-6"><a href="#cb46-6"></a><span class="kw">qplot</span>(<span class="dt">x=</span><span class="dv">0</span><span class="op">:</span>(t<span class="dv">-1</span>), N, <span class="dt">geom=</span><span class="kw">c</span>(<span class="st">&quot;line&quot;</span>, <span class="st">&quot;point&quot;</span>), <span class="dt">xlab=</span><span class="st">&quot;Time (y)&quot;</span>)</span></code></pre></div>
<div class="figure">
<img src="figs/randomLambda-1.png" alt="Random variation in growth rate alters the long term average growth rate." width="90%" />
<p class="caption">
(#fig:randomLambda)Random variation in growth rate alters the long term average growth rate.
</p>
</div>
<p>Sometimes the arithmetic average is close to the correct average, but it is never the correct approach.</p>
</div>
</div>
<div id="modeling-with-data-simulated-dynamics" class="section level2">
<h2><span class="header-section-number">4.4</span> Modeling with Data: Simulated Dynamics</h2>
<p>Science strives to make predictions about about the behavior of systems.
Ecologists and conservation biologists frequently strive to predict the fate of populations. Here we put into practice ideas about population biology to make informed predictions about the fate of the Song Sparrow population in Darrtown, OH. We also illustrate simple commputational methods for doing so.</p>
<p>The preceding sections (the bulk of the chapter) emphasized understanding the deterministic underpinnings of simple forms of density independent growth: geometric and exponential growth. This section explores the stochastic simulation of density independent growth. Our simulation makes most of the same assumptions we made at the beginning of the chapter. In addition, we assume that the observed annual growth rates (<span class="math inline">\(N_{t+1}/N_t\)</span>) are representative of future growth rates, and that the growth rate in one year is entirely independent of any other year.</p>
<p>To make meaning full projections of future population size, we should quantify the uncertainty with our guess. Simulation is one way we can project populations and quantify the uncertainty. The way one often does that is to use the original data and sample it randomly to calculate model parameters. This way, the simulations are random, but based on our best available knowldge, i.e., the real data. The re-use of observed data occurs in many guises, and it is known often as bootstrapping or resampling.</p>
<div id="data-based-approaches" class="section level3">
<h3><span class="header-section-number">4.4.1</span> Data-based approaches</h3>
<p>We could use the observed <em>changes</em> in population counts <span class="math inline">\(R_t=N_{t+1}/N_t\)</span> as our data. We would then draw an <span class="math inline">\(R_t\)</span> at random from among the many observed values, and project the population one year forward. We then repeat this into the future, say, for ten years. Each simulation of a ten year period will result in a different ten year trajectory because we draw <span class="math inline">\(R_t\)</span> at random from among the observed <span class="math inline">\(R_t\)</span>. However, if we do many such simulations, we will have a <em>distribution</em> of outcomes that we can describe with simple statistics (e.g., median, mean, quantiles).</p>
<p>A different approach would be to estimate the individual probabilities of births and deaths in the entire Darrtown population, and use those probabilities and birth rates to simulate the entire population into the future. In such an <em>individual-based simulation</em>, we would simulate the fates of individuals, keeping track of all individual births and deaths.</p>
<p>There are myriad other approaches, but these give you a taste of what might be possible. In this section we focus on the first of these alternatives, in which we use observed <span class="math inline">\(R_t\)</span> to simulate the dynamics of Song Sparrow counts. Do do so, in part, because we have those data, while we do not have any estimates of birth rates or death rates.</p>
<p>Here we investigate Song Sparrow (<em>Melospize melodia</em>) dynamics using data from the annual U.S. Breeding Bird Survey (<a href="http://www.mbr-pwrc.usgs.gov/" class="uri">http://www.mbr-pwrc.usgs.gov/</a> bbs/). Below we will</p>
<ol style="list-style-type: decimal">
<li>create and examine visually the data (annual <span class="math inline">\(R\)</span>’s),</li>
<li>simulate one projection,</li>
<li>scale up to multiple simulations,</li>
<li>simplify simulations and perform them 1000s of times, and</li>
<li>analyze the output.</li>
</ol>
</div>
<div id="creating-and-visualizing-the-data" class="section level3">
<h3><span class="header-section-number">4.4.2</span> Creating and visualizing the data</h3>
<p>Let’s start by graphing the data<a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a>. <em>Graphing the data is always a good idea — it is a principle of working with data</em>. We first load the data from the <code>primer</code> R package, and look at the names of the data frame. We then choose to <code>attach</code> the data frame, because it makes the code easier to read.<a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a></p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">library</span>(primer)</span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="kw">data</span>(sparrows)</span>
<span id="cb47-3"><a href="#cb47-3"></a><span class="kw">names</span>(sparrows)</span></code></pre></div>
<pre><code>## [1] &quot;Year&quot;           &quot;Count&quot;          &quot;ObserverNumber&quot;</code></pre>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1"></a><span class="kw">attach</span>(sparrows)</span></code></pre></div>
<p>Now we plot these counts through time (Fig. @ref(fig:cts)).</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1"></a><span class="kw">ggplot</span>(<span class="dt">data=</span>sparrows, <span class="kw">aes</span>(<span class="dt">x=</span>Year, <span class="dt">y=</span>Count)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">pch=</span><span class="dv">1</span>)</span></code></pre></div>
<div class="figure">
<img src="figs/cts-1.png" alt="Observations of Song Sparrows in Darrtown, OH (http://www.mbr-pwrc.usgs.gov/bbs/)." width="75%" />
<p class="caption">
(#fig:cts)Observations of Song Sparrows in Darrtown, OH (<a href="http://www.mbr-pwrc.usgs.gov/bbs/" class="uri">http://www.mbr-pwrc.usgs.gov/bbs/</a>).
</p>
</div>
<p>We see that Song Sparrow counts at this site (the DARRTOWN transect, OH, USA) fluctuated a fair bit between 1966 and 2003. They never were completely absent and never exceeded <span class="math inline">\(\sim 120\)</span> individuals.</p>
<p>Next we calculate annual <span class="math inline">\(R_t=N_{t+1}/N_t\)</span>, that is, the observed growth rate for each year <span class="math inline">\(t\)</span>.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1"></a><span class="co"># the use of [-1[ in the index tells R to exclude the first element.</span></span>
<span id="cb51-2"><a href="#cb51-2"></a><span class="co"># length() is the length of a vector, so [-length(X)] means exclude the last</span></span>
<span id="cb51-3"><a href="#cb51-3"></a>obs.R &lt;-<span class="st"> </span>Count[<span class="op">-</span><span class="dv">1</span>]<span class="op">/</span>Count[<span class="op">-</span><span class="kw">length</span>(Count)]</span></code></pre></div>
<p>Thus our <em>data</em> are the observed <span class="math inline">\(R_t\)</span>, not the counts <em>per se</em>. These <span class="math inline">\(R\)</span> form the basis of everything else we do. Because they are so important, let’s plot these as well. Let’s also indicate <span class="math inline">\(R=1\)</span> with a horizontal dotted line as a visual cue for zero population growth. Note that we exclude the last year because each <span class="math inline">\(R_t\)</span> is associated with <span class="math inline">\(N_t\)</span> rather than <span class="math inline">\(N_{t+1}\)</span>.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1"></a><span class="kw">qplot</span>(<span class="dt">x=</span>Year[<span class="op">-</span><span class="kw">length</span>(Count)], <span class="dt">y=</span>obs.R, <span class="dt">geom=</span><span class="st">&quot;point&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">geom_hline</span>(<span class="dt">yintercept=</span><span class="dv">1</span>, <span class="dt">lty=</span><span class="dv">3</span>) <span class="op">+</span><span class="st"> </span></span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="st">  </span><span class="kw">labs</span>(<span class="dt">y=</span><span class="kw">bquote</span>(N[t<span class="op">+</span><span class="dv">1</span>]<span class="op">/</span>N[t]), <span class="dt">x=</span><span class="st">&quot;Year (t)&quot;</span>)</span></code></pre></div>
<div class="figure">
<img src="figs/Rrates-1.png" alt="Annual growth rates (R=N[t+1]/N[t]) for Song Sparrows" width="75%" />
<p class="caption">
(#fig:Rrates)Annual growth rates (R=N[t+1]/N[t]) for Song Sparrows
</p>
</div>
<p>One thing that emerges in our graphic data display (Fig. @ref(fig:Rrates)) is we have an unusually high growth rate in the early 1990’s, with the rest of the data clustered around 0.5–1.5. We may want to remember that.</p>
</div>
<div id="one-simulation" class="section level3">
<h3><span class="header-section-number">4.4.3</span> One simulation</h3>
<p>Our simulation will,</p>
<ol style="list-style-type: decimal">
<li>determine the number of years we wish to simulate,</li>
<li>create an empty vector, <code>N</code>, to hold our simulated <span class="math inline">\(N\)</span>, which is <code>years + 1</code> long,</li>
<li>draw a random sample of <span class="math inline">\(R_t\)</span>, one for each year (<code>R</code>),</li>
<li>select a starting abundance <span class="math inline">\(N_0\)</span> and put it in <code>N[1]</code>.</li>
<li>multiply our first random <span class="math inline">\(R\)</span>, <code>R[1]</code>, times <code>N[1]</code> to generate the next, <code>N[2]</code>.</li>
<li>repeat step 5 for each year to simulate each <code>N[t+1]</code> from <code>R[t]</code> and <code>N[t]</code>.</li>
</ol>
<p>First, we decide how many years we want to simulate growth, and create an empty vector that will hold our data.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1"></a>years &lt;-<span class="st"> </span><span class="dv">10</span></span>
<span id="cb53-2"><a href="#cb53-2"></a>N &lt;-<span class="kw">numeric</span>(years<span class="op">+</span><span class="dv">1</span>) <span class="co"># rep(0,years+1) would do the same thing.</span></span></code></pre></div>
<p>Our vector of <span class="math inline">\(N\)</span> has to be one longer than the number of <span class="math inline">\(R\)</span> we use. This is because each <span class="math inline">\(R\)</span> is sthe change <em>from one year to the next</em> and there will always be one more <em>next</em> than there is <span class="math inline">\(R\)</span>.</p>
<p>Next we draw 10 <span class="math inline">\(R\)</span> at random with replacement. This is just like having all 35 observed <span class="math inline">\(R\)</span> written down on slips of paper and dropped into a paper bag. We then draw one slip of paper out of the bag, write the number down, and put the slip of paper back in the bag, and then repeat this 9 more times. This is <em>resampling with replacement</em>. In that case, we would be assuming that all of these <span class="math inline">\(R_t\)</span> are important and will occur at some point, but we just don’t know when—they constitute the entire universe of possiblities. The R function <em>sample</em> will do this.
[A random process occurs only in our imagination, or perhaps at the quantum level.<a href="#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a> A stochastic process is one which we treat operationally as random while acknowledging that there are complex underlying deterministic drivers. A pseudorandom process is a completely deterministic and hidden process used by computers and their programmers to generate numbers that cannot be distinguished from random; we can repeat a pseudorandom process by stipulating a key hidden starting point.]</p>
<p>We can use <code>set.seed()</code> to make your pseudorandom process the same as mine, i.e., repeatable.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1"></a><span class="kw">set.seed</span>(<span class="dv">3</span>)</span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="co"># Draw a sample of our observed R with replacement, &quot;years&quot; times.</span></span>
<span id="cb54-3"><a href="#cb54-3"></a>(rRs &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dt">x=</span>obs.R, <span class="dt">size=</span>years, <span class="dt">replace =</span> <span class="ot">TRUE</span>))</span></code></pre></div>
<pre><code>##  [1] 1.4489796 0.8125000 1.0714286 1.2857143 0.7727273 0.4805195 1.2857143
##  [8] 1.0500000 0.7204301 1.4489796</code></pre>
<p>Now that we have these 10 <span class="math inline">\(R\)</span>, all we have to do is use them to generate the population sizes through time. For this, we need to use what programmers call a <em>for-loop</em>. In brief, a for-loop repeats a series of steps for a predetermined number of times.</p>
<p>Let’s start our simulated N with the sparrow count we had in the last year.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1"></a>N[<span class="dv">1</span>] &lt;-<span class="st"> </span>Count[<span class="kw">length</span>(Count)]</span></code></pre></div>
<p>Now we are ready to use the for-loop to project the population. For each year <span class="math inline">\(t\)</span>, we multiply <span class="math inline">\(N_t\)</span> by the randomly selected <span class="math inline">\(R_t\)</span> to get <span class="math inline">\(N_{t+1}\)</span> and put it into the <span class="math inline">\(t +1\)</span> element of <code>N</code>.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1"></a><span class="cf">for</span>( t <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>years) { </span>
<span id="cb57-2"><a href="#cb57-2"></a><span class="co"># starting with year = 1, and for each subsequent year, do... </span></span>
<span id="cb57-3"><a href="#cb57-3"></a>N[t<span class="op">+</span><span class="dv">1</span>] &lt;-<span class="st"> </span>N[t] <span class="op">*</span><span class="st"> </span>rRs[t]</span>
<span id="cb57-4"><a href="#cb57-4"></a>}</span></code></pre></div>
<p>Let’s graph the result.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1"></a><span class="kw">qplot</span>(<span class="dv">0</span><span class="op">:</span>years, N, <span class="dt">geom=</span><span class="kw">c</span>(<span class="st">&quot;point&quot;</span>,<span class="st">&quot;line&quot;</span>))</span></code></pre></div>
<div class="figure">
<img src="figs/simten-1.png" alt="A single simulated population projection." width="90%" />
<p class="caption">
(#fig:simten)A single simulated population projection.
</p>
</div>
<p>It appears to work (Fig. @ref(fig:simten)). Let’s review what we have done. We</p>
<p><em>had a bird count each year for 36 years. From this we calculated 35 <span class="math inline">\(R\)</span> (for all years except the very last).
</em> decided how many years we wanted to project the population (10,y).
* drew at random and with replacement the observed <span class="math inline">\(R\)</span>—one <span class="math inline">\(R\)</span> for each year we want to project forward.
* we created an empty vector and put in an initial value (the last year’s real data).
* performed each year’s calculation, and put it into the vector we made.</p>
<p>So what does Fig. @ref(fig:simten) represent? It represents one possible outcome of a trajectory, if we assume that <span class="math inline">\(R\)</span> has an equal probability of being any of the observed <span class="math inline">\(R_t\)</span>. This <em>particular</em> trajectory is very unlikely, because it would require one particular sequence of randomly selected <span class="math inline">\(R\)</span>s. However, it is <em>no less likely</em> than any other particular trajectory.</p>
<p>As only one realization of a set of randomly selected <span class="math inline">\(R\)</span>, Fig. @ref(fig:simten) tells us very little. What we need to do now is to replicate this process a very large number of times, and examine the <em>distribution</em> of outcomes, including moments of the distribution such as the mean, median, and confidence interval of eventual outcomes.</p>
</div>
<div id="multiple-simulations" class="section level3">
<h3><span class="header-section-number">4.4.4</span> Multiple simulations</h3>
<p>Now we create a way to perform the above simulation several times. There are a couple tricks we use to do this. We still want to start small so we can figure out the steps as we go. Here is what we would do next.</p>
<ol style="list-style-type: decimal">
<li>We start by creating a function that will do the steps we did above.</li>
<li>We then do replicate independent simulations, using <code>replicate()</code>.</li>
</ol>
<p>Here we write a function to combine several steps.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1"></a>myForLoop &lt;-<span class="st"> </span><span class="cf">function</span>(obs.R, years, initial.N) {</span>
<span id="cb59-2"><a href="#cb59-2"></a>  <span class="co"># select all R at random</span></span>
<span id="cb59-3"><a href="#cb59-3"></a>  rR &lt;-<span class="st"> </span><span class="kw">sample</span>(obs.R, <span class="dt">size=</span>years, <span class="dt">replace=</span><span class="ot">TRUE</span>)</span>
<span id="cb59-4"><a href="#cb59-4"></a>  <span class="co"># create a vector to hold N</span></span>
<span id="cb59-5"><a href="#cb59-5"></a>  N &lt;-<span class="st"> </span><span class="kw">numeric</span>(years<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb59-6"><a href="#cb59-6"></a>  <span class="co"># give it an initial population size</span></span>
<span id="cb59-7"><a href="#cb59-7"></a>  N[<span class="dv">1</span>] &lt;-<span class="st"> </span>initial.N</span>
<span id="cb59-8"><a href="#cb59-8"></a>  <span class="co"># Do the for-loop</span></span>
<span id="cb59-9"><a href="#cb59-9"></a>  <span class="cf">for</span>( t <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>years ) {</span>
<span id="cb59-10"><a href="#cb59-10"></a>    <span class="co"># project the population one time step</span></span>
<span id="cb59-11"><a href="#cb59-11"></a>      N[t<span class="op">+</span><span class="dv">1</span>] &lt;-<span class="st">  </span>N[t] <span class="op">*</span><span class="st"> </span>rR[t]</span>
<span id="cb59-12"><a href="#cb59-12"></a>  }</span>
<span id="cb59-13"><a href="#cb59-13"></a>  <span class="co"># return the vector of N</span></span>
<span id="cb59-14"><a href="#cb59-14"></a>  N</span>
<span id="cb59-15"><a href="#cb59-15"></a>} </span>
<span id="cb59-16"><a href="#cb59-16"></a><span class="co"># try it out with different hypothetical R</span></span>
<span id="cb59-17"><a href="#cb59-17"></a><span class="kw">myForLoop</span>(<span class="dt">obs.R=</span><span class="dv">0</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">years=</span><span class="dv">5</span>, <span class="dt">initial.N=</span><span class="dv">43</span>)</span></code></pre></div>
<pre><code>## [1]  43 129   0   0   0   0</code></pre>
<p>Our function seems to work. Next we do ten such projection simulations, each for 50 time steps, using the sparrow data.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1"></a><span class="co"># specify the number of simulations and for how long</span></span>
<span id="cb61-2"><a href="#cb61-2"></a>sims=<span class="dv">10</span>; years=<span class="dv">50</span></span>
<span id="cb61-3"><a href="#cb61-3"></a><span class="kw">set.seed</span>(<span class="dv">3</span>)</span>
<span id="cb61-4"><a href="#cb61-4"></a>outmat &lt;-<span class="st"> </span><span class="kw">replicate</span>(sims,   </span>
<span id="cb61-5"><a href="#cb61-5"></a>                    <span class="dt">expr=</span><span class="kw">myForLoop</span>(<span class="dt">obs.R=</span>obs.R, <span class="dt">years=</span>years, <span class="dt">initial.N=</span><span class="dv">43</span>)</span>
<span id="cb61-6"><a href="#cb61-6"></a>                    )</span></code></pre></div>
<p>Now let’s peek at the results (Fig. @ref(fig:tensimfig)). It is fun to graph our output, but also helps us make sure we are not making a heinous mistake in our code. Note we use log scale to help us see the small populations.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1"></a><span class="kw">matplot</span>(<span class="dv">0</span><span class="op">:</span>years, outmat, <span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">log=</span><span class="st">&quot;y&quot;</span>)</span></code></pre></div>
<div class="figure">
<img src="figs/tensimfig-1.png" alt="Using matplot() to plot a matrix vs. a single variable. Our simulated populations sometimes increase and sometimes decrease." width="75%" />
<p class="caption">
(#fig:tensimfig)Using matplot() to plot a matrix vs. a single variable. Our simulated populations sometimes increase and sometimes decrease.
</p>
</div>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1"></a><span class="co"># combine columns years, and our output</span></span>
<span id="cb63-2"><a href="#cb63-2"></a>junk &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">years =</span> <span class="dv">1</span><span class="op">:</span>(years<span class="op">+</span><span class="dv">1</span>), outmat)</span>
<span id="cb63-3"><a href="#cb63-3"></a><span class="kw">names</span>(junk)</span></code></pre></div>
<pre><code>##  [1] &quot;years&quot; &quot;X1&quot;    &quot;X2&quot;    &quot;X3&quot;    &quot;X4&quot;    &quot;X5&quot;    &quot;X6&quot;    &quot;X7&quot;    &quot;X8&quot;   
## [10] &quot;X9&quot;    &quot;X10&quot;</code></pre>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1"></a><span class="co"># make sure to load &#39;tidyr&#39; if you did not already load it or tidyverse</span></span>
<span id="cb65-2"><a href="#cb65-2"></a><span class="co"># library(tidyr)</span></span>
<span id="cb65-3"><a href="#cb65-3"></a><span class="co"># &quot;gather&quot; many columns into one (except years)</span></span>
<span id="cb65-4"><a href="#cb65-4"></a>out.long &lt;-<span class="st"> </span><span class="kw">gather</span>(junk, <span class="dt">key=</span><span class="st">&quot;Run&quot;</span>, <span class="dt">value=</span><span class="st">&quot;N&quot;</span>, <span class="op">-</span>years)</span>
<span id="cb65-5"><a href="#cb65-5"></a><span class="kw">ggplot</span>(<span class="dt">data=</span>out.long, <span class="kw">aes</span>(<span class="dt">x=</span>years, <span class="dt">y=</span>N, <span class="dt">group=</span>Run)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>() <span class="op">+</span><span class="st">  </span></span>
<span id="cb65-6"><a href="#cb65-6"></a><span class="st">  </span><span class="kw">scale_y_log10</span>() </span></code></pre></div>
<div class="figure">
<img src="figs/tensimfig2-1.png" alt="Using ggplot() to plot one variable against vs. a single variable, organized by a grouping variable. Our simulated populations sometimes increase and sometimes decrease." width="75%" />
<p class="caption">
(#fig:tensimfig2)Using ggplot() to plot one variable against vs. a single variable, organized by a grouping variable. Our simulated populations sometimes increase and sometimes decrease.
</p>
</div>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1"></a><span class="co"># Or for colorful lines</span></span>
<span id="cb66-2"><a href="#cb66-2"></a><span class="co"># ggplot(data=out.long, aes(x=years, y=N,  linetype=Run, colour=Run)) + </span></span>
<span id="cb66-3"><a href="#cb66-3"></a><span class="co">#    geom_line(show.legend=FALSE) + scale_y_log10() </span></span></code></pre></div>
<p>What does it mean that the simulation has an approximately even distribution of final population sizes  (Fig. )? If we plotted it on a linear scale, what would it look like?^[Plotting it on the log scale reveals that the relative change is independent of population size; this is true because the rate of change is geometric. If we plotted it on a linear scale, we would see that many trajectories result in small counts, and only a few get really big. That is, the median size is pretty small, but a few populations get huge.}</p>
<p>Rerunning this simulation, with new <span class="math inline">\(R\)</span> each time, will show different dynamics every time, and that is the point of simulations. Simulations are a way to make a few key assumptions, and then leave the rest to chance. In that sense it is a null model of population dynamics.</p>
</div>
<div id="a-distribution-of-possible-futures" class="section level3">
<h3><span class="header-section-number">4.4.5</span> A distribution of possible futures</h3>
<p>Now we are in a position to make an informed prediction, given our assumptions. We will predict the range of possible outcomes and the most likely outcomes, given our set of assumptions.</p>
<p>We will simulate the population for 50 years 10,000 times and describe the distribution of final populatin sizes. We use <code>system.time</code> to tell me how long it takes on my computer.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1"></a>sims=<span class="fl">1e4</span>; years=<span class="dv">50</span></span>
<span id="cb67-2"><a href="#cb67-2"></a><span class="kw">set.seed</span>(<span class="dv">3</span>)</span>
<span id="cb67-3"><a href="#cb67-3"></a><span class="co">## system.time keeps track of how long processes take.</span></span>
<span id="cb67-4"><a href="#cb67-4"></a><span class="kw">system.time</span>(</span>
<span id="cb67-5"><a href="#cb67-5"></a>outmat &lt;-<span class="st"> </span><span class="kw">replicate</span>(sims,   </span>
<span id="cb67-6"><a href="#cb67-6"></a>                    <span class="dt">expr=</span><span class="kw">myForLoop</span>(<span class="dt">obs.R=</span>obs.R, <span class="dt">years=</span>years, <span class="dt">initial.N=</span><span class="dv">43</span>)</span>
<span id="cb67-7"><a href="#cb67-7"></a>                    )</span>
<span id="cb67-8"><a href="#cb67-8"></a>            )</span></code></pre></div>
<pre><code>##    user  system elapsed 
##   0.141   0.011   0.152</code></pre>
<p>This tells me how long it took to complete 10,000 simulations. We also check the dimensions of the output, and they make sense.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1"></a><span class="kw">dim</span>(outmat)</span></code></pre></div>
<pre><code>## [1]    51 10000</code></pre>
<p>We see that we have an object that is the size we think it should be. We shall assume that everything worked way we think it should.</p>
</div>
<div id="analyzing-results" class="section level3">
<h3><span class="header-section-number">4.4.6</span> Analyzing results</h3>
<p>We extract the last year of the simulations (last row), and summarize it with quartiles (0%, 25%, 50%, 75%, 100%, and also the mean).</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1"></a>N<span class="fl">.2053</span> &lt;-<span class="st"> </span>outmat[<span class="dv">51</span>,]</span>
<span id="cb71-2"><a href="#cb71-2"></a><span class="kw">summary</span>(N<span class="fl">.2053</span>, <span class="dt">digits=</span><span class="dv">6</span>)</span></code></pre></div>
<pre><code>##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
##       0.0      12.1      60.7    1306.3     297.7 2299420.0</code></pre>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1"></a><span class="kw">hist</span>(<span class="kw">log10</span>(N<span class="fl">.2053</span>))</span></code></pre></div>
<div class="figure">
<img src="figs/unnamed-chunk-20-1.png" alt="Distribution of the 10000 final base-10 log population sizes. Note the approximately Normal distribution." width="75%" />
<p class="caption">
(#fig:unnamed-chunk-20)Distribution of the 10000 final base-10 log population sizes. Note the approximately Normal distribution.
</p>
</div>
<p>The <code>quantile()</code> function allows us to find a form of empirical confidence interval, including, approximately, the central 90% of the observations.<a href="#fn21" class="footnote-ref" id="fnref21"><sup>21</sup></a></p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1"></a><span class="kw">quantile</span>(N<span class="fl">.2053</span>, <span class="dt">prob=</span><span class="kw">c</span>(<span class="fl">0.05</span>, <span class="fl">.95</span>) )</span></code></pre></div>
<pre><code>##          5%         95% 
##    1.331579 2862.940808</code></pre>
<p>These quantiles provide an estimate of the most likely range of possible populatin sizes, given our assumptions.</p>
</div>
<div id="inferring-processes-underlying-growth-rate" class="section level3">
<h3><span class="header-section-number">4.4.7</span> Inferring processes underlying growth rate</h3>
<p>The above approach relies only on the observed data. That means that the growth rates, while representative, can never be different than what was observed. A different approaach would be to assume that the growth rates can be different than observed, <em>but drawn from the same underlying process</em> that caused the observed rates.</p>
<p>The observed rates are simply a visible manifestation of unseen processes. We might summarize these by asserting that the observed growth rates were samples from a continuous distribution distribution, whose prperties we can infer from the sample. For instance, it may be that these processes cause annual rates to follow a Normal, or perhaps log-normal distribution.</p>
<p>We can fit a Normal distribution to the logarithms of our observed <span class="math inline">\(R\)</span>, and we see that it doesn’t do too bad a job (Fig. @ref(fig:fitln)).</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1"></a>mu &lt;-<span class="st"> </span><span class="kw">mean</span>( <span class="kw">log</span>(obs.R) )</span>
<span id="cb76-2"><a href="#cb76-2"></a>sigma &lt;-<span class="st"> </span><span class="kw">sd</span>( <span class="kw">log</span>(obs.R) )</span>
<span id="cb76-3"><a href="#cb76-3"></a></span>
<span id="cb76-4"><a href="#cb76-4"></a><span class="co"># a regular sequence for log-R</span></span>
<span id="cb76-5"><a href="#cb76-5"></a>lR &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">1</span>, <span class="fl">1.1</span>, <span class="dt">by=</span><span class="fl">0.01</span>)</span>
<span id="cb76-6"><a href="#cb76-6"></a><span class="co"># the probability densities for the log-R</span></span>
<span id="cb76-7"><a href="#cb76-7"></a>dR &lt;-<span class="st"> </span><span class="kw">dnorm</span>(lR, <span class="dt">m=</span>mu, <span class="dt">sd=</span>sigma)</span>
<span id="cb76-8"><a href="#cb76-8"></a></span>
<span id="cb76-9"><a href="#cb76-9"></a><span class="kw">hist</span>(<span class="kw">log</span>(obs.R), <span class="dt">breaks=</span><span class="dv">10</span>, <span class="dt">prob=</span><span class="ot">TRUE</span>)</span>
<span id="cb76-10"><a href="#cb76-10"></a><span class="kw">lines</span>(lR, dR)</span></code></pre></div>
<div class="figure">
<img src="figs/fitln-1.png" alt="The logarithms of the observed R seem reasonably approximated by a Normal distribution whose mean and standard deviation are derived from the log-transformed data." width="75%" />
<p class="caption">
(#fig:fitln)The logarithms of the observed R seem reasonably approximated by a Normal distribution whose mean and standard deviation are derived from the log-transformed data.
</p>
</div>
<p>Now we will simulate populations just like before, but instead of random draws from the observed data, we do random draws from the inferred distribution.</p>
<p>Our new function.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1"></a>myForLoop2 &lt;-<span class="st"> </span><span class="cf">function</span>(mu, sigma, years, initial.N) {</span>
<span id="cb77-2"><a href="#cb77-2"></a>  <span class="co"># select all R at random from </span></span>
<span id="cb77-3"><a href="#cb77-3"></a>  lrR &lt;-<span class="st"> </span><span class="kw">rnorm</span>(years, <span class="dt">m=</span>mu, <span class="dt">sd=</span>sigma)</span>
<span id="cb77-4"><a href="#cb77-4"></a>  rR &lt;-<span class="st"> </span><span class="kw">exp</span>(lrR)</span>
<span id="cb77-5"><a href="#cb77-5"></a>  <span class="co"># create a vector to hold N</span></span>
<span id="cb77-6"><a href="#cb77-6"></a>  N &lt;-<span class="st"> </span><span class="kw">numeric</span>(years<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb77-7"><a href="#cb77-7"></a>  <span class="co"># give it an initial population size</span></span>
<span id="cb77-8"><a href="#cb77-8"></a>  N[<span class="dv">1</span>] &lt;-<span class="st"> </span>initial.N</span>
<span id="cb77-9"><a href="#cb77-9"></a>  <span class="co"># Do the for-loop</span></span>
<span id="cb77-10"><a href="#cb77-10"></a>  <span class="cf">for</span>( t <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>years ) {</span>
<span id="cb77-11"><a href="#cb77-11"></a>    <span class="co"># project the population one time step</span></span>
<span id="cb77-12"><a href="#cb77-12"></a>      N[t<span class="op">+</span><span class="dv">1</span>] &lt;-<span class="st">  </span>N[t] <span class="op">*</span><span class="st"> </span>rR[t]</span>
<span id="cb77-13"><a href="#cb77-13"></a>  }</span>
<span id="cb77-14"><a href="#cb77-14"></a>  <span class="co"># return the vector of N</span></span>
<span id="cb77-15"><a href="#cb77-15"></a>  N</span>
<span id="cb77-16"><a href="#cb77-16"></a>} </span></code></pre></div>
<p>Our new simulations.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1"></a>sims=<span class="fl">1e4</span>; years=<span class="dv">50</span></span>
<span id="cb78-2"><a href="#cb78-2"></a><span class="kw">set.seed</span>(<span class="dv">3</span>)</span>
<span id="cb78-3"><a href="#cb78-3"></a>outmat2 &lt;-<span class="st"> </span><span class="kw">replicate</span>(sims,   </span>
<span id="cb78-4"><a href="#cb78-4"></a>                    <span class="dt">expr=</span><span class="kw">myForLoop2</span>(<span class="dt">mu=</span>mu, <span class="dt">sigma=</span>sigma, <span class="dt">years=</span>years, <span class="dt">initial.N=</span><span class="dv">43</span>)</span>
<span id="cb78-5"><a href="#cb78-5"></a>                    )</span>
<span id="cb78-6"><a href="#cb78-6"></a>N2<span class="fl">.2053</span> &lt;-<span class="st"> </span>outmat2[<span class="dv">51</span>,]</span>
<span id="cb78-7"><a href="#cb78-7"></a><span class="kw">quantile</span>(N2<span class="fl">.2053</span>, <span class="dt">prob=</span><span class="kw">c</span>(<span class="fl">0.05</span>, <span class="fl">.95</span>) )</span></code></pre></div>
<pre><code>##          5%         95% 
##    1.205509 3089.819907</code></pre>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1"></a><span class="kw">quantile</span>(N<span class="fl">.2053</span>, <span class="dt">prob=</span><span class="kw">c</span>(<span class="fl">0.05</span>, <span class="fl">.95</span>) )</span></code></pre></div>
<pre><code>##          5%         95% 
##    1.331579 2862.940808</code></pre>
<p>The results are very similar to those based on only the observed <span class="math inline">\(R\)</span>. If they were markedly different, we might ask whether our choice of distribution was appropriate.</p>
<p>Our conclusions are based on a model of discrete density-independent population growth</p>
<ul>
<li>what assumptions are we making and are they valid?</li>
<li>Are our unrealistic assumptions perhaps nonetheless a good approximation of reality?</li>
<li>what would you like to add next to make the model a better approximation?</li>
</ul>
<p>Perhaps we might explain some of the variation in annual growth rates to weather patterns in the breeding range (Darrtown, Ohio). If so, we might separate demographic effects vs. environmental effects. That would give us an even better model we could use for explanation and prediction.</p>

<p>In this chapter, we have explored the meaning of density-independent population growth. It is a statistically demonstrable phenomenon, wherein the per captia growth rate exhibits no relation with population density. It is a useful starting point for conceptualizing population growth. We have derived discrete geometric and continuous exponential growth and seen how they are related. We have caculated doubling times. We have discussed the assumptions that different people might make regarding these growth models. Last, we have used simulation to explore prediction and inference in a density-independent context.</p>
<!--chapter:end:03-Expo-growth.Rmd-->
</div>
</div>
</div>
<div id="DID" class="section level1">
<h1><span class="header-section-number">5</span> Density-independent Demography</h1>
<p>In the preceding chapter, we listed Hastings’ <span class="citation">(Hastings <a href="#ref-Hastings2011" role="doc-biblioref">2011</a>)</span> key principles and assumptions of single species population growth. One of the key assumptions is that “all individuals in a population are identical.” In this chapter, we elucidate an important violation of that assumption, population structure.</p>
<div class="figure">
<img src="figs/AgeDistM.png" alt="Demography of human populations of Mexico and Sweden. Based on 1990 data from US Census Bureau, Population Division, International Programs Center." width="30%" /><img src="figs/AgeDistS.png" alt="Demography of human populations of Mexico and Sweden. Based on 1990 data from US Census Bureau, Population Division, International Programs Center." width="30%" /><img src="figs/AgeSpecFert.png" alt="Demography of human populations of Mexico and Sweden. Based on 1990 data from US Census Bureau, Population Division, International Programs Center." width="30%" />
<p class="caption">
(#fig:human)Demography of human populations of Mexico and Sweden. Based on 1990 data from US Census Bureau, Population Division, International Programs Center.
</p>
</div>
<p><em>Populations have structure.</em> Consider the human populations of Mexico and Sweden in 1990. Mexico had a much larger fraction of their population in child bearing age classes or younger (Fig. @ref(fig:human)). In addition, the age-specific fertility rate was higher in Mexico, especially for younger women
(Fig. @ref(fig:human)). How did this happen, and why did Mexico have so
many young people? What were the consequences of this for their
culture, their use of resources, their domestic and foreign policies,
and their future population growth? How about Sweden?</p>
<p>Demography is the study of populations with special attention to their structure <span class="citation">(Lincoln, Boxshall, and Clark <a href="#ref-Lincoln:1998ta" role="doc-biblioref">1998</a>)</span>. Originally, age-based human demography was the provenance of actuaries who helped governments keep track of the number citizens of different ages and thus, for instance, know how many would be available for conscription into the military.<a href="#fn22" class="footnote-ref" id="fnref22"><sup>22</sup></a></p>
<p><em>The reason we model the structure of populations</em> is because various demographic rates vary markedly with these stages. Juveniles produce no offspring. Very few seeds survive an entire year, whereas some large adults survive very well. We use structure when that structure is associated with important differences in demographic rates: <em>survival</em>, <em>fecundity</em>, and <em>growth</em>.</p>
<p>The <em>structure</em> to which we refer is simply the organization of populations by some character such as life history stage, age, or size. Sizes and ages are often reduced to categories such as we saw in human populations (e.g., 0–4.9,y, 5–9.9,y,…). Sizes may be based on any reliable and repeatable measure that relates to demographic rates and are similarly binned. Life history stages may include eggs, larvae, metamorphs, juveniles, and adults in amphibians, or seeds, rosettes, and reproductive stems in herbaceous plants. With a variable such as size, we don’t even need to use categories, but rather we can use size as a continuous variable; we address this briefly later in the chapter.</p>
<p>Structured population models allow us to intertwine species-specific natural history and quantitative methods. This makes the approach especially appealing for the conservation biology of threatened and endangered species. We use structured population models to improve our better understanding of a population or improve predictions of its future dynamics, or guide the management of the population. We might learn a lot about what controls the abundance
of a species if we can test ideas related to different stages, ages,
or sizes. What limits the population growth of the Western toad –
is it egg survival, or overwintering survival of juveniles? Where
should we invest our efforts to
control garlic mustard (<em>Alliaria petiolata</em>) – killing the
first year
rosettes, or the second year adults? Why are cacti generally endangered <span class="citation">(Goettsch et al. <a href="#ref-Goettsch2015" role="doc-biblioref">2015</a>)</span>—is the smallest size, or the largest size
that is most essential to insure long-term survival? We can use
structured population models to address such questions.</p>
<div id="a-two-stage-matrix-model" class="section level2">
<h2><span class="header-section-number">5.1</span> A two stage matrix model</h2>
<div class="figure">
<img src="figs/VoneshF1.pdf" alt="Like all amphibians, the Western toad (Anaxyrus boreas) has a complex life cycle, with several life history stages. Adults breed in early spring, laying eggs in water. The larvae (tadpoles) hatch and develop over the spring and summer, and then metamorphose (become metamorphs), and then juveniles. Juveniles require more than a year to mature. Adults can live up to about a decade. American toads (A. americanus) do the same thing." width="65%" />
<p class="caption">
(#fig:toadlh)Like all amphibians, the Western toad (Anaxyrus boreas) has a complex life cycle, with several life history stages. Adults breed in early spring, laying eggs in water. The larvae (tadpoles) hatch and develop over the spring and summer, and then metamorphose (become metamorphs), and then juveniles. Juveniles require more than a year to mature. Adults can live up to about a decade. American toads (A. americanus) do the same thing.
</p>
</div>
<p>A matrix model of a structured population consists of <em>stages</em> and <em>transitions</em>. <span class="citation">Vonesh and Cruz (<a href="#ref-Vonesh:2002fr" role="doc-biblioref">2002</a>)</span> used matrix projection to assess the importance of egg mortality for declines in amphibian populations. Their model of the Western toad (<em>Anaxyrus boreas</em>, Fig. @ref(fig:toadlh)) comprises two stages (juveniles and adults) and four transitions.</p>
<p>In all structured popuation models<a href="#fn23" class="footnote-ref" id="fnref23"><sup>23</sup></a>, a transition is the annual contribution of an individual in stage <span class="math inline">\(i\)</span> at time <span class="math inline">\(t\)</span> to stage <span class="math inline">\(j\)</span> at <span class="math inline">\(t+1\)</span>. In Fig. @ref(fig:toadlh), the transition from juvenile to adult is the probability that a juvenile survives an entire year and also matures, becoming sexually viable.<a href="#fn24" class="footnote-ref" id="fnref24"><sup>24</sup></a> The transition from juvenile to juvenile is the probability that a juvenile survives a year and does not mature. The transition from adult to adult is the probability that an adult survives the year. These three transitions are probabilities.</p>
<p>The transition from adult to juvenile (Fig. @ref(fig:toadlh)) is typically referred to as <em>fecundity</em>, and it is the product of several events. Vonesh and De la Cruz assume that this transition depends on the population sex ratio, the average clutch size of a female, egg survival, larval survival and metamorphosis, and the overwintering survival of metamorphs. They even assume that larval survival depnds on denisty. Thus what we refer to as “fecundity”<a href="#fn25" class="footnote-ref" id="fnref25"><sup>25</sup></a> is far more than just average clutch size because it must include all the processes that occur over the year associated with producing a clutch and the survival of that clutch.</p>
<p>Structured population models allow us to take advantage of the natural history of our study species. For our study population, at a minimum, we need to (i) identify stages that differ in their demographic rates, and (ii) when individuals tend to breed.</p>
<p>Consider the example of the Western toad (<em>Anaxyrus boreas</em>). As with all amphibians, survival and fecundity rates depend heavily or entirely on life history stages of egg, larvae (tadpole), juvenile, and adult. We would know that breeding occurs in early spring, depending on latitude and elevation. If we wanted to model juveniles and adults, we would typically sample a population prior to breeding when juveniles and adults are just starting to become active.</p>
<p>The design of a structured population model depends on the sampling or census schedule. These models are typically assume an annual census that occurs just before, and just after seed set, egg laying, or births. We refer to these as <em>pre-breeding</em> or <em>post-breeding</em> census models. <span class="citation">Vonesh and Cruz (<a href="#ref-Vonesh:2002fr" role="doc-biblioref">2002</a>)</span> (Fig. @ref(fig:toadlh)) use a pre-breeding census model. This is because only juveniles and adults are present in the population at the time of sampling. If the design assumed a post-breeding census (later in the year), it would probably include three stages, with larva (tadpoles) in addition to juveniles and adults.</p>
<p>The reasons for using a pre- <em>vs.</em> post-breeding census include our ability to actually identify and sample stages, and parameter estimation. For example, it may be easy to accurately estimate the abundance of juvenile and adult toads, but very difficult to estimate larval density and larval survival. In such a case, we could represent the adult to juvenile transition as a black box, estimated as the total number of new juveniles in year <span class="math inline">\(t+1\)</span> divided by the number of adults in year <span class="math inline">\(t\)</span>.</p>
<p>We can draw a two different types of life cycle graphs for this two-stage model in just such a population (Fig. @ref(fig:vdlc1)). Some people find one more illuminating than the other. It is useful to be able to use both.</p>
<div class="figure">
<img src="figs/vdlc2.jpg" alt="Two types of life cycle graphs. These both represent an amphibian pre-breeding model." width="65%" /><img src="figs/vdlc1-2.png" alt="Two types of life cycle graphs. These both represent an amphibian pre-breeding model." width="65%" />
<p class="caption">
(#fig:vdlc1)Two types of life cycle graphs. These both represent an amphibian pre-breeding model.
</p>
</div>
<p>All the stages must be present during the annual census, and each arrow or
transition must represent everything that happens over the
entire year. Notice the transition from adult toad to juvenile toad
(Fig. @ref(fig:vdlc1)) includes egg production, egg survival, tadpole or
larva survival and growth, and metamorphosis out of the aquatic
stage. This are obviously important events. We make explicit only those stages that we count during our census; all other other events are iplicit within the transitions.</p>
<p>Once we have a life cycle diagram (Fig. @ref(fig:vdlc1)), we create a <em>transition</em> or <em>projection</em> matrix that represents mathematically all of the stages and transitions between stages @ref(eq:m1). This matrix will have one row and one column for each stage, and the columns represent the stages in year <span class="math inline">\(t\)</span> and the rows represent the stages in year <span class="math inline">\(t+1\)</span>. We refer to a single column by <em>j</em> and a single row by <em>i</em>. Each column represents stage <em>j</em> in year <span class="math inline">\(t\)</span>, and each row represents stage <em>i</em> in year <span class="math inline">\(t+1\)</span>. For our amphibian example, the transition matrix will have two rows and two columns. It will be a “two by two”, or <span class="math inline">\(2 \times 2\)</span> matrix.
<span class="math display">\[
\begin{equation}
(\#eq:m1)
 \mathbf{A} =
\left(
\begin{array}{cc}
 p_{11}&amp;F_{12} \\
p_{21}&amp;p_{22} 
\end{array}
\right)
\end{equation}
\]</span>
If @ref(eq:m1) represents the Western toad (Fig. @ref(fig:vdlc1)), then transition</p>
<ul>
<li><span class="math inline">\(p_{11}\)</span> is the probability that juveniles survive but fail to mature,</li>
<li><span class="math inline">\(p_{21}\)</span> is the probability that juveniles survive and also mature,</li>
<li><span class="math inline">\(p_{22}\)</span> is the probability that adults survive, and</li>
<li><span class="math inline">\(F_{12}\)</span> is contribution of the average adult to the juvenile stage.</li>
</ul>
<p>In addition to fecundity, survival, maturation or growth from one stage to the next, some organisms undergo <em>regression</em> (Fig. @ref(fig:conceptualmatrix)). Regressing means to transition from a later stage to an earlier stage. For instance, and plant can shrink in size do to physical damage, disease or herbivory. A plant can also return temporarily to a non-reproductive stage after a large bout of reproduction. These are examples of regression (Fig. @ref(fig:conceptualmatrix)).</p>
<p>One assumption we are making is that individuals set seed, or give birth, all at once. Therefore, we refer to our model as a <em>birth-pulse model</em>. On the other hand, if we assume that we have continuous reproduction throughout the year, we do things differently, and would refer to this as a <em>birth-flow model</em>. Whether a population is breeding continuously over a year, or whether reproduction is seasonal, will influence how we estimate fecundities. Even for synchronously breeding populations, many models pool years into a single age class or stage. The interested reader should consult an authoritative text such as <span class="citation">Caswell (<a href="#ref-Caswell:2001gu" role="doc-biblioref">2001</a>)</span>.</p>
<div class="figure">
<img src="figs/conceptualmatrix-1.png" alt="A transition matrix, in which each element in the matrix describes the probability that an individual of a given size $j$ at time $t$ appears as size $i$ and time $t+1$. Reproduction typically results in the minimum size, stage, or age. This matrix may be composed of a small number of rows and columns (2-10), or, in the case of integral projection, an infinite number of rows and columns. The number of rows is equal to the number of columns." width="100%" />
<p class="caption">
(#fig:conceptualmatrix)A transition matrix, in which each element in the matrix describes the probability that an individual of a given size <span class="math inline">\(j\)</span> at time <span class="math inline">\(t\)</span> appears as size <span class="math inline">\(i\)</span> and time <span class="math inline">\(t+1\)</span>. Reproduction typically results in the minimum size, stage, or age. This matrix may be composed of a small number of rows and columns (2-10), or, in the case of integral projection, an infinite number of rows and columns. The number of rows is equal to the number of columns.
</p>
</div>
<p>A life cycle graph (Figs. @ref(fig:toadlh), @ref(fig:vdlc1)) and the corresponding transition matrix @ref(eq:m1) constitute our model. The matrix <strong>A</strong> for our structured population is directly analogous to <span class="math inline">\(\lambda\)</span> for our unstructured model of discrete population growth in the previous chapter.<a href="#fn26" class="footnote-ref" id="fnref26"><sup>26</sup></a></p>
<p>Later, we will project the population in an analogous way, using
<span class="math display">\[\mathbf{ N_{t+1} = A N_t}\]</span>
and to do that, we need a refresher on matrix multiplication.</p>
</div>
<div id="a-brief-primer-on-matrices" class="section level2">
<h2><span class="header-section-number">5.2</span> A brief primer on matrices</h2>
<p>We refer to matrices by their rows and columns. A matrix with three rows and one column is a <span class="math inline">\(3 \times 1\)</span> matrix (a ``three by one’’ matrix); we <em>always</em> state the number of rows first. Matrices comprise <em>elements</em>; an element of a matrix is signified by its row and column. The element in the second row and first column is <span class="math inline">\(a_{21}\)</span>. The <em>dimension</em> of a matrix is its number of rows and columns.</p>
<p>To add two matrices, they must have the same dimensions. Consider two matrices, <strong>A</strong> and <strong>B</strong> . To add these two matrices we simply add the elements in the same row and column of both matrices, as below.</p>
<p><span class="math display">\[\begin{align*}
\mathbf{A} &amp;=
\left(
\begin{array}{cc}
a &amp; b \\
c &amp; d
\end{array} \right); \;
\mathbf{B} =
\left(\begin{array}{cc}
m &amp; o\\
n &amp; p
\end{array}\right)\\
\mathbf{A+B} &amp;=
\left( \begin{array}{cc}
\left( a+m \right) &amp; \left(b+o \right)\\
\left(c+n \right) &amp; \left(d+p \right)
\end{array} \right) 
\end{align*}\]</span></p>
<p>Multiplying matrices is a little more complicated. To do so, we mutliply elements and then sum them:</p>
<ul>
<li>multiply each row element of the first matrix (<strong>A</strong>) times each column element of the second matrix (<strong>B</strong>),</li>
<li>sum the element-wise products, and</li>
<li>place this sum in the respective element of the final matrix.</li>
</ul>
<p>This process is what we refer to as a <em>dot product</em> or sometimes <em>inner product</em>. When we have two vectors of equal length <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> the dot product is
<span class="math display">\[x \cdot y = x_1y_1 + x_2y_2 + \ldots + x_n y_n\]</span>
A dot product begins with two equal length vectors and returns a single number (i.e. a scalar).</p>
<p>Consider the matrix multiplication in @ref(eq:exM). We first multiply each element of row 1 of <strong>A</strong> (<span class="math inline">\(a\; b\)</span>), times the corresponding elements of column 1 of <strong>B</strong> (<span class="math inline">\(m\; n\)</span>), sum these products, and place the sum in the first row, first column of the resulting matrix. We then repeat this for each row of <strong>A</strong> and each column of <strong>B</strong>.</p>
<p><span class="math display">\[\begin{align}
(\#eq:exM)
\mathbf{AB} &amp;=
\left( \begin{array}{cc}
\left( am + bn \right) &amp; \left(ao+bp \right)\\
\left(cm + dn \right) &amp; \left(co + dp \right)
\end{array}\right) 
\end{align}\]</span></p>
<p>To do this, the number of columns in the first matrix must equal the number of rows in the second matrix. It also means that the resulting matrix will have the same number of rows as the first matrix, and the same number of columns as the second matrix. Multiplying a <span class="math inline">\(2 \times 2\)</span> matrix by a <span class="math inline">\(2 \times 1\)</span> results in a <span class="math inline">\(2 \times 1\)</span>. Multiplying a <span class="math inline">\(3 \times 3\)</span> matrix by a <span class="math inline">\(3 \times 1\)</span> results in a <span class="math inline">\(3 \times 1\)</span>. We cannot multiply a <span class="math inline">\(2 \times 1\)</span> matrix by a <span class="math inline">\(2 \times 2\)</span> because the number of columns in the first matrix (1) does not match the number of rows in the second matrix (2).</p>
<p>Let’s define two <span class="math inline">\(2 \times 2\)</span> matrices, <strong>M</strong> and <strong>N</strong>, filling in one by rows, and the other by columns.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1"></a>(M &lt;-<span class="st"> </span><span class="kw">matrix</span>( <span class="dv">1</span><span class="op">:</span><span class="dv">4</span> , <span class="dt">nrow=</span><span class="dv">2</span>, <span class="dt">byrow=</span><span class="ot">TRUE</span>))</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4</code></pre>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1"></a>(N &lt;-<span class="st"> </span><span class="kw">matrix</span>( <span class="kw">c</span>(<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">40</span>), <span class="dt">nrow=</span><span class="dv">2</span>)) <span class="co"># byrow=FALSE is the default.</span></span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]   10   30
## [2,]   20   40</code></pre>
<p>Adding these matrices is simple. Here we do the first element by hand, and then sum the matrices all at once.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1"></a><span class="co"># 1 + 10</span></span>
<span id="cb86-2"><a href="#cb86-2"></a>M[<span class="dv">1</span>,<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>N[<span class="dv">1</span>,<span class="dv">1</span>]</span></code></pre></div>
<pre><code>## [1] 11</code></pre>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1"></a>M <span class="op">+</span><span class="st"> </span>N</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]   11   32
## [2,]   23   44</code></pre>
<p>To mulitply <strong>M</strong> and <strong>N</strong>, we multiply and then sum the first row of <span class="math inline">\(M\)</span> by the first column of <span class="math inline">\(N\)</span>, and make this element <span class="math inline">\(a_{11}\)</span> of the resulting matrix product.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1"></a><span class="co"># 1*10 + 2*20</span></span>
<span id="cb90-2"><a href="#cb90-2"></a>M[<span class="dv">1</span>,<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>N[<span class="dv">1</span>,<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>M[<span class="dv">1</span>,<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>N[<span class="dv">2</span>,<span class="dv">1</span>] </span></code></pre></div>
<pre><code>## [1] 50</code></pre>
<p>This is the dot product.</p>
<p>In R, we must use <code>%*%</code> to signify that we mean matrix multiplication.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1"></a>M <span class="op">%*%</span><span class="st"> </span>N</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]   50  110
## [2,]  110  250</code></pre>
<p>If we multiply <strong>M</strong> times a <span class="math inline">\(2 \times 1\)</span> matrix <strong>D</strong>, what should we get?</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1"></a>D &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">200</span>), <span class="dt">nrow=</span><span class="dv">2</span>)</span>
<span id="cb94-2"><a href="#cb94-2"></a>M <span class="op">%*%</span><span class="st"> </span>D</span></code></pre></div>
<pre><code>##      [,1]
## [1,]  500
## [2,] 1100</code></pre>
<div class="sourceCode" id="cb96"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1"></a><span class="co"># note that we cannot perform D %*% M</span></span></code></pre></div>
<p>Make sure you could write out the multiplication and summation for each element in the resulting matrix.</p>
<p>The transpose of <strong>M</strong> is <span class="math inline">\(\mathbf{M^T}\)</span></p>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1"></a>M; <span class="kw">t</span>(M)</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4</code></pre>
<p>We use the transpose of <strong>A</strong> to calculate reproductive value, later in the chapter.</p>
</div>
<div id="decomposing-a" class="section level2">
<h2><span class="header-section-number">5.3</span> Decomposing <strong>A</strong></h2>
<p>A slightly different way to conceptualize our transition matrix is to consider it the three separate matrices, one each for survival, growth, and fecundity,
<span class="math display">\[\mathbf{ A = SG + F }\]</span>.</p>
<p>Survival, <strong>S</strong>, and growth, <strong>G</strong>, havethese elements:</p>
<ul>
<li>each stage <span class="math inline">\(j\)</span> has its own probability of survival <span class="math inline">\(s_j\)</span>, which describes survival of each stage from <span class="math inline">\(t\)</span> to <span class="math inline">\(t+1\)</span>.</li>
<li>each survivor in stage <span class="math inline">\(j\)</span> will grow or regress into a different stage, or remain in the same stage, with probability <span class="math inline">\(g_{ij}\)</span>.</li>
</ul>
<p>In a demographic context, fecundity, <strong>F</strong>, is the surviving number of offspring produced by the average individual in stage <span class="math inline">\(i\)</span>. Sometimes this is a complete black box, in which we can only count the adults in year <span class="math inline">\(t\)</span> and the offspring in year <span class="math inline">\(t+1\)</span>. Other times, we can use estimates of the probability that an individual in stage <span class="math inline">\(i\)</span> reproduces at all, the average number of offspring of an individual that does actually reproduce, and the survival and growth of the adults or the resulting offspring. It all depends on the detail we have of our study system. And, of course, it depends heavily on whether we census our population shortly before reproduction (pre-breeding census), or shortly after reproduction (post-breeding census).</p>
<p>For our Western Toad (Fig. @ref(fig:toadlh)), this results in
<span class="math display">\[\begin{equation*}
(\#eq:SGF)
 \mathbf{A = SG + F} = 
 \left(
 \begin{array}{c}
 \sigma_j\\
\sigma_a
 \end{array} \right)
\left(
\begin{array}{cc}
1-\mathrm{P} &amp; 0 \\
\mathrm{P} &amp; 1
\end{array} \right)
+
\left(
\begin{array}{cc}
0 &amp; \rho \phi \sigma_e \sigma_t \sigma_m \\
0 &amp; 0
\end{array} \right)
\end{equation*}\]</span></p>
<p>where <span class="math inline">\(\sigma_j,\,\sigma_a\)</span> are survival of juveniles and adults, and P is the probability of juvenile growth, given survival. If an adult survives it always remains an adult (<span class="math inline">\(g_{22}=1\)</span>) and never regresses (<span class="math inline">\(g_{12}=0\)</span>). Fecundity occurs only in adults, and it is the product of the sex ratio (<span class="math inline">\(\rho\)</span>), average clutch size per female (<span class="math inline">\(\phi\)</span>), egg survival (<span class="math inline">\(\sigma_e\)</span>), survival of tadpoles (<span class="math inline">\(\sigma_t\)</span>), and the overwintering survival of the metamorphs (<span class="math inline">\(\sigma_m\)</span>).</p>
<p>Following the rules of matrix multiplication and addition, we now have</p>
<p>Vonesh and de la Cruz went further and added <em>density-dependence</em> using a term for the negative effects of high tadpole density on tadpole survival and growth. We do not show that here, but regardless how complex the natural history gets, we can build natural history into our models.</p>
<p><span class="math display">\[\begin{equation*}
(\#eq:SGA)
 \mathbf{SG} = 
\left(
\begin{array}{cc}
\sigma_j (1-\mathrm{P}) &amp; 0 \\
\sigma_j \mathrm{P} &amp; \sigma_a
\end{array} \right) \; ; \;
\mathbf{A} = 
\left(
\begin{array}{cc}
\sigma_j (1-\mathrm{P}) &amp; \rho \phi \sigma_e \sigma_t \sigma_m \\
\sigma_j \mathrm{P} &amp; \sigma_a
\end{array} \right)
\end{equation*}\]</span></p>
</div>
<div id="a-three-stage-model" class="section level2">
<h2><span class="header-section-number">5.4</span> A three stage model</h2>
Now we describe a three-stage model of a plant population. Like our amphibian example, it is a <em>pre-breeding</em> model, relying on a pre-breeding census. Nonetheless, it includes a seed stage for the seed bank, where seeds may be more than one year old. Eleanor <span class="citation">Pardini et al. (<a href="#ref-Pardini:2009aa" role="doc-biblioref">n.d.</a>)</span> and colleagues modeled garlic mustard (<em>Alliaria petiolata</em>), a biennial plant species that is an exotic invasive species in the eastern deciduous forest of the U.S. The stages they choose to represent were those present in May: seeds in the soil seed bank, 1–2 month old immature rosettes, and adults (Fig. @fig:garlic1).
<div class="figure">
<img src="figs/pardiniLC.pdf" alt="The life cycle of garlic mustard using a post-breeding census (Pardini et al. 2009). The census takes place in May of each year. Each arrow represents the transition from May to May. Seeds germinate in early spring and become rosettes (basal leaves near the soil surface). The rosettes experience mortality all summer, fall, and winter. Surviving rosettes become reproductive adults the following spring a summer. Adults flower and are pollinated in June, after which the fruits ripen and seeds mature. Seeds overwinter for at least six months before germinating in the spring. Not all seeds germinate, but they may remain viable in the seed bank for several years. Thus, the complete life cycle at least two years. Once the seeds germinate, the plant requires over a year to reach maturity, and produce flowers, fruits and seeds." width="90%" />
<p class="caption">
(#fig:garlic1)The life cycle of garlic mustard using a post-breeding census (Pardini et al. 2009). The census takes place in May of each year. Each arrow represents the transition from May to May. Seeds germinate in early spring and become rosettes (basal leaves near the soil surface). The rosettes experience mortality all summer, fall, and winter. Surviving rosettes become reproductive adults the following spring a summer. Adults flower and are pollinated in June, after which the fruits ripen and seeds mature. Seeds overwinter for at least six months before germinating in the spring. Not all seeds germinate, but they may remain viable in the seed bank for several years. Thus, the complete life cycle at least two years. Once the seeds germinate, the plant requires over a year to reach maturity, and produce flowers, fruits and seeds.
</p>
</div>
<p>Let’s work through these probability transitions.</p>
<ul>
<li><span class="math inline">\(s_1\)</span>, a germinated seed survives as a rosette.</li>
<li><span class="math inline">\(s_2\)</span>, surviving from May to August as a rosette.</li>
<li><span class="math inline">\(s_3\)</span>, surviving from August to early May and becoming a reproductive plant.</li>
<li><span class="math inline">\(v\)</span>, a seed is viable (survives and can germinate).</li>
<li><span class="math inline">\(g_1\)</span>, a viable seed germinates in the first season, or <span class="math inline">\(1-g_1\)</span> remains un germinated</li>
<li><span class="math inline">\(g_2\)</span>, a viable seed germinates in the second season or <span class="math inline">\(1-g_2\)</span> does not.</li>
</ul>
<p>Fecundity, <span class="math inline">\(f\)</span>, is the average number of seeds per reproductive plant.</p>
<p>The transition matrix <strong>A</strong> would thus be</p>
<p><span class="math display">\[\begin{equation*}
(\#eq:pardini)
 \mathbf{A} = 
\left(
\begin{array}{ccc}
 1-g_2  &amp; 0       &amp; v(1-g_1)f \\
g_2 s_1 &amp; 0       &amp; v g_1 s_1 f \\
0       &amp; s_2 s_3 &amp; 0
\end{array} \right)
\end{equation*}\]</span></p>
<p>Put into your own words each of the transition elements.</p>
<p>What about the transition from adult to rosette? Did the plant shrink? While perennial plants can get smaller, or <em>regress</em>, that is not what happens here. In this transition, the adult in May gets pollinated, develops fruits, the seeds mature and are deposited on the soil late that summer or fall. Those seeds are survive overwinter, germinate in early spring, and grow into rosettes that summer, and survive until the next census in May. In that way, stage 3 (adult) contributes to stage 2 (rosette) through reproduction plus survival and growth. The transition from adult to seed, <span class="math inline">\(p_{13}\)</span>, occurs only when the seeds do not germinate after the first winter, but spend another year in the seed bank in the soil.</p>
<p>Once we have the transition matrix, we can use it to characterize many features of the population, including the finite rate of increase (<span class="math inline">\(\lambda\)</span>), the predicted relative abundances of the various stages, and the relative importance of each separate transition <span class="math inline">\(p_{ij}\)</span> for the long term population growth rate. We will do this in a later section, but first will explore projection. It is frequently useful to acutally project the population, one year at a time, into the future.</p>
</div>
<div id="projection" class="section level2">
<h2><span class="header-section-number">5.5</span> Projection</h2>
<p><em>Projection</em> is the modeling of a population through time, for prediction under one or another set of assumptions. In practice, we use <em>matrix multiplication</em> to project stage- or structured populations. Matrix multiplication does all these calculations for us. We let <strong>A</strong> be our square demographic transition matrix, with one row and one column for each stage. Let <span class="math inline">\(\mathbf{N}_t\)</span> be a one-column matrix of stage sizes, with one row for each stage. Matrix multiplication allows us to project the population,
<span class="math inline">\(\mathbf{A}\mathbf{N}_t = \mathbf{N}_{t+1}\)</span>.</p>
<p>To project a population for multiple years, we use a <em>for-loop</em>. We used this in the previous chapter for an unstructured population. Here we multiply our transition matrix by the current year’s abundances projecting next year’s abundances. All we need to specify are the transition matrix, starting stage abundances for <span class="math inline">\(t=0\)</span>, and the number of years through which we want to project. Here we define a transition matrix, <span class="math inline">\(\mathbf{N}_0\)</span>, and a numbers of time steps to project.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1"></a>A &lt;-<span class="st"> </span><span class="kw">matrix</span>( <span class="kw">c</span>(.<span class="dv">1</span>, <span class="fl">2.0</span>, </span>
<span id="cb100-2"><a href="#cb100-2"></a>        <span class="fl">.3</span>,.<span class="dv">4</span>), <span class="dt">nrow=</span><span class="dv">2</span>, <span class="dt">byrow=</span>T)</span>
<span id="cb100-3"><a href="#cb100-3"></a>N0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">1</span>), <span class="dt">nrow=</span><span class="dv">1</span>) </span>
<span id="cb100-4"><a href="#cb100-4"></a>years &lt;-<span class="st"> </span><span class="dv">6</span></span></code></pre></div>
<p>To do the for-loop, we need an zeroes matrix to hold <span class="math inline">\(n\)</span> for each of the years of each of the stages, including for our first year. We start by filling our matrix with zeroes and “binding” the rows in <span class="math inline">\(\mathbf{N}_0\)</span> onto the top of our zeroes matrix as the first row.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb101-1"><a href="#cb101-1"></a>N.proj1 &lt;-<span class="st"> </span><span class="kw">matrix</span>( <span class="dv">0</span>, <span class="dt">nrow=</span>years, <span class="dt">ncol=</span><span class="kw">nrow</span>(A)) </span>
<span id="cb101-2"><a href="#cb101-2"></a><span class="kw">colnames</span>(N.proj1) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Juv&quot;</span>, <span class="st">&quot;Adult&quot;</span>)</span>
<span id="cb101-3"><a href="#cb101-3"></a>N.proj2 &lt;-<span class="st"> </span><span class="kw">rbind</span>(N0, N.proj1)</span></code></pre></div>
<p>Now we perform the iteration with the for-loop and plot the result. Note how we do the multiplication for the current year <span class="math inline">\(t\)</span> and put the result in the next year <span class="math inline">\(t+1\)</span>.</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1"></a><span class="co"># Project, then...</span></span>
<span id="cb102-2"><a href="#cb102-2"></a><span class="cf">for</span>(t <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>years) {N.proj2[t<span class="op">+</span><span class="dv">1</span>,] &lt;-<span class="st"> </span>A<span class="op">%*%</span>N.proj2[t,]}</span>
<span id="cb102-3"><a href="#cb102-3"></a><span class="co"># ...rearrange and plot</span></span>
<span id="cb102-4"><a href="#cb102-4"></a>N.proj.data &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Year=</span><span class="dv">0</span><span class="op">:</span>years, N.proj2)</span>
<span id="cb102-5"><a href="#cb102-5"></a>npd &lt;-<span class="st"> </span><span class="kw">gather</span>(N.proj.data, Stage, Abundance, <span class="op">-</span>Year)</span>
<span id="cb102-6"><a href="#cb102-6"></a><span class="kw">ggplot</span>(npd, <span class="kw">aes</span>(Year, Abundance, <span class="dt">linetype=</span>Stage)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>()</span></code></pre></div>
<div class="figure">
<img src="figs/projmat-1.png" alt="Projection of a population showing transient dynamics." width="90%" />
<p class="caption">
(#fig:projmat)Projection of a population showing transient dynamics.
</p>
</div>
<p>In the first seven years, we see the abundances of the two stages bounce around. These are <em>transient</em> dynamics that, in our density-independent models, will fade away over time.</p>
</div>
<div id="analyzing-the-transition-matrix" class="section level2">
<h2><span class="header-section-number">5.6</span> Analyzing the transition matrix</h2>
<p>Projection is very important for many reasons, especially for stochastic models or for very complicated models. However, we also get some of our best insights through direct analysis the transition matrix using <em>eigenanalysis</em> <span class="citation">(Caswell <a href="#ref-Caswell:2001gu" role="doc-biblioref">2001</a>)</span>.</p>
<p>The features we learn about a structured population using eigenanalysis are best thought of as predictions, attractors, or long term averages, assuming that the transition elements don’t change. This is a big assumption, but understanding it helps us interpret the analysis appropriately.</p>
<p>Once you have obtained the transition matrix, <span class="math inline">\(\mathbf{A}\)</span>, you can analysis it using <em>eigenanalysis</em> to estimate</p>
<ul>
<li><span class="math inline">\(\lambda\)</span>, the finite rate of increase,</li>
<li>stable stage structure,</li>
<li>reproductive value, and</li>
<li>sensitivities and elasticities.</li>
</ul>
<p>Below, we explain each of these quantities.</p>
<div id="eigenanalysis" class="section level3">
<h3><span class="header-section-number">5.6.1</span> Eigenanalysis</h3>
<p>Eigenanalysis is a mathematical technique that summarizes multivariate data. Ecologists use eigenanalysis frequently, for (i) multivariate statistics such as ordination, (ii) local stability analyses with two or more species, and (iii) analyzing population transition matrices. Eigenanalysis is simply a method to transform a square matrix into independent, or orthogonal, pieces. These pieces are <em>eigenvectors</em> and their corresponding <em>eigenvalues.</em> There are the same number of eigenvalues (and eigenvectors) as there are columns in a matrix. In demography, the two most useful pieces are the <em>dominant right eigenvalue</em> and its <em>corresponding right eigenvector</em>.</p>
<p>Eigenanalysis is a technique that finds all the solutions for <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(\mathbf{w}\)</span> of</p>
<p><span class="math display">\[\begin{equation}
(\#eq:eigsol)
\mathbf{Aw}=\lambda \mathbf{w}
\end{equation}\]</span>
where <span class="math inline">\(\mathbf{w}\)</span> is a particular summary of our data. With analysis of a transition matrix, <span class="math inline">\(\mathbf{A}\)</span> is the projection matrix, <span class="math inline">\(\lambda\)</span> is an <em>eigenvalue</em> and <span class="math inline">\(\mathbf{w}\)</span> is an <em>eigenvector</em>. If we write out eq. @ref(eq:eigsol) for a <span class="math inline">\(2 \times 2\)</span> matrix, we would have</p>
<p><span class="math display">\[
 (\#eq:eigsollong)
 \left(
 \begin{array}{ccc}
  a_{11} &amp; a_{12} \\
  a_{21} &amp; a_{22}\\
 \end{array} 
 \right) 
 \left(
  \begin{array}[c]{c}
   w_{11}\\
   w_{21}
  \end{array}
  \right)
  =\lambda \left(
  \begin{array}[c]{c}
   w_{11}\\
   w_{21}
  \end{array}
  \right)
\]</span></p>
<p>For instance, we can preform eigenanalysis on this transition matrix.</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb103-1"><a href="#cb103-1"></a>(A &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">.3</span>, <span class="dv">2</span>, <span class="fl">.7</span>), <span class="dt">nrow=</span><span class="dv">2</span>))</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]  0.0  2.0
## [2,]  0.3  0.7</code></pre>
<div class="sourceCode" id="cb105"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1"></a>(eA &lt;-<span class="st"> </span><span class="kw">eigen</span>(A))</span></code></pre></div>
<pre><code>## eigen() decomposition
## $values
## [1]  1.2 -0.5
## 
## $vectors
##            [,1]       [,2]
## [1,] -0.8574929 -0.9701425
## [2,] -0.5144958  0.2425356</code></pre>
<p>This gives us one eigenvalue per column of our transition matrix (<code>values</code>). Each eigenvalue has a <em>corresponding eigenvector</em> that is the corresponding column of the <code>vectors</code> matrix.</p>
<p>Let’s use R to prove to ourselves that eq. @ref(eq:eigsol) is what we say it is. Here we see for ourselves whether <span class="math inline">\(\mathbf{A}\mathbf{w} = \lambda \mathbf{w}\)</span> for
<span class="math inline">\(i = 1\)</span>. Below, we use the results of the previous eigenanalysis.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1"></a>(lambda1 &lt;-<span class="st"> </span>eA<span class="op">$</span>values[<span class="dv">1</span>])</span></code></pre></div>
<pre><code>## [1] 1.2</code></pre>
<div class="sourceCode" id="cb109"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1"></a>(w1 &lt;-<span class="st"> </span>eA<span class="op">$</span>vectors[,<span class="dv">1</span>])</span></code></pre></div>
<pre><code>## [1] -0.8574929 -0.5144958</code></pre>
<div class="sourceCode" id="cb111"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1"></a><span class="kw">cbind</span>(A <span class="op">%*%</span><span class="st"> </span>w1, lambda1 <span class="op">*</span><span class="st"> </span>w1)</span></code></pre></div>
<pre><code>##            [,1]       [,2]
## [1,] -1.0289915 -1.0289915
## [2,] -0.6173949 -0.6173949</code></pre>
<p>The first column is <span class="math inline">\(\mathbf{Aw}\)</span> and the second column is <span class="math inline">\(\lambda \mathbf{w}\)</span>. Sure enough, they look the same. Try doing the same exercise for the second eigenvalue and the second eigenvector, <span class="math inline">\(i=2\)</span>.</p>
<p>Typically, the first eigenvalue and its corresponding eigenvector capture the most important features of the transition matrix. We call these the dominant eigenvalue, <span class="math inline">\(\lambda_1\)</span>, and its corresponding eigenvector, <span class="math inline">\(w_1\)</span>. While first solution does not capture all of the information about our transition matrix, it is the most useful.</p>
<p>There are an infinite number of solutions to this equation because solutions can just be simple multiples of the set found with eigenanalysis. Eigenanalysis finds a set in which the solutions are all independent of each other, and which capture all of the information in <span class="math inline">\(\mathbf{A}\)</span> in a particularly useful way.</p>
<p>In this book, we will not delve into details of eigenanalysis beyond this. What is important for us is how we use the results. Below, we describe how we use eigenanalysis to find (i) the long term asymptotic finite rate of increase <span class="math inline">\(\lambda\)</span>, (ii) the <em>stable stage distribution</em>, and the the <em>reproductive values</em> of each stage.</p>
</div>
<div id="finite-rate-of-increase" class="section level3">
<h3><span class="header-section-number">5.6.2</span> Finite rate of increase</h3>
<p>
The asymptotic annual growth rate or finite rate of increase is the dominant eigenvalue of the transition matrix. Eigenvalues are always referred to with the Greek symbol <span class="math inline">\(\lambda\)</span>, and provide a solution to @ref(eq:eigsol). The dominant eigenvalue of any matrix, <span class="math inline">\(\lambda_{1}\)</span>, is the eigenvalue with the largest magnitude, and it is frequently a complex number. (When we perform eigenanalysis, it is common to get complex numbers, with real and imaginary parts. The magnitude is the sum of the squared parts.) With population transition matrices, <span class="math inline">\(\lambda_{1}\)</span> will always be positive and real. This will not be the case with other types of matrices we examine in later chapters.</p>
<p>The dominant eigenvalue is the biggest one. We can find which one it by asking R to tell us the index position <span class="math inline">\(i\)</span> of the largest absolute value (the modulus) of the eigenvalues. In most cases, it is the first eigenvalue, as it is here.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb113-1"><a href="#cb113-1"></a>( dom.pos &lt;-<span class="st"> </span><span class="kw">which.max</span>( <span class="kw">Mod</span>(eA[[<span class="st">&quot;values&quot;</span>]]) )  )</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>We use that index to extract the largest eigenvalue. We keep the real part, using <code>Re()</code>, dropping the imaginary part. (Note that although the dominant eigenvalue of a real transition matrix will always be real, R will include an imaginary part equal to zero (<span class="math inline">\(0i\)</span>) as a place holder if any of the eigenvalues has a non-zero imaginary part).</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb115-1"><a href="#cb115-1"></a><span class="co"># extract the dominant eigenvalue and retain only its Real part</span></span>
<span id="cb115-2"><a href="#cb115-2"></a>( L1 &lt;-<span class="st"> </span><span class="kw">Re</span>(eA[[<span class="st">&quot;values&quot;</span>]][dom.pos]) )</span></code></pre></div>
<pre><code>## [1] 1.2</code></pre>
<p><code>L1</code> is <span class="math inline">\(\lambda_1\)</span>, the aysmptotic finite rate of increase. This finite rate of increase has the same biological meaning as <span class="math inline">\(\lambda\)</span> in the previous chapter.</p>
</div>
<div id="stable-stage-distribution" class="section level3">
<h3><span class="header-section-number">5.6.3</span> Stable stage distribution</h3>
<p>The relative abundance of the different life history stages is called the <em>stage distribution</em>, that is, the distribution of individuals among the stages. A property of a stage structured population is that, if all the demographic rates (elements of the transition matrix) remain constant, its stage structure will approach a <em>stable</em> stage distribution, a stage distribution in which the <strong>relative</strong> number of individuals in each stage is constant. Note that a population can grow, so that the absolute number of individuals increases, but the relative abundances of the stages is constant; this is the stable stage distribution. If the population is not actually growing (i.e. <span class="math inline">\(\lambda=1\)</span>) and demographic parameters remain constant, then the population is <em>stationary</em> and will achieve a <em>stationary stage distribution</em>, where neither absolute nor relative abundances change.</p>
<p>How do we find the stable stage distribution? It also turns out that <span class="math inline">\(w_1\)</span> provides the necessary information. We scale the eigenvector <span class="math inline">\(w_1\)</span> by the sum of its elements because we are interested in the <em>distribution</em>, which is defined by all stages summing to one. Therefore the stable stage distribution is
<span class="math display">\[\begin{equation}
 (\#eq:ssd)
 \frac{w_1}{\sum_{i=1}^s{w_1}}
\end{equation}\]</span>
where <span class="math inline">\(s\)</span> is the number of stages.</p>
<p>Once a population reaches its stable stage distribution each of the stages grow exponentially, because
<span class="math display">\[\mathbf{Aw}=\lambda \mathbf{w}\]</span></p>
</div>
<div id="calculating-the-stable-stage-distribution" class="section level3">
<h3><span class="header-section-number">5.6.4</span> Calculating the stable stage distribution</h3>
<p>The dominant eigenvector, <span class="math inline">\(w_1\)</span>, is in the same position as the dominant eigenvalue. We extract <span class="math inline">\(w_1\)</span>, keeping just the real part, and divide it by its sum to get the stable stage distribution.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb117-1"><a href="#cb117-1"></a><span class="co"># continuing from previous code...</span></span>
<span id="cb117-2"><a href="#cb117-2"></a>w1 &lt;-<span class="st"> </span><span class="kw">Re</span>(eA[[<span class="st">&quot;vectors&quot;</span>]][,dom.pos])</span>
<span id="cb117-3"><a href="#cb117-3"></a>ssd &lt;-<span class="st"> </span>w1<span class="op">/</span><span class="kw">sum</span>(w1)</span>
<span id="cb117-4"><a href="#cb117-4"></a><span class="kw">round</span>(ssd, <span class="dv">3</span>)</span></code></pre></div>
<pre><code>## [1] 0.625 0.375</code></pre>
<p>This shows us that if the transition matrix does not change over time, the population will eventually be composed of these relative abundances.</p>
<p>We have claimed, without evidence, that with a constant transition matrix, the projected population will eventually reach a stable stage distribution and grow exponentially with a finite rate of increase of <span class="math inline">\(\lambda_1\)</span>. Here we show an example.</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb119-1"><a href="#cb119-1"></a>A &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">.3</span>, <span class="dv">2</span>, <span class="fl">.7</span>), <span class="dt">nrow=</span><span class="dv">2</span>) <span class="co"># our tran. matrix</span></span>
<span id="cb119-2"><a href="#cb119-2"></a>N0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">Juveniles=</span><span class="dv">1</span>,<span class="dt">Adults=</span><span class="dv">10</span>) <span class="co"># initial population</span></span>
<span id="cb119-3"><a href="#cb119-3"></a>steps &lt;-<span class="st"> </span><span class="dv">8</span> <span class="co"># number of time steps</span></span>
<span id="cb119-4"><a href="#cb119-4"></a><span class="co"># combine the stages of our initial population, and a zero matrix </span></span>
<span id="cb119-5"><a href="#cb119-5"></a><span class="co"># with a column for each stage and a row for each time step</span></span>
<span id="cb119-6"><a href="#cb119-6"></a>N &lt;-<span class="st"> </span><span class="kw">rbind</span>(N0, <span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">ncol=</span><span class="dv">2</span>, <span class="dt">nrow=</span>steps) )</span>
<span id="cb119-7"><a href="#cb119-7"></a><span class="co"># use a for-loop to project the population each year and store it.</span></span>
<span id="cb119-8"><a href="#cb119-8"></a><span class="cf">for</span>(t <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>steps) {N[t<span class="op">+</span><span class="dv">1</span>,] &lt;-<span class="st"> </span>A<span class="op">%*%</span>N[t,]}</span>
<span id="cb119-9"><a href="#cb119-9"></a><span class="co"># Sum the stages to get the total N</span></span>
<span id="cb119-10"><a href="#cb119-10"></a>N.total &lt;-<span class="st"> </span><span class="kw">rowSums</span>(N)</span>
<span id="cb119-11"><a href="#cb119-11"></a><span class="co"># For each year, divide each stage by the total to get </span></span>
<span id="cb119-12"><a href="#cb119-12"></a><span class="co"># relative abundances and thus the distribution.</span></span>
<span id="cb119-13"><a href="#cb119-13"></a>proportions &lt;-<span class="st"> </span>N<span class="op">/</span>N.total</span>
<span id="cb119-14"><a href="#cb119-14"></a>SD &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Year=</span><span class="dv">0</span><span class="op">:</span>steps, proportions)</span>
<span id="cb119-15"><a href="#cb119-15"></a>sdg &lt;-<span class="st"> </span><span class="kw">gather</span>(SD, Stage, Proportion, <span class="op">-</span>Year)</span>
<span id="cb119-16"><a href="#cb119-16"></a></span>
<span id="cb119-17"><a href="#cb119-17"></a><span class="co"># plot the distributions for succeeding years.</span></span>
<span id="cb119-18"><a href="#cb119-18"></a><span class="kw">ggplot</span>(sdg, <span class="kw">aes</span>(Stage, Proportion)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_col</span>()  <span class="op">+</span><span class="st"> </span></span>
<span id="cb119-19"><a href="#cb119-19"></a><span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span>Year, <span class="dt">nrow=</span><span class="dv">3</span>, <span class="dt">ncol=</span><span class="dv">3</span>)</span></code></pre></div>
<p><img src="figs/poweriter-1.png" width="90%" /></p>
<p>Using total population sizes, we can calculate an annual rate of increase <span class="math inline">\(N_{t+1}/N_t\)</span>.</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb120-1"><a href="#cb120-1"></a><span class="co"># using &quot;-&quot; in an index removes that element</span></span>
<span id="cb120-2"><a href="#cb120-2"></a>lambda.t &lt;-<span class="st"> </span>N.total[<span class="op">-</span><span class="dv">1</span>]<span class="op">/</span>N.total[<span class="op">-</span>(steps<span class="op">+</span><span class="dv">1</span>)] </span>
<span id="cb120-3"><a href="#cb120-3"></a><span class="kw">qplot</span>(<span class="dt">x=</span><span class="dv">1</span><span class="op">:</span>steps, <span class="dt">y=</span>lambda.t, <span class="dt">geom=</span><span class="kw">c</span>(<span class="st">&quot;line&quot;</span>, <span class="st">&quot;point&quot;</span>)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb120-4"><a href="#cb120-4"></a><span class="st">  </span><span class="kw">annotate</span>(<span class="st">&quot;point&quot;</span>, <span class="dt">x =</span> steps  , <span class="dt">y=</span>L1, <span class="dt">pch=</span><span class="dv">1</span>, <span class="dt">size=</span><span class="dv">3</span>) </span></code></pre></div>
<div class="figure">
<img src="figs/unnamed-chunk-36-1.png" alt="Calculating an annual finite rate of increase from a projected population shows that the population will approach asymptotically a constant geometric rate of increase. Solid points are annual growth rate; the circular point is lambda(1) from eigen analyysis." width="90%" />
<p class="caption">
(#fig:unnamed-chunk-36)Calculating an annual finite rate of increase from a projected population shows that the population will approach asymptotically a constant geometric rate of increase. Solid points are annual growth rate; the circular point is lambda(1) from eigen analyysis.
</p>
</div>
<p>Iterating the transition matrix to approximate <span class="math inline">\(\lambda_1\)</span> and <span class="math inline">\(w_1\)</span> is actually called the <em>power iteration method</em> for eigenanalysis.</p>
</div>
<div id="reproductive-value" class="section level3">
<h3><span class="header-section-number">5.6.5</span> Reproductive value</h3>
<p>
If the stage structure gives us one measure of the importance of a stage (its relative abundance), then the <em>reproductive value</em> gives us one measure of the importance of an <em>individual</em> in each stage. Reproductive value is the expected contribution of each individual to future reproduction. We characterize all individuals in a stage using the same expected reproductive value.</p>
<p>We find each stage’s reproductive value by solving for the dominant <em>left</em> eigenvector <span class="math inline">\(\mathbf{v}\)</span>, where
<span class="math display">\[\begin{equation}
 (\#eq:rv)
 \mathbf{vA}=\lambda\mathbf{v}
\end{equation}\]</span>
Like the relation between the dominant right eigenvector and the stable stage distribution, this vector is actually <em>proportional</em> to the reproductive values. Unlike the stable stage distribution, we scale it so that all reproductive values are relative to that of the first stage (e.g. juveniles or seeds).
<span class="math display">\[
 (\#eq:rv2)
  \frac{v}{v_{1}}
\]</span></p>
<p>We find the left eigenvalues and -vectors by performing eigenanalysis on the <em>transpose</em> of the transition matrix. Transposition flips rows and columns. We perform eigenanalysis, extracting just the dominant left eigenvector; we then scale it, so the stage 1 has a reproductive value of 1.0.</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb121-1"><a href="#cb121-1"></a>etA &lt;-<span class="st"> </span><span class="kw">eigen</span>(<span class="kw">t</span>(A))</span>
<span id="cb121-2"><a href="#cb121-2"></a>dom.pos &lt;-<span class="st"> </span><span class="kw">which.max</span>(<span class="kw">Mod</span>(etA<span class="op">$</span>values))</span>
<span id="cb121-3"><a href="#cb121-3"></a>v1 &lt;-<span class="st"> </span><span class="kw">Re</span>(etA<span class="op">$</span>vectors[,dom.pos])</span>
<span id="cb121-4"><a href="#cb121-4"></a>( rv &lt;-<span class="st"> </span>v1<span class="op">/</span>v1[<span class="dv">1</span>] )</span></code></pre></div>
<pre><code>## [1] 1 4</code></pre>
<p>Here we see that reproductive value, <span class="math inline">\(rv\)</span>, increases with age or stage. This means that the expected reproductive value of an individual in the second stage is <code>4</code> times as great as that of an individual in the first stage. In general, reproductive value of individuals in a stage increases with increasing probability of reaching fecund stages.</p>
</div>
<div id="sensitivity-and-elasticity" class="section level3">
<h3><span class="header-section-number">5.6.6</span> Sensitivity and elasticity</h3>
<p>Sensitivity and elasticity tell us the relative importance of each transition (i.e. each arrow of the life cycle graph or element of the matrix) in determining <span class="math inline">\(\lambda\)</span>. They do so by combining information on the stable stage structure and reproductive values.</p>
<p>The stage structure and reproductive values each in their own way contribute to the importance of each stage in determining <span class="math inline">\(\lambda\)</span>. The stable stage distribution provides the relative abundance of individuals in each stage. Reproductive value provides the expected contribution to future population growth of individuals in each stage. Sensitivity and elasticity combine these to tell us the relative importance of each transition in determining <span class="math inline">\(\lambda_1\)</span>.</p>
<p>Almost always, sensitivities of a transition matrix are the sensistivities of <span class="math inline">\(\lambda_1\)</span> to the elements of the transition matrix. They are the direct contributions of each transition to determining <span class="math inline">\(\lambda_1\)</span>. The sensitivity for the element <span class="math inline">\(a_{ij}\)</span> of a transition matrix is the change in <span class="math inline">\(\lambda_1\)</span> that occurs when we change <span class="math inline">\(a_{ij}\)</span> a small amount, or <span class="math inline">\(\delta \lambda / \delta a_{ij}\)</span>. It isn’t surprising, then, these are derived from the stable stage distribution and the reproductive values. Specifically, the sensitivities are calculated as</p>
<p><span class="math display">\[
\frac{\delta \lambda}{\delta a_{ij}}=\frac{v_{i}w_{j}}{v\cdot w} 
(\#eq:sens)
\]</span>
where <span class="math inline">\(v_{i}w_{j}\)</span> is the product of each pairwise combination of elements of the dominant left and right eigenvectors, <span class="math inline">\(v\)</span> and <span class="math inline">\(w\)</span>. Specifically, the numerator is generated by the reproductive value of the target stage and the stable stage distribution of the source stage,
<span class="math display">\[
\begin{pmatrix} v_1\\v_2 \end{pmatrix} \begin{pmatrix} w_1 &amp; w_2 \end{pmatrix}=
\begin{pmatrix} 
v_1 w_1 &amp; v_1 w_2 \\
v_2 w_1 &amp; v_2 w_2
\end{pmatrix}
\]</span></p>
<p>In the denominator, the <em>dot product</em>, <span class="math inline">\(\mathbf{v} \cdot \mathbf{w}\)</span>, is the sum of the pairwise products of each vector element. Dividing <span class="math inline">\(v_{i}w_{j}\)</span> by this sum causes the sensitivities to be relative to the magnitudes of <span class="math inline">\(v\)</span> and <span class="math inline">\(w\)</span>.</p>
<p>Let’s calculate sensitivities now. Because the stable stage distribution and the reproductive values are merely scaled versions of the dominant right and left eigenvectors, it doesn’t matter whether we use the unscaled eigenvectors, or the scaled stable stage distribution and reproductive values.</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb123-1"><a href="#cb123-1"></a>vw &lt;-<span class="st"> </span><span class="kw">matrix</span>(rv, <span class="dt">nr=</span><span class="dv">2</span>, <span class="dt">nc=</span><span class="dv">1</span>) <span class="op">%*%</span><span class="st"> </span><span class="kw">matrix</span>(ssd, <span class="dt">nr=</span><span class="dv">1</span>, <span class="dt">nc=</span><span class="dv">2</span>) <span class="co"># or vw &lt;- v1 %*% t(w1); the numerator</span></span>
<span id="cb123-2"><a href="#cb123-2"></a>dot.prod &lt;-<span class="st"> </span><span class="kw">sum</span>(rv<span class="op">*</span>ssd) <span class="co"># or dot.prod &lt;- sum(v1 * w1) denominator</span></span>
<span id="cb123-3"><a href="#cb123-3"></a>(s &lt;-<span class="st"> </span>vw<span class="op">/</span>dot.prod)</span></code></pre></div>
<pre><code>##           [,1]      [,2]
## [1,] 0.2941176 0.1764706
## [2,] 1.1764706 0.7058824</code></pre>
<p>These are the sensitivities, <span class="math inline">\(\delta \lambda / \delta a_{ij}\)</span>, of each corresponding transition element. You will always get a sensitivity for every position in this matrix, even when the transition is zero, <span class="math inline">\(a_{ij}=0\)</span>. We just ignore those, but by convention, include them.</p>
<p>These sensitivities are the relative change in <span class="math inline">\(\lambda_1\)</span> for an absolute change in the element. For instance, it is the relative effect of increasing <span class="math inline">\(a_{21}\)</span> from 0.3 to 0.33, or <span class="math inline">\(a_{22}\)</span> from 0.7 to 0.73.</p>
<p>The largest of these sensitivities is that for is <span class="math inline">\(p_{21}\)</span>, surviving from the first stage to the second stage. This means that small changes to <span class="math inline">\(p_{21}\)</span> have large effects on <span class="math inline">\(\lambda_1\)</span> than do small changes to <span class="math inline">\(F_2\)</span> or <span class="math inline">\(p_{22}\)</span>.</p>
As <span class="math inline">\(\delta \lambda / \delta a_{ij}\)</span>, the sensitivities are the slope of the line relating the magnitude of <span class="math inline">\(\lambda_1\)</span> to the matrix element.
<div class="figure">
<img src="figs/unnamed-chunk-39-1.png" alt="Sensitivities of lambda to transition elements are slopes. The dotted line is the calculated sensitivity of lambda to A[2,1], because it is the slope evaluated at A[2,1]." width="75%" />
<p class="caption">
(#fig:unnamed-chunk-39)Sensitivities of lambda to transition elements are slopes. The dotted line is the calculated sensitivity of lambda to A[2,1], because it is the slope evaluated at A[2,1].
</p>
</div>
<p><em>Elasticities</em> are sensitivities that have been weighted by the transition probabilities. We may, however, be interested in how a <em>proportional</em> change in a transition element influences <span class="math inline">\(\lambda_1\)</span>—how does a 10% increase in seed production, or a 10% decline in juvenile survival influence <span class="math inline">\(\lambda_1\)</span>? For these answers, we need to adjust sensitivities to account for the relative magnitudes of the transition elements, and this provides the elasticities, <span class="math inline">\(e_{ij}\)</span>. Elasticities are <em>relative sensitivities</em>, and are defined as</p>
<p><span class="math display">\[
e_{ij}=\frac{\delta \lambda/\lambda}{\delta a_{ij}/a_{ij}} = \frac{a_{ij}}{\lambda}\frac{\delta \lambda}{\delta a_{ij}}.
\]</span>
These are also equal to
<span class="math display">\[e_{ij}= \frac{\delta \log \lambda}{\delta \log a_{ij}}.\]</span>
Like sensitivities, we can think of elasticities as slopes.</p>
<p>Calculating these in R is easy.</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb125-1"><a href="#cb125-1"></a>e &lt;-<span class="st"> </span>(A<span class="op">/</span>L1) <span class="op">*</span><span class="st"> </span>s</span>
<span id="cb125-2"><a href="#cb125-2"></a>(<span class="kw">round</span>(e, <span class="dv">3</span>))</span></code></pre></div>
<pre><code>##       [,1]  [,2]
## [1,] 0.000 0.294
## [2,] 0.294 0.412</code></pre>
<p>Now we see that survival by adults (<span class="math inline">\(p_{22}\)</span>) has the biggest effect on <span class="math inline">\(\lambda_1\)</span>. Why the difference between sensitivities and elasticities? Because the elasticities reflect the effect of a <em>proportional change</em> (e.g., 1%) of the elements, whereas sensitivities reflect the effect of a change by a constant amount (e.g., 0.01) of each element.</p>
<p>Note that elasticities are relative to each other, in that they sum to 1.0. This is an especially nice features of elasticities because it makes it easier to compare elasticities among differ matrices and even different organisms.</p>
<p>Once we have the sensitivities and elasticities, we can really begin to see what is controlling the growth rate of a stage (or age) structured population. Although these values do not tell us which stages and transitions will be influenced by natural phenomona or management practices, they provide us with the predicted effects on <span class="math inline">\(\lambda_1\)</span> of a proportional change in a demographic rate. This is particularly important in the management of invasive (or endangered) species where we seek to have the maximum impact for the minimum amount of effort and resources <span class="citation">(Caswell <a href="#ref-Caswell:2001gu" role="doc-biblioref">2001</a>; Ellner and Guckenheimer <a href="#ref-Ellner:2006qe" role="doc-biblioref">2006</a>)</span>.</p>
<p><em>All of these details can get very confusing</em>, and smart people don’t always get it right. Therefore, get expert advice <span class="citation">(Caswell <a href="#ref-Caswell:2001gu" role="doc-biblioref">2001</a>; Ellner and Guckenheimer <a href="#ref-Ellner:2006qe" role="doc-biblioref">2006</a>)</span>, and remember that the stages of life cycle graph and matrix are the stages that you collect at one point in time, and an arrow or transition element has to include everything that happens from one census period to the next.</p>
<hr />
<p>What do we do if our stages seem like arbitrary categories along a continuous scale? What if size is easy to measure accurately and is a really good predictor of demographic rates, and these rates vary continuously with size? How do we decide on size classes? How do we draw seemingly arbitrary divisions between different sizes?</p>
<p>With <em>integral projection</em>, as opposed to matrix projection, we no
longer have to worry about a particular number of stages or age
classes. We select an individual-level state variable, such as body mass, length, stem diameter, or even location, that is a useful predictor of
demographic rates. We use this continuously varying state variable in place of stages or age classes. We rely on statistical methods, such as linear regression, to describe the relations between the individual-level state variable and survival, growth, and fecundity. We then combine those relations to model how individuals in a population are likely to change from one generation to the next.</p>
<p>In many organisms, size is often a relatively good predictor of survival and fecundity. Within a poulation, size is often associated with age, learning, and resource acquisition. Size is also related to the onset of reproductive maturity and initiation of specific reproductive structures. Among reproductive individuals, size is often strongly correlated with per capita reproductive output. Integral projection can use size to model size-dependent demography.</p>
<p>Whereas matrix projection models use matrix algebra to project populations. Matrix algebra is mutliplication of discrete classes and summation of discrete products. Integral projection models (IPMs) use multiplication and the calculus of integration across continuous variables toward the same end.</p>
</div>
</div>
<div id="r-packges-for-demography" class="section level2">
<h2><span class="header-section-number">5.7</span> R packges for demography</h2>
<p><span class="citation">Caswell (<a href="#ref-Caswell:2001gu" role="doc-biblioref">2001</a>)</span> is a definitive reference text for matrix models. <span class="citation">Ellner and Guckenheimer (<a href="#ref-Ellner:2006qe" role="doc-biblioref">2006</a>)</span> provides an excellent introduction, and I am sure there are many other excellent texts as well.</p>
<p><span class="citation">Stubben and Milligan (<a href="#ref-Stubben:2007" role="doc-biblioref">2007</a>)</span> and <span class="citation">Stott, Hodgson, and Townley (<a href="#ref-Stott:2018" role="doc-biblioref">2018</a>)</span>, and <span class="citation">de la Cruz (<a href="#ref-delaCruz:2019" role="doc-biblioref">2019</a>)</span> provide R packages for stage-based matrix models with methods that go well beyond this text. In addition, there are several other packages for analyzing life tables and human demography.</p>
<p><span class="citation">Ellner, Childs, and Rees (<a href="#ref-Ellner:2016aa" role="doc-biblioref">2016</a>)</span> is probably the best source for understanding IPMs. The R package IPMpack <span class="citation">(Metcalf et al. <a href="#ref-Metcalf:2014ab" role="doc-biblioref">2014</a>)</span> is an excellent package to implement and analyze IPMs.</p>
</div>
<div id="exploring-a-real-population" class="section level2">
<h2><span class="header-section-number">5.8</span> Exploring a real population</h2>
<p><span class="citation">Crouse, Crowder, and Caswell (<a href="#ref-Crouse1987" role="doc-biblioref">1987</a>)</span> performed a demographic analysis of an endangered sea turtle species, the loggerhead (<em>Caretta caretta</em>). Management of loggerhead populations seemed essential for their long term survival, and a popular management strategy had been and still is to protect nesting females, eggs, and hatchlings. The ground breaking work by Crouse<a href="#fn27" class="footnote-ref" id="fnref27"><sup>27</sup></a> and her colleagues compiled data to create a stage-based projection matrix to analyze quantitatively which stages are most important and least important in influencing long-term growth rate. This work led to US Federal laws requiring that US shrimp fishermen use nets that include Turtle Excluder Devices (TEDs, <a href="https://www.fisheries.noaa.gov/southeast/bycatch/turtle-excluder-device-regulations" class="uri">https://www.fisheries.noaa.gov/southeast/bycatch/turtle-excluder-device-regulations</a> ). Crouse et al. determined a transition matrix, <strong>A</strong>, for their loggerhead population:</p>
<p><span class="math display">\[\begin{array}{c}
H\\J_s\\J_l \\sub \\ B_1 \\B_2 \\ M
\end{array}
 \left(
\begin{array}{cccccccc}
     0&amp;      0&amp;      0&amp;      0&amp;    127&amp;      4&amp; 80\\
0.6747&amp; 0.7370&amp;      0&amp;      0&amp;      0&amp;      0&amp; 0\\
     0&amp; 0.0486&amp; 0.6610&amp;      0&amp;      0&amp;      0&amp; 0\\
     0&amp;      0&amp; 0.0147&amp; 0.6907&amp;      0&amp;      0&amp; 0\\
     0&amp;      0&amp;      0&amp; 0.0518&amp;      0&amp;      0&amp; 0\\
      0&amp;      0&amp;      0&amp;      0&amp; 0.8091&amp;      0&amp; 0\\
      0&amp;      0&amp;      0&amp;      0&amp;      0&amp; 0.8091&amp; 0.8089
\end{array} 
\right)\]</span></p>
<ol style="list-style-type: decimal">
<li>Draw by hand two different types of life cycle graphs for this loggerhead population. Include the matrix elements associated with each transition.</li>
<li>Use eigenanalysis to determine <span class="math inline">\(\lambda_1\)</span>. Explain what this tells us about the population, including any assumptions regarding the stable stage distribution.</li>
<li>Use eigenanalysis to determine the stable stage distribution.</li>
<li>Use eigenanalysis to determine the elasticities. Which transition(s) are most influential in determining growth rate?</li>
<li>What is the predicted long-term relative abundance of all stages? What do we call this?</li>
<li>If your interest is to maximize long-term growth rate, in which stage(s) should you invest protection measures? Which stages are least likely to enhance long-term growth rate, regardless of protective measures?</li>
<li>Start with <span class="math inline">\(\mathbf{N} = \left(1000\,10\,10\,10\,10\,10\,10\right)\)</span> and graph dynamics for all stages for 20 years.</li>
</ol>
<!--chapter:end:04-DIDemography.Rmd-->
</div>
</div>
<div id="references" class="section level1">
<h1><span class="header-section-number">6</span> References</h1>
<!--chapter:end:references.Rmd-->
<div id="refs" class="references">
<div id="ref-Banavar2002">
<p>Banavar, Jayanth R, John Damuth, Amos Maritan, Andrea Rinaldo, Geoffrey B West, and Brian J. Enquist. 2002. “Modelling universality and scaling - communications arising.” <em>Nature</em> 420 (December): 626–27.</p>
</div>
<div id="ref-Banavar1999">
<p>Banavar, J R, a Maritan, and a Rinaldo. 1999. “Size and form in efficient transportation networks.” <em>Nature</em> 399 (6732): 130–2.</p>
</div>
<div id="ref-Banavar2010">
<p>Banavar, J. R., M. E. Moses, J. H. Brown, J. Damuth, A. Rinaldo, R. M. Sibly, and A. Maritan. 2010. “A general basis for quarter-power scaling in animals.” <em>Proceedings of the National Academy of Sciences</em> 107 (36): 15816–20.</p>
</div>
<div id="ref-Beckerman2010">
<p>Beckerman, Andrew, Owen L. Petchey, and Peter J. Morin. 2010. “Adaptive Foragers and Community Ecology: Linking Individuals to Communities and Ecosystems.” <em>Functional Ecology</em> 24 (1): 1–6. <a href="https://doi.org/10.1111/j.1365-2435.2009.01673.x">https://doi.org/10.1111/j.1365-2435.2009.01673.x</a>.</p>
</div>
<div id="ref-Boenigk2002">
<p>Boenigk, J., C. Metz, K. Jürgens, and H. Arndt. 2002. “Food Concentration-Dependent Regulation of Food Selectivity of Interception Feeding Bacterivorous Nanoflagellates.” <em>Aquatic Microbial Ecology</em> 27: 195–202.</p>
</div>
<div id="ref-Brown:2004wa">
<p>Brown, J H, J F Gillooly, A P Allen, V M Savage, and G B West. 2004. “Toward a metabolic theory of ecology.” <em>Ecology</em> 85 (7): 1771–89.</p>
</div>
<div id="ref-Caswell:2001gu">
<p>Caswell, H. 2001. <em>Matrix Population Models: Construction, Analysis, and Interpretation</em>. 2nd ed. Sinauer Associates, Inc., Sunderland, MA, USA.</p>
</div>
<div id="ref-Charnov1976b">
<p>Charnov, E. L. 1976. “Optimal foraging theory: the marginal value theorem.” <em>Theoretical Population Biology</em> 9: 129–36.</p>
</div>
<div id="ref-Crouse1987">
<p>Crouse, D T, L B Crowder, and H Caswell. 1987. “A stage-based population model for loggerhead sea turtles and implications for conservation.” <em>Ecology</em> 68: 1412–23.</p>
</div>
<div id="ref-delaCruz:2019">
<p>de la Cruz, Marcelino. 2019. <em>Rramas: Matrix Population Models</em>. <a href="https://CRAN.R-project.org/package=Rramas">https://CRAN.R-project.org/package=Rramas</a>.</p>
</div>
<div id="ref-Ellner2009">
<p>Ellner, S. P. 2009. “Lecture Notes, Bioee 4600 Theoretical Ecology , Cornell University.”</p>
</div>
<div id="ref-Ellner:2006qe">
<p>Ellner, S P, and J Guckenheimer. 2006. <em>Dynamic Models in Biology</em>. Princeton University Press, Princeton, NJ.</p>
</div>
<div id="ref-Ellner:2016aa">
<p>Ellner, Stephen P., Dylan Z. Childs, and Mark Rees. 2016. <em>Data-Driven Modelling of Structured Populations: A Practical Guide to the Integral Projection Model</em>. Lecture Notes on Matehematical Modelling in the Life Sciences. Springer International Publishing.</p>
</div>
<div id="ref-Emlen1966">
<p>Emlen, J. M. 1966. “The Role of Time and Energy in Food Preference.” <em>The American Naturalist</em> 100: 611–17.</p>
</div>
<div id="ref-Gillooly2000">
<p>Gillooly, James F. 2000. “Effect of body size and temperature on generation time in zooplankton” 22 (2): 241–51.</p>
</div>
<div id="ref-Glazier2018">
<p>Glazier, Douglas S. 2018. “Rediscovering and Reviving Old Observations and Explanations of Metabolic Scaling in Living Systems.” <em>Systems</em> 6 (4).</p>
</div>
<div id="ref-Goettsch2015">
<p>Goettsch, Bárbara, Craig Hilton-Taylor, Gabriela Cruz-Piñón, James P. Duffy, Anne Frances, Héctor M. Hernández, Richard Inger, et al. 2015. “High proportion of cactus species threatened with extinction.” <em>Nature Plants</em> 1 (10): 15142.</p>
</div>
<div id="ref-Hastings2011">
<p>Hastings, A. 2011. “Single Species Population Dynamics and Its Theoretical Underpinnings.” In, edited by S. M. Scheiner and M. R. Willig. Chicago, IL, USA: University of Chicago Press.</p>
</div>
<div id="ref-Hutchinson1978">
<p>Hutchinson, G E. 1978. <em>An {I}ntroduction to {P}opulation {E}cology</em>. New Haven, CT: Yale University Press.</p>
</div>
<div id="ref-Kleiber1932">
<p>Kleiber, M. 1932. “Body Size and Metabolism.” <em>Hilgardia</em>, 315–32.</p>
</div>
<div id="ref-Lincoln:1998ta">
<p>Lincoln, R, G Boxshall, and P Clark. 1998. <em>A Dictionary of Ecology, Evolution and Systematics</em>. 2nd ed. Cambridge University Press, Cambridge UK.</p>
</div>
<div id="ref-MacArthur1966">
<p>MacArthur, R H, and E R Pianka. 1966. “On optimal use of a patchy environment.” <em>The American Naturalist</em> 100: 603–9.</p>
</div>
<div id="ref-Marquet2014">
<p>Marquet, Pablo A., Andrew P. Allen, James H. Brown, Jennifer A. Dunne, Brian J. Enquist, James F. Gillooly, Patricia A. Gowaty, et al. 2014. “On theory in ecology.” <em>BioScience</em> 64 (8): 701–10.</p>
</div>
<div id="ref-Metcalf:2014ab">
<p>Metcalf, C. J. E., S. M. McMahon, R. Salguero-Gomez, E. Jongejans, and C. Merow. 2014. <em>IPMpack: Builds and Analyses Integral Projection Models (Ipms).</em> <a href="https://CRAN.R-project.org/package=IPMpack">https://CRAN.R-project.org/package=IPMpack</a>.</p>
</div>
<div id="ref-Niklas2001">
<p>Niklas, Karl J., and Brian J. Enquist. 2001. “Invariant scaling relationships for interspecific plant biomass production rates and body size.” <em>Proceedings of the National Academy of Sciences of the United States of America</em> 98 (5): 2922–7.</p>
</div>
<div id="ref-ONeill1986">
<p>O’Neill, RV, DL De Angelis, JB Waide, and TFH Allen. 1986. <em>A Hierarchical Concept of Ecosystems.</em> Vol. 23. Monographs in Population Biology. Princeton University Press, Princeton, New Jersey, USA.</p>
</div>
<div id="ref-Pardini:2009aa">
<p>Pardini, Eleanor A., John M. Drake, Jonathan M. Chase, and Tiffany M. Knight. n.d. “Complex population dynamics and control of the invasive biennial Alliaria petiolata (garlic mustard).” <em>ECOLOGICAL APPLICATIONS</em> 19 (2): 387–97. <a href="https://doi.org/%7B10.1890/08-0845.1%7D">https://doi.org/{10.1890/08-0845.1}</a>.</p>
</div>
<div id="ref-Rose2017">
<p>Rose, Kevin C., Rose A. Graves, Winslow D. Hansen, Brian J. Harvey, Jiangxiao Qiu, Stephen A. Wood, Carly Ziter, and Monica G. Turner. 2017. “Historical foundations and future directions in macrosystems ecology.” <em>Ecology Letters</em> 20 (2): 147–57.</p>
</div>
<div id="ref-Scheiner2010">
<p>Scheiner, Samuel M. 2010. “Toward a conceptual framework for biology.” <em>Quarterly Review of Biology</em> 85 (3): 293–318.</p>
</div>
<div id="ref-Scheiner2011">
<p>Scheiner, S M, and M. R. Willig. 2011. <em>The Theory of Ecology</em>.</p>
</div>
<div id="ref-Sih2011">
<p>Sih, A. 2011. “Foraging Theory.” In, edited by S. M. Scheiner and M. R. Willig. Chicago, IL, USA: University of Chicago Press.</p>
</div>
<div id="ref-Stephens1986">
<p>Stephens, D W, and J R Krebs. 1986. <em>Foraging {T}heory</em>. Edited by J. R. Krebs and T. H. Clutton-Brock. Monographs in Behavior and Ecology. Princeton, University Press, Princeton, NJ, USA: Princeton University Press.</p>
</div>
<div id="ref-Stott:2018">
<p>Stott, Iain, Dave Hodgson, and Stuart Townley. 2018. <em>Popdemo: Demographic Modelling Using Projection Matrices</em>. <a href="https://CRAN.R-project.org/package=popdemo">https://CRAN.R-project.org/package=popdemo</a>.</p>
</div>
<div id="ref-Stubben:2007">
<p>Stubben, Chris J., and Brook G. Milligan. 2007. “Estimating and Analyzing Demographic Models Using the Popbio Package in R.” <em>Journal of Statistical Software</em> 22 (11).</p>
</div>
<div id="ref-Vonesh:2002fr">
<p>Vonesh, J R, and O de la Cruz. 2002. “Complex life cycles and density dependence: assessing the contribution of egg mortality to amphibian declines.” <em>Oecologia</em> 133 (3): 325–33.</p>
</div>
<div id="ref-West1997">
<p>West, G B, J H Brown, and B J Enquist. 1997. “A general model for the origin of allometric scaling laws in biology.” <em>Science</em> 276: 122–26.</p>
</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Miami University is located in the Miami River valley in Oxford, Ohio, USA; the region is home to the Myaamia tribe that dwelled here prior to European occupation.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>“ecology” derives from the Greek “oikos” which means the rules of the house<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>An entity may be an ecosystem, a community, a population, an individual, or some other system with operationally defined boundaries.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p><span class="math inline">\(E=mc^2\)</span> - need I say more?<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>Variables are quantities we measure and which change through time (e.g., population size). <em>Parameters</em> are (usually) fixed constants that govern the rates of change of variables (e.g., per capita birth rate).<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>Metabolic rate may be measured by variables tied directly to metabolism, such as the rate of oxygen or energy consumption, or CO<span class="math inline">\(_2\)</span> production.<a href="#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p>With plants, we often measure something called “specific leaf area”, SLA, which is the two dimensional area of a leaf divided by its mass.<a href="#fnref7" class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p>A linear relation is one in which <span class="math inline">\(y\)</span> is proportional to <span class="math inline">\(x\)</span>, or <span class="math inline">\(y \propto x\)</span>.<a href="#fnref8" class="footnote-back">↩︎</a></p></li>
<li id="fn9"><p>whether “I” is a sugar maple tree or a human, most of us do not make this decision conciously…<a href="#fnref9" class="footnote-back">↩︎</a></p></li>
<li id="fn10"><p>A forager encounters prey at random, and this is known as a “Poisson process”, where the number of encounters in a specified time interval is a random variable drawn from the Poisson probability distribution. It turns out that the <em>time between events</em> of a Poisson process follows the Exponential distribution. The Poisson distribution is determined by a single parameter, its mean. The Exponential distribution is also described by a single parameter, its <em>rate</em>. It turns out that we use the same <span class="math inline">\(\lambda\)</span> for both. }<a href="#fnref10" class="footnote-back">↩︎</a></p></li>
<li id="fn11"><p>We can check units for total handling time, <span class="math inline">\(H = S\lambda_i p_i h_i\)</span> by replacing the variables and parameters with their units. The units for <span class="math inline">\(H\)</span> are seconds, so we have <span class="math inline">\(\mathrm{s = s \frac{\#}{s} \frac{\#}{\#} \frac{s}{\#}}\)</span>. When we multiply these fractions, we find that the <span class="math inline">\(\#\)</span>s and two of the s’s cancel out and we are left with <span class="math inline">\(s=s\)</span>.<a href="#fnref11" class="footnote-back">↩︎</a></p></li>
<li id="fn12"><p>“expected” value of a variable is the mean of that variable, because that is what we expect given the absence of other knowledge<a href="#fnref12" class="footnote-back">↩︎</a></p></li>
<li id="fn13"><p>A constatnt ratio between successive numbers.<a href="#fnref13" class="footnote-back">↩︎</a></p></li>
<li id="fn14"><p>A zen koan if there ever was one.<a href="#fnref14" class="footnote-back">↩︎</a></p></li>
<li id="fn15"><p>No observed relation between <span class="math inline">\(\frac{\Delta N}{N}\)</span> vs. <span class="math inline">\(N\)</span><a href="#fnref15" class="footnote-back">↩︎</a></p></li>
<li id="fn16"><p>discrete generations are common in nature.<a href="#fnref16" class="footnote-back">↩︎</a></p></li>
<li id="fn17"><p>“Delta” N is the change in N.<a href="#fnref17" class="footnote-back">↩︎</a></p></li>
<li id="fn18"><p>I’ve come to abhor my use of the expression “look at”; I use it when I don’t say what I mean. “Look at” can mean alomst anything these days, and it rarely means only “looking at”…<a href="#fnref18" class="footnote-back">↩︎</a></p></li>
<li id="fn19"><p>Don’t use <code>attach</code> for anything important<a href="#fnref19" class="footnote-back">↩︎</a></p></li>
<li id="fn20"><p>Random, pseudorandom, and stochastic processes.<a href="#fnref20" class="footnote-back">↩︎</a></p></li>
<li id="fn21"><p>Note that there are many ways to estimate quantiles (R has nine ways), but they are approximately similar to percentiles.<a href="#fnref21" class="footnote-back">↩︎</a></p></li>
<li id="fn22"><p>In his chapter entitled ``Interesting Ways to Think about Death’’ G.E. Hutchinson <span class="citation">Hutchinson (<a href="#ref-Hutchinson1978" role="doc-biblioref">1978</a>)</span> cites C.~F. Trenerry, E.~L. Gover and A.~S. Paul (<em>The Origins and Early History of Insurance</em>, London, P.~S. King &amp; Sons, Ltd.) for description of early Roman actuarial tables.<a href="#fnref22" class="footnote-back">↩︎</a></p></li>
<li id="fn23"><p>Models comprise stages and transitions.<a href="#fnref23" class="footnote-back">↩︎</a></p></li>
<li id="fn24"><p>Practice these pronunciations: <span class="math inline">\(\sigma\)</span> is sigma <span class="math inline">\(\phi\)</span> is phi or phee; <span class="math inline">\(\rho\)</span> is rho.<a href="#fnref24" class="footnote-back">↩︎</a></p></li>
<li id="fn25"><p>In structured population models, fecundity includes survival.<a href="#fnref25" class="footnote-back">↩︎</a></p></li>
<li id="fn26"><p>A is the analog of lambda.<a href="#fnref26" class="footnote-back">↩︎</a></p></li>
<li id="fn27"><p>Crouse was a graduate student at the time—graduate students are the life-blood of modern science, doing cutting edge work and pushing their fields forward.<a href="#fnref27" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
<!--bookdown:body:end-->
            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->
    </div>
  </div>
<!--bookdown:config-->

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
