<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>4 Density-independent Demography | Primer of Ecology using R</title>
<meta name="author" content="Hank Stevens">
<meta name="description" content="In the preceding chapter, we listed Hastings’ (A. Hastings 2011) key principles and assumptions of single species population growth. One of the key assumptions is that “all individuals in a...">
<meta name="generator" content="bookdown 0.24 with bs4_book()">
<meta property="og:title" content="4 Density-independent Demography | Primer of Ecology using R">
<meta property="og:type" content="book">
<meta property="og:description" content="In the preceding chapter, we listed Hastings’ (A. Hastings 2011) key principles and assumptions of single species population growth. One of the key assumptions is that “all individuals in a...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="4 Density-independent Demography | Primer of Ecology using R">
<meta name="twitter:description" content="In the preceding chapter, we listed Hastings’ (A. Hastings 2011) key principles and assumptions of single species population growth. One of the key assumptions is that “all individuals in a...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/header-attrs-2.11/header-attrs.js"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.3.1/transition.js"></script><script src="libs/bs3compat-0.3.1/tabs.js"></script><script src="libs/bs3compat-0.3.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-VCV8MES4YY"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-VCV8MES4YY');
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS -->
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Primer of Ecology using R</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Preface</a></li>
<li><a class="" href="theory.html"><span class="header-section-number">1</span> Theory in Ecology</a></li>
<li><a class="" href="oft.html"><span class="header-section-number">2</span> Optimal Foraging</a></li>
<li><a class="" href="expo.html"><span class="header-section-number">3</span> Simple density-independent growth</a></li>
<li><a class="active" href="DID.html"><span class="header-section-number">4</span> Density-independent Demography</a></li>
<li><a class="" href="DDgrowth.html"><span class="header-section-number">5</span> Density-dependent growth</a></li>
<li><a class="" href="meta.html"><span class="header-section-number">6</span> Populations in Space</a></li>
<li><a class="" href="comp.html"><span class="header-section-number">7</span> Direct competition and mutualism</a></li>
<li><a class="" href="cr.html"><span class="header-section-number">8</span> Consumer-resource Interactions</a></li>
<li><a class="" href="host-parasitoid-relations.html"><span class="header-section-number">9</span> Host-parasitoid relations</a></li>
<li><a class="" href="disease.html"><span class="header-section-number">10</span> Disease</a></li>
<li><a class="" href="consumer-resource-competition-and-mutualisms.html"><span class="header-section-number">11</span> Consumer-resource Competition and Mutualisms</a></li>
<li><a class="" href="food-webs-and-other-networks.html"><span class="header-section-number">12</span> Food webs and other networks</a></li>
<li><a class="" href="diversity.html"><span class="header-section-number">13</span> Diversity</a></li>
<li><a class="" href="appendix.html"><span class="header-section-number">14</span> Appendix</a></li>
<li><a class="" href="references.html"><span class="header-section-number">15</span> References</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="DID" class="section level1" number="4">
<h1>
<span class="header-section-number">4</span> Density-independent Demography<a class="anchor" aria-label="anchor" href="#DID"><i class="fas fa-link"></i></a>
</h1>
<p>In the preceding chapter, we listed Hastings’ <span class="citation">(<a href="references.html#ref-Hastings2011" role="doc-biblioref">A. Hastings 2011</a>)</span> key principles and assumptions of single species population growth. One of the key assumptions is that “all individuals in a population are identical.” In this chapter, we elucidate an important violation of that assumption, population structure.</p>
<div class="figure">
<span style="display:block;" id="fig:human"></span>
<img src="figs/AgeDistM.png" alt="Demography of human populations of Mexico and Sweden. Based on 1990 data from US Census Bureau, Population Division, International Programs Center." width="30%"><img src="figs/AgeDistS.png" alt="Demography of human populations of Mexico and Sweden. Based on 1990 data from US Census Bureau, Population Division, International Programs Center." width="30%"><img src="figs/AgeSpecFert.png" alt="Demography of human populations of Mexico and Sweden. Based on 1990 data from US Census Bureau, Population Division, International Programs Center." width="30%"><p class="caption">
Figure 4.1: Demography of human populations of Mexico and Sweden. Based on 1990 data from US Census Bureau, Population Division, International Programs Center.
</p>
</div>
<p><em>Populations have structure.</em> Consider the human populations of Mexico and Sweden in 1990. Mexico had a much larger fraction of their population in child bearing age classes or younger (Fig. <a href="DID.html#fig:human">4.1</a>). In addition, the age-specific fertility rate was higher in Mexico, especially for younger women
(Fig. <a href="DID.html#fig:human">4.1</a>). How did this happen, and why did Mexico have so
many young people? What were the consequences of this for their
culture, their use of resources, their domestic and foreign policies,
and their future population growth? How about Sweden?</p>
<p>Demography is the study of populations with special attention to their structure <span class="citation">(<a href="references.html#ref-Lincoln:1998ta" role="doc-biblioref">Lincoln, Boxshall, and Clark 1998</a>)</span>. Originally, age-based human demography was the provenance of actuaries who helped governments keep track of the number citizens of different ages and thus, for instance, know how many would be available for conscription into the military.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;In his chapter entitled “Interesting Ways to Think about Death” G.E. Hutchinson &lt;span class="citation"&gt;&lt;a href="references.html#ref-Hutchinson1978" role="doc-biblioref"&gt;Hutchinson&lt;/a&gt; (&lt;a href="references.html#ref-Hutchinson1978" role="doc-biblioref"&gt;1978&lt;/a&gt;)&lt;/span&gt; cites C.~F. Trenerry, E.~L. Gover and A.~S. Paul (&lt;em&gt;The Origins and Early History of Insurance&lt;/em&gt;, London, P.~S. King &amp;amp; Sons, Ltd.) for description of early Roman actuarial tables.&lt;/p&gt;'><sup>23</sup></a></p>
<p><em>The reason we model the structure of populations</em> is because various demographic rates vary markedly with these stages. Juveniles produce no offspring. Very few seeds survive an entire year, whereas some large adults survive very well. We use structure when that structure is associated with important differences in demographic rates: <em>survival</em>, <em>fecundity</em>, and <em>growth</em>.</p>
<p>The <em>structure</em> to which we refer is simply the organization of populations by some character such as life history stage, age, or size. Sizes and ages are often reduced to categories such as we saw in human populations (e.g., 0–4.9,y, 5–9.9,y,…). Sizes may be based on any reliable and repeatable measure that relates to demographic rates and are similarly binned. Life history stages may include eggs, larvae, metamorphs, juveniles, and adults in amphibians, or seeds, rosettes, and reproductive stems in herbaceous plants. With a variable such as size, we don’t need to use categories, but rather we can use size as a continuous variable; we address this briefly later in the chapter.</p>
<p>Structured population models allow us to intertwine species-specific natural history and quantitative methods. This makes the approach especially appealing for the conservation biology of threatened and endangered species. We use structured population models to improve our understanding of a population or improve predictions of its future dynamics, or guide the management of the population. We might learn a lot about what controls the abundance of a species if we can test ideas related to different stages, ages, or sizes. What limits the population growth of the Western toad – is it egg survival, or overwintering survival of juveniles? Where should we invest our efforts to control garlic mustard (<em>Alliaria petiolata</em>) – killing the first year rosettes, or the second year adults? Why are cacti generally endangered <span class="citation">(<a href="references.html#ref-Goettsch2015" role="doc-biblioref">Goettsch et al. 2015</a>)</span>—is the smallest size or the largest size more important for long-term survival? We can use structured population models to address such questions.</p>
<div id="a-two-stage-matrix-model" class="section level2" number="4.1">
<h2>
<span class="header-section-number">4.1</span> A two stage matrix model<a class="anchor" aria-label="anchor" href="#a-two-stage-matrix-model"><i class="fas fa-link"></i></a>
</h2>
<div class="figure">
<span style="display:block;" id="fig:toadlh"></span>
<img src="figs/VoneshF1.png" alt="Like all amphibians, the Western toad (*Anaxyrus boreas*) has a complex life cycle, with several life history stages. Adults breed in early spring, laying eggs in water. The larvae (tadpoles) hatch and develop over the spring and summer, and then metamorphose (become metamorphs), and then juveniles. Juveniles require more than a year to mature. Adults can live up to about a decade. American toads (*A. americanus*) do the same thing." width="65%"><p class="caption">
Figure 4.2: Like all amphibians, the Western toad (<em>Anaxyrus boreas</em>) has a complex life cycle, with several life history stages. Adults breed in early spring, laying eggs in water. The larvae (tadpoles) hatch and develop over the spring and summer, and then metamorphose (become metamorphs), and then juveniles. Juveniles require more than a year to mature. Adults can live up to about a decade. American toads (<em>A. americanus</em>) do the same thing.
</p>
</div>
<p>A matrix model of a structured population consists of <em>stages</em> and <em>transitions</em>. <span class="citation"><a href="references.html#ref-Vonesh:2002fr" role="doc-biblioref">Vonesh and Cruz</a> (<a href="references.html#ref-Vonesh:2002fr" role="doc-biblioref">2002</a>)</span> used matrix projection to assess the importance of egg mortality for declines in amphibian populations. Their model of the Western toad (<em>Anaxyrus boreas</em>, Fig. <a href="DID.html#fig:toadlh">4.2</a>) comprises two stages (juveniles and adults) and four transitions.</p>
<p>In all structured popuation models<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Models comprise stages and transitions.&lt;/p&gt;"><sup>24</sup></a>, a transition is the annual contribution of an individual in stage <span class="math inline">\(i\)</span> at time <span class="math inline">\(t\)</span> to stage <span class="math inline">\(j\)</span> at <span class="math inline">\(t+1\)</span>. In Fig. <a href="DID.html#fig:toadlh">4.2</a>, the transition from juvenile to adult is the probability that a juvenile survives an entire year and also matures, becoming sexually viable.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Practice these pronunciations: &lt;span class="math inline"&gt;\(\sigma\)&lt;/span&gt; is sigma &lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt; is phi or phee; &lt;span class="math inline"&gt;\(\rho\)&lt;/span&gt; is rho.&lt;/p&gt;'><sup>25</sup></a> The transition from juvenile to juvenile is the probability that a juvenile survives a year and does not mature. The transition from adult to adult is the probability that an adult survives the year. These three transitions are probabilities.</p>
<p>The transition from adult to juvenile (Fig. <a href="DID.html#fig:toadlh">4.2</a>) is typically referred to as <em>fecundity</em>, and it is the product of several events. Vonesh and De la Cruz assume that this transition depends on the population sex ratio, the average clutch size of a female, egg survival, larval survival and metamorphosis, and the overwintering survival of metamorphs. They also assume that larval survival depends on density. Thus what we refer to as “fecundity”<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;In structured population models, fecundity includes survival.&lt;/p&gt;"><sup>26</sup></a> is far more than just average clutch size because it must include all the processes that occur over the year associated with producing a clutch and the survival of that clutch.</p>
<p>Structured population models allow us to take advantage of the natural history of our study species. For our study population, at a minimum, we need to (i) identify stages that differ in their demographic rates, and (ii) when individuals tend to breed.</p>
<p>Consider the example of the Western toad (<em>Anaxyrus boreas</em>). As with all amphibians, survival and fecundity rates depend heavily or entirely on life history stages of egg, larvae (tadpole), juvenile, and adult. Breeding often occurs in early spring, depending on latitude and elevation. If we wanted to model juveniles and adults, we would typically sample a population prior to breeding when juveniles and adults are just starting to become active.</p>
<p>The design of a structured population model depends on the sampling or census schedule. These models are typically assume an annual census that occurs just before, and just after seed set, egg laying, or births. We refer to these as <em>pre-breeding</em> or <em>post-breeding</em> census models. <span class="citation"><a href="references.html#ref-Vonesh:2002fr" role="doc-biblioref">Vonesh and Cruz</a> (<a href="references.html#ref-Vonesh:2002fr" role="doc-biblioref">2002</a>)</span> (Fig. <a href="DID.html#fig:toadlh">4.2</a>) use a pre-breeding census model. It is a pre-breeding census because only juveniles and adults are present in the population at the time of sampling. If the design assumed a post-breeding census (later in the year), it would include three stages, with larva (tadpoles) in addition to juveniles and adults.</p>
<p>The reasons for using a pre- <em>vs.</em> post-breeding census include our ability to actually identify stages, sample or census individuals in each stage, and whether we can estimate parameters. For example, it may be easy to accurately estimate the abundance of juvenile and adult toads, but very difficult to estimate larval density and larval survival. In such a case, we could represent the adult to juvenile transition as a black box, estimated as the total number of new juveniles in year <span class="math inline">\(t+1\)</span> divided by the number of adults in year <span class="math inline">\(t\)</span>.</p>
<p>We can draw two different types of life cycle graphs for this two-stage model in just such a population (Fig. <a href="DID.html#fig:vdlc1">4.3</a>). Some people find one more illuminating than the other. It is useful to be able to use both.</p>
<div class="figure">
<span style="display:block;" id="fig:vdlc1"></span>
<img src="figs/vdlc2.jpg" alt="Two types of life cycle graphs. These both represent an amphibian pre-breeding model." width="65%"><img src="figs/vdlc1-2.png" alt="Two types of life cycle graphs. These both represent an amphibian pre-breeding model." width="65%"><p class="caption">
Figure 4.3: Two types of life cycle graphs. These both represent an amphibian pre-breeding model.
</p>
</div>
<p>All the stages must be present during the annual census, and each arrow or
transition must represent everything that happens over the
entire year. Notice the transition from adult toad to juvenile toad
(Fig. <a href="DID.html#fig:vdlc1">4.3</a>) includes egg production, egg survival, tadpole or
larva survival and growth, and metamorphosis out of the aquatic
stage, and also overwintering of the juvenile. This are obviously important events. We make explicit only those stages that we count during our census; all other other events are implicit within the transitions.</p>
<p>Once we have a life cycle diagram (Fig. <a href="DID.html#fig:vdlc1">4.3</a>), we create a <em>transition</em> or <em>projection</em> matrix that represents mathematically all of the stages and transitions between stages <a href="DID.html#eq:m1">(4.1)</a>. This matrix will have one row and one column for each stage, and the columns represent the stages in year <span class="math inline">\(t\)</span> and the rows represent the stages in year <span class="math inline">\(t+1\)</span>. We refer to a single row by <em>i</em> and a single column by <em>j</em>. Each column represents stage <em>j</em> in year <span class="math inline">\(t\)</span>, and each row represents stage <em>i</em> in year <span class="math inline">\(t+1\)</span>. For our amphibian example, the transition matrix will have two rows and two columns. It will be a “two by two,” or <span class="math inline">\(2 \times 2\)</span> matrix.
<span class="math display" id="eq:m1">\[\begin{equation}
\tag{4.1}
 \mathbf{A} =
\left(
\begin{array}{cc}
 p_{11}&amp;F_{12} \\
p_{21}&amp;p_{22} 
\end{array}
\right)
\end{equation}\]</span>
If <a href="DID.html#eq:m1">(4.1)</a> represents the Western toad (Fig. <a href="DID.html#fig:vdlc1">4.3</a>), then transition</p>
<ul>
<li>
<span class="math inline">\(p_{11}\)</span> is the probability that juveniles survive but fail to mature,</li>
<li>
<span class="math inline">\(p_{21}\)</span> is the probability that juveniles survive and also mature,</li>
<li>
<span class="math inline">\(p_{22}\)</span> is the probability that adults survive, and</li>
<li>
<span class="math inline">\(F_{12}\)</span> is contribution of the average adult to the juvenile stage.</li>
</ul>
<p>In addition to fecundity, survival, maturation or growth from one stage to the next, some organisms undergo <em>regression</em> (Fig. <a href="DID.html#fig:conceptualmatrix">4.4</a>). Regressing means to transition from a later stage to an earlier stage. For instance, and plant can shrink in size due to physical damage, disease or herbivory. A plant can also return temporarily to a non-reproductive stage after a large bout of reproduction. These are examples of regression (Fig. <a href="DID.html#fig:conceptualmatrix">4.4</a>).</p>
<p>One assumption we make here is that individuals set seed, or give birth, all at once. Therefore, we refer to our model as a <em>birth-pulse model</em>. On the other hand, if we assume that we have continuous reproduction throughout the year, we do things differently, and would refer to this as a <em>birth-flow model</em>. Whether a population is breeding continuously over a year, or whether reproduction is seasonal, will influence how we estimate fecundities. Even for synchronously breeding populations, many models pool years into a single age class or stage. The interested reader should consult an authoritative text such as <span class="citation"><a href="references.html#ref-Caswell:2001gu" role="doc-biblioref">Caswell</a> (<a href="references.html#ref-Caswell:2001gu" role="doc-biblioref">2001</a>)</span>.</p>
<div class="figure">
<span style="display:block;" id="fig:conceptualmatrix"></span>
<img src="figs/conceptualmatrix-1.png" alt="A transition matrix, in which each element in the matrix describes the probability that an individual of a given size $j$ at time $t$ appears as size $i$ and time $t+1$. Reproduction is typically a contribution to the minimum size, stage, or age. This matrix may comprise a small number of rows and columns (2-10), or, in the case of integral projection, an infinite number of rows and columns. The number of rows is equal to the number of columns." width="100%"><p class="caption">
Figure 4.4: A transition matrix, in which each element in the matrix describes the probability that an individual of a given size <span class="math inline">\(j\)</span> at time <span class="math inline">\(t\)</span> appears as size <span class="math inline">\(i\)</span> and time <span class="math inline">\(t+1\)</span>. Reproduction is typically a contribution to the minimum size, stage, or age. This matrix may comprise a small number of rows and columns (2-10), or, in the case of integral projection, an infinite number of rows and columns. The number of rows is equal to the number of columns.
</p>
</div>
<p>A life cycle graph (Figs. <a href="DID.html#fig:toadlh">4.2</a>, <a href="DID.html#fig:vdlc1">4.3</a>) and the corresponding transition matrix <a href="DID.html#eq:m1">(4.1)</a> constitute our model. The matrix <strong>A</strong> for our structured population is directly analogous to <span class="math inline">\(\lambda\)</span> for our unstructured model of discrete population growth in the previous chapter.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;A is the analog of lambda.&lt;/p&gt;"><sup>27</sup></a></p>
<p>Later, we will project the population in an analogous way, using
<span class="math display">\[\mathbf{ N_{t+1} = A N_t}\]</span>
and to do that, we need a refresher on matrix multiplication.</p>
</div>
<div id="a-brief-primer-on-matrices" class="section level2" number="4.2">
<h2>
<span class="header-section-number">4.2</span> A brief primer on matrices<a class="anchor" aria-label="anchor" href="#a-brief-primer-on-matrices"><i class="fas fa-link"></i></a>
</h2>
<p>We refer to matrices by their rows and columns. A matrix with three rows and one column is a <span class="math inline">\(3 \times 1\)</span> matrix (a “three by one” matrix); we <em>always</em> state the number of rows first. Matrices comprise <em>elements</em>; an element of a matrix is signified by its row and column. The element in the second row and first column is <span class="math inline">\(a_{21}\)</span>. The <em>dimension</em> of a matrix is its number of rows and columns.</p>
<p>To add two matrices, they must have the same dimensions. Consider two matrices, <strong>A</strong> and <strong>B</strong> . To add these two matrices we simply add the elements in the same row and column of both matrices, as below.</p>
<p><span class="math display">\[\begin{align*}
\mathbf{A} &amp;=
\left(
\begin{array}{cc}
a &amp; b \\
c &amp; d
\end{array} \right); \;
\mathbf{B} =
\left(\begin{array}{cc}
m &amp; o\\
n &amp; p
\end{array}\right)\\
\mathbf{A+B} &amp;=
\left( \begin{array}{cc}
\left( a+m \right) &amp; \left(b+o \right)\\
\left(c+n \right) &amp; \left(d+p \right)
\end{array} \right) 
\end{align*}\]</span></p>
<p>Multiplying matrices is a little more complicated. To do so, we mutliply elements and then sum them:</p>
<ul>
<li>multiply each row element of the first matrix (<strong>A</strong>) times each column element of the second matrix (<strong>B</strong>),</li>
<li>sum the element-wise products, and</li>
<li>place this sum in the respective element of the final matrix.</li>
</ul>
<p>This process is what we refer to as a <em>dot product</em> or sometimes <em>inner product</em>. When we have two vectors of equal length <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> the dot product is
<span class="math display">\[x \cdot y = x_1y_1 + x_2y_2 + \ldots + x_n y_n\]</span>
A dot product begins with two equal length vectors and returns a single number (i.e. a scalar).</p>
<p>Consider the matrix multiplication in <a href="DID.html#eq:exM">(4.2)</a>. We first multiply each element of row 1 of <strong>A</strong> (<span class="math inline">\(a\; b\)</span>), times the corresponding elements of column 1 of <strong>B</strong> (<span class="math inline">\(m\; n\)</span>), sum these products, and place the sum in the first row, first column of the resulting matrix. We then repeat this for each row of <strong>A</strong> and each column of <strong>B</strong>.</p>
<p><span class="math display" id="eq:exM">\[\begin{align}
\tag{4.2}
\mathbf{AB} &amp;=
\left( \begin{array}{cc}
\left( am + bn \right) &amp; \left(ao+bp \right)\\
\left(cm + dn \right) &amp; \left(co + dp \right)
\end{array}\right) 
\end{align}\]</span></p>
<p>To do this, the number of columns in the first matrix must equal the number of rows in the second matrix. It also means that the resulting matrix will have the same number of rows as the first matrix, and the same number of columns as the second matrix. Multiplying a <span class="math inline">\(2 \times 2\)</span> matrix by a <span class="math inline">\(2 \times 1\)</span> results in a <span class="math inline">\(2 \times 1\)</span>. Multiplying a <span class="math inline">\(3 \times 3\)</span> matrix by a <span class="math inline">\(3 \times 1\)</span> results in a <span class="math inline">\(3 \times 1\)</span>. We cannot multiply a <span class="math inline">\(2 \times 1\)</span> matrix by a <span class="math inline">\(2 \times 2\)</span> because the number of columns in the first matrix (1) does not match the number of rows in the second matrix (2).</p>
<p>Let’s define two <span class="math inline">\(2 \times 2\)</span> matrices, <strong>M</strong> and <strong>N</strong>, filling in one by rows, and the other by columns.</p>
<div class="sourceCode" id="cb102"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">M</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span> <span class="fl">1</span><span class="op">:</span><span class="fl">4</span> , nrow<span class="op">=</span><span class="fl">2</span>, byrow<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4</code></pre>
<div class="sourceCode" id="cb104"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">20</span>, <span class="fl">30</span>, <span class="fl">40</span><span class="op">)</span>, nrow<span class="op">=</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span> <span class="co"># byrow=FALSE is the default.</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]   10   30
## [2,]   20   40</code></pre>
<p>Adding these matrices is simple. Here we do the first element by hand, and then sum the matrices all at once.</p>
<div class="sourceCode" id="cb106"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># 1 + 10</span>
<span class="va">M</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">N</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span></code></pre></div>
<pre><code>## [1] 11</code></pre>
<div class="sourceCode" id="cb108"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">M</span> <span class="op">+</span> <span class="va">N</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]   11   32
## [2,]   23   44</code></pre>
<p>To mulitply <strong>M</strong> and <strong>N</strong>, we multiply and then sum the first row of <span class="math inline">\(M\)</span> by the first column of <span class="math inline">\(N\)</span>, and make this element <span class="math inline">\(a_{11}\)</span> of the resulting matrix product.</p>
<div class="sourceCode" id="cb110"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># 1*10 + 2*20</span>
<span class="va">M</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="va">N</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">M</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">*</span> <span class="va">N</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> </code></pre></div>
<pre><code>## [1] 50</code></pre>
<p>This is the dot product.</p>
<p>In R, we must use <code><a href="https://rdrr.io/r/base/matmult.html">%*%</a></code> to signify that we mean matrix multiplication.</p>
<div class="sourceCode" id="cb112"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">M</span> <span class="op">%*%</span> <span class="va">N</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]   50  110
## [2,]  110  250</code></pre>
<p>If we multiply <strong>M</strong> times a <span class="math inline">\(2 \times 1\)</span> matrix <strong>D</strong>, what should we get?</p>
<div class="sourceCode" id="cb114"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">D</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">100</span>, <span class="fl">200</span><span class="op">)</span>, nrow<span class="op">=</span><span class="fl">2</span><span class="op">)</span>
<span class="va">M</span> <span class="op">%*%</span> <span class="va">D</span></code></pre></div>
<pre><code>##      [,1]
## [1,]  500
## [2,] 1100</code></pre>
<div class="sourceCode" id="cb116"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># note that we cannot perform D %*% M</span></code></pre></div>
<p>Make sure you could write out the multiplication and summation for each element in the resulting matrix.</p>
<p>The transpose of <strong>M</strong> is the same matrix, but where we flip it along the diagonal, switching rows and columns. We use <span class="math inline">\(\mathbf{M^T}\)</span> to represent the transpose operation. In R, we use <code><a href="https://rdrr.io/r/base/t.html">t()</a></code>.</p>
<div class="sourceCode" id="cb117"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">M</span>; <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">M</span><span class="op">)</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4</code></pre>
<p>We use the transpose of <strong>A</strong> to calculate reproductive value, later in the chapter.</p>
</div>
<div id="decomposing-a" class="section level2" number="4.3">
<h2>
<span class="header-section-number">4.3</span> Decomposing <strong>A</strong><a class="anchor" aria-label="anchor" href="#decomposing-a"><i class="fas fa-link"></i></a>
</h2>
<p>A slightly different way to conceptualize our transition matrix is to consider it the three separate matrices, one each for growth, survival, and fecundity,
<span class="math display">\[\mathbf{ A = GS + F }\]</span>.</p>
<p>Survival, <strong>S</strong>, and growth, <strong>G</strong>, have these elements:</p>
<ul>
<li>each stage <span class="math inline">\(j\)</span> has its own probability of survival <span class="math inline">\(s_j\)</span>, which describes survival of each stage from <span class="math inline">\(t\)</span> to <span class="math inline">\(t+1\)</span>.</li>
<li>each survivor in stage <span class="math inline">\(j\)</span> will grow or regress into a different stage, or remain in the same stage, with probability <span class="math inline">\(g_{ij}\)</span>.</li>
</ul>
<p>In a demographic context, fecundity, <strong>F</strong>, is the surviving number of offspring produced by the average individual in stage <span class="math inline">\(i\)</span>. Sometimes this is a complete black box, in which we can only count the adults in year <span class="math inline">\(t\)</span> and the offspring in year <span class="math inline">\(t+1\)</span>. Other times, we estimate of the probability that an individual in stage <span class="math inline">\(i\)</span> reproduces at all (yes/no), as well as the average number of offspring of an individual that does actually reproduce, and the survival and growth of the adults or the resulting offspring. It all depends on the detail we have of our study system. And, of course, it depends heavily on whether we census our population shortly before reproduction (pre-breeding census), or shortly after reproduction (post-breeding census).</p>
<p>For our Western Toad (Fig. <a href="DID.html#fig:toadlh">4.2</a>), this results in
<span class="math display" id="eq:SGF">\[\begin{equation*}
\tag{4.3}
 \mathbf{A = GS + F} = 
\left(
\begin{array}{cc}
1-\mathrm{P} &amp; 0 \\
\mathrm{P} &amp; 1
\end{array} \right)
\left(
 \begin{array}{cc}
 \sigma_j&amp;0\\
0 &amp; \sigma_a
 \end{array} \right)
+
\left(
\begin{array}{cc}
0 &amp; \rho \phi \sigma_e \sigma_t \sigma_m \\
0 &amp; 0
\end{array} \right)
\end{equation*}\]</span></p>
<p>Combining these we get,
<span class="math display" id="eq:SGF">\[\begin{equation*}
\tag{4.3}
 \mathbf{A = GS + F} = 
\left(
\begin{array}{cc}
\sigma_j (1-\mathrm{P}) &amp; \rho \phi \sigma_e \sigma_t \sigma_m \\
\sigma_j \mathrm{P} &amp; \sigma_a
\end{array} \right)
\end{equation*}\]</span></p>
<p>where <span class="math inline">\(\sigma_j,\,\sigma_a\)</span> are survival of juveniles and adults, and P is the probability of juvenile maturation (“growth”), given survival. If an adult survives it always remains an adult (<span class="math inline">\(g_{22}=1\)</span>) and never regresses (<span class="math inline">\(g_{12}=0\)</span>). Fecundity occurs only in adults, and it is the product of the sex ratio (<span class="math inline">\(\rho\)</span>), average clutch size per female (<span class="math inline">\(\phi\)</span>), egg survival (<span class="math inline">\(\sigma_e\)</span>), survival of tadpoles (<span class="math inline">\(\sigma_t\)</span>), and the overwintering survival of the metamorphs (<span class="math inline">\(\sigma_m\)</span>).<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Survival, &lt;strong&gt;S&lt;/strong&gt;, is really a vector, here (&lt;span class="math inline"&gt;\(\sigma_j,\,\sigma_a\)&lt;/span&gt;). In order to multiply survivals and the growth matrix in the way we want, we need to multiply &lt;strong&gt;S&lt;/strong&gt; by the identity matrix to get what we see above.&lt;/p&gt;'><sup>28</sup></a></p>
<p>Vonesh and de la Cruz went further and added <em>density-dependence</em> using a term for the negative effects of high tadpole density on tadpole survival and growth. We do not show that here, but regardless how complex the natural history gets, we can build natural history into our models.</p>
</div>
<div id="a-three-stage-model" class="section level2" number="4.4">
<h2>
<span class="header-section-number">4.4</span> A three stage model<a class="anchor" aria-label="anchor" href="#a-three-stage-model"><i class="fas fa-link"></i></a>
</h2>
Now we describe a three-stage model of a plant population. Like our amphibian example, it is a <em>pre-breeding</em> model, relying on a pre-breeding census. Nonetheless, it includes a seed stage for the seed bank, where seeds may be more than one year old. Eleanor <span class="citation"><a href="references.html#ref-Pardini:2009aa" role="doc-biblioref">Pardini et al.</a> (<a href="references.html#ref-Pardini:2009aa" role="doc-biblioref">2009</a>)</span> and colleagues modeled garlic mustard (<em>Alliaria petiolata</em>), a biennial plant species that is an exotic invasive species in the eastern deciduous forest of the U.S. The stages they choose to represent were those present in May: seeds in the soil seed bank, 1–2 month old immature rosettes, and adults (Fig. <a href="DID.html#fig:garlic1">4.5</a>).
<div class="figure">
<span style="display:block;" id="fig:garlic1"></span>
<img src="figs/pardiniLC.png" alt="The life cycle of garlic mustard using a pre-breeding census (Pardini et al. 2009). The census takes place in May of each year. Each arrow represents the transition from May to May. Seeds germinate in early spring and become rosettes (basal leaves near the soil surface). The rosettes experience mortality all summer, fall, and winter. Surviving rosettes become reproductive adults the following spring and summer. Adults flower and are pollinated in June, after which the fruits ripen and seeds mature. Seeds overwinter for at least six months before germinating in the spring. Not all seeds germinate, but they may remain viable in the seed bank for several years. Thus, the complete life cycle at least two years. Once the seeds germinate, the plant requires over a year to reach maturity, and produce flowers, fruits and seeds. Where parameters are functions of A or R (e.g., $s_2(R,A)$), they permit the effect of adult or rosette density on those parameters. Here we do not include that density dependence." width="90%"><img src="figs/pardiniLC2.png" alt="The life cycle of garlic mustard using a pre-breeding census (Pardini et al. 2009). The census takes place in May of each year. Each arrow represents the transition from May to May. Seeds germinate in early spring and become rosettes (basal leaves near the soil surface). The rosettes experience mortality all summer, fall, and winter. Surviving rosettes become reproductive adults the following spring and summer. Adults flower and are pollinated in June, after which the fruits ripen and seeds mature. Seeds overwinter for at least six months before germinating in the spring. Not all seeds germinate, but they may remain viable in the seed bank for several years. Thus, the complete life cycle at least two years. Once the seeds germinate, the plant requires over a year to reach maturity, and produce flowers, fruits and seeds. Where parameters are functions of A or R (e.g., $s_2(R,A)$), they permit the effect of adult or rosette density on those parameters. Here we do not include that density dependence." width="90%"><p class="caption">
Figure 4.5: The life cycle of garlic mustard using a pre-breeding census (Pardini et al. 2009). The census takes place in May of each year. Each arrow represents the transition from May to May. Seeds germinate in early spring and become rosettes (basal leaves near the soil surface). The rosettes experience mortality all summer, fall, and winter. Surviving rosettes become reproductive adults the following spring and summer. Adults flower and are pollinated in June, after which the fruits ripen and seeds mature. Seeds overwinter for at least six months before germinating in the spring. Not all seeds germinate, but they may remain viable in the seed bank for several years. Thus, the complete life cycle at least two years. Once the seeds germinate, the plant requires over a year to reach maturity, and produce flowers, fruits and seeds. Where parameters are functions of A or R (e.g., <span class="math inline">\(s_2(R,A)\)</span>), they permit the effect of adult or rosette density on those parameters. Here we do not include that density dependence.
</p>
</div>
<p>Let’s work through these probability transitions.</p>
<ul>
<li>
<span class="math inline">\(s_1\)</span>, a germinated seed survives as a rosette.</li>
<li>
<span class="math inline">\(s_2\)</span>, surviving from May to August as a rosette.</li>
<li>
<span class="math inline">\(s_3\)</span>, surviving from August to early May and becoming a reproductive plant.</li>
<li>
<span class="math inline">\(v\)</span>, a seed is viable (survives and can germinate).</li>
<li>
<span class="math inline">\(g_1\)</span>, a viable seed germinates in the first season, or <span class="math inline">\(1-g_1\)</span> remains ungerminated.</li>
<li>
<span class="math inline">\(g_2\)</span>, a viable seed germinates in the second season or <span class="math inline">\(1-g_2\)</span> does not.</li>
</ul>
<p>Fecundity, <span class="math inline">\(f\)</span>, is the average number of seeds per reproductive plant.</p>
<p>The transition matrix <strong>A</strong> would thus be</p>
<p><span class="math display" id="eq:pardini">\[\begin{equation*}
\tag{4.4}
 \mathbf{A} = 
\left(
\begin{array}{ccc}
 1-g_2  &amp; 0       &amp; v(1-g_1)f \\
g_2 s_1 &amp; 0       &amp; v g_1 s_1 f \\
0       &amp; s_2 s_3 &amp; 0
\end{array} \right)
\end{equation*}\]</span></p>
<p>Put into your own words each of the transition elements.</p>
<p>What about the transition from adult to rosette? Did the plant shrink? While perennial plants can get smaller, or <em>regress</em>, that is not what happens here. In this transition, the adult in May gets pollinated, develops fruits, the seeds mature and are deposited on the soil late that summer or fall. Those seeds are survive overwinter, germinate in early spring, and grow into rosettes in April, and survive until the census in that May. Thus, stage 3 (adult) contributes to stage 2 (rosette) through reproduction plus survival and germination of the seeds and growth and survival of the young rosette. The transition from adult to seed, <span class="math inline">\(p_{13}\)</span>, occurs only when the seeds do not germinate after the first winter, but spend another year in the seed bank in the soil.</p>
<p>Once we have the transition matrix, we can use it to characterize many features of the population, including the finite rate of increase (<span class="math inline">\(\lambda\)</span>), the predicted relative abundances of the various stages, and the relative importance of each separate transition <span class="math inline">\(p_{ij}\)</span> for the long term population growth rate. We will do this in a later section, but first will explore projection. It is frequently useful to acutally project the population, one year at a time, into the future.</p>
</div>
<div id="projection" class="section level2" number="4.5">
<h2>
<span class="header-section-number">4.5</span> Projection<a class="anchor" aria-label="anchor" href="#projection"><i class="fas fa-link"></i></a>
</h2>
<p><em>Projection</em> is the modeling of a population through time, for prediction under one or another set of assumptions. In practice, we use <em>matrix multiplication</em> to project stage- or age-structured populations. Matrix multiplication does all these calculations for us. We let <strong>A</strong> be our square demographic transition matrix, with one row and one column for each stage. Let <span class="math inline">\(\mathbf{N}_t\)</span> be a one-column matrix of stage sizes, with one row for each stage. Matrix multiplication allows us to project the population,
<span class="math inline">\(\mathbf{A}\mathbf{N}_t = \mathbf{N}_{t+1}\)</span>.</p>
<p>To project a population for multiple years, we use a <em>for-loop</em>. We used this in the previous chapter for an unstructured population. Here we multiply our transition matrix by the current year’s abundances projecting next year’s abundances. All we need to specify are the transition matrix, starting stage abundances for <span class="math inline">\(t=0\)</span>, and the number of years through which we want to project. Here we define a transition matrix, <span class="math inline">\(\mathbf{N}_0\)</span>, and the number of time steps to project.</p>
<div class="sourceCode" id="cb120"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">.1</span>, <span class="fl">2.0</span>, 
        <span class="fl">.3</span>,<span class="fl">.4</span><span class="op">)</span>, nrow<span class="op">=</span><span class="fl">2</span>, byrow<span class="op">=</span><span class="cn">T</span><span class="op">)</span>
<span class="va">N0</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">100</span>, <span class="fl">1</span><span class="op">)</span>, nrow<span class="op">=</span><span class="fl">1</span><span class="op">)</span> 
<span class="va">years</span> <span class="op">&lt;-</span> <span class="fl">6</span></code></pre></div>
<p>To do the for-loop, we need a zero matrix to hold <span class="math inline">\(n\)</span> for each of the years of each of the stages, including for our first year. We start by filling our matrix with zeros and “binding” the rows in <span class="math inline">\(\mathbf{N}_0\)</span> onto the top of our zeroes matrix as the first row.</p>
<div class="sourceCode" id="cb121"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">N.proj1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span> <span class="fl">0</span>, nrow<span class="op">=</span><span class="va">years</span>, ncol<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">A</span><span class="op">)</span><span class="op">)</span> 
<span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">N.proj1</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Juv"</span>, <span class="st">"Adult"</span><span class="op">)</span>
<span class="va">N.proj2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">N0</span>, <span class="va">N.proj1</span><span class="op">)</span></code></pre></div>
<p>Now we perform the iteration with the for-loop and plot the result. Note how we do the multiplication for the current year <span class="math inline">\(t\)</span> and put the result in the next year <span class="math inline">\(t+1\)</span>.</p>
<div class="sourceCode" id="cb122"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Project, then...</span>
<span class="kw">for</span><span class="op">(</span><span class="va">t</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">years</span><span class="op">)</span> <span class="op">{</span><span class="va">N.proj2</span><span class="op">[</span><span class="va">t</span><span class="op">+</span><span class="fl">1</span>,<span class="op">]</span> <span class="op">&lt;-</span> <span class="va">A</span><span class="op">%*%</span><span class="va">N.proj2</span><span class="op">[</span><span class="va">t</span>,<span class="op">]</span><span class="op">}</span>
<span class="co"># ...rearrange and plot</span>
<span class="va">N.proj.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>Year<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="va">years</span>, <span class="va">N.proj2</span><span class="op">)</span>
<span class="va">npd</span> <span class="op">&lt;-</span> <span class="fu">gather</span><span class="op">(</span><span class="va">N.proj.data</span>, <span class="va">Stage</span>, <span class="va">Abundance</span>, <span class="op">-</span><span class="va">Year</span><span class="op">)</span>
<span class="fu">ggplot</span><span class="op">(</span><span class="va">npd</span>, <span class="fu">aes</span><span class="op">(</span><span class="va">Year</span>, <span class="va">Abundance</span>, linetype<span class="op">=</span><span class="va">Stage</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="fu">geom_line</span><span class="op">(</span><span class="op">)</span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:projmat"></span>
<img src="figs/projmat-1.png" alt="Projection of a population showing transient dynamics." width="90%"><p class="caption">
Figure 4.6: Projection of a population showing transient dynamics.
</p>
</div>
<p>In the first seven years, we see the abundances of the two stages bounce around. These are <em>transient</em> dynamics that, in our density-independent models, will fade away over time.</p>
</div>
<div id="analyzing-the-transition-matrix" class="section level2" number="4.6">
<h2>
<span class="header-section-number">4.6</span> Analyzing the transition matrix<a class="anchor" aria-label="anchor" href="#analyzing-the-transition-matrix"><i class="fas fa-link"></i></a>
</h2>
<p>Projection is very important for many reasons, especially for stochastic models or for very complicated models. However, we also get some of our best insights through direct analysis the transition matrix using <em>eigenanalysis</em> <span class="citation">(<a href="references.html#ref-Caswell:2001gu" role="doc-biblioref">Caswell 2001</a>)</span>.</p>
<p>The eigenanalysis of a population matrix can tell us about predictions, attractors, short term dynamics or long term averages, assuming that the transition elements don’t change. This is a big assumption, but understanding it helps us interpret the analysis appropriately.</p>
<p>Once you have obtained the transition matrix, <span class="math inline">\(\mathbf{A}\)</span>, we can analysis it using <em>eigenanalysis</em> to estimate</p>
<ul>
<li>
<span class="math inline">\(\lambda\)</span>, the finite rate of increase,</li>
<li>stable stage structure,</li>
<li>reproductive value, and</li>
<li>sensitivities and elasticities.</li>
</ul>
<p>Below, we explain each of these quantities.</p>
<div id="eigenanalysis" class="section level3" number="4.6.1">
<h3>
<span class="header-section-number">4.6.1</span> Eigenanalysis<a class="anchor" aria-label="anchor" href="#eigenanalysis"><i class="fas fa-link"></i></a>
</h3>
<p>Eigenanalysis is a mathematical technique that summarizes multivariate data. Ecologists use eigenanalysis frequently, for (i) multivariate statistics such as ordination, (ii) local stability analyses with two or more species, and (iii) analyzing population transition matrices. Eigenanalysis is simply a method to transform a square matrix into independent, or orthogonal, pieces. These pieces are <em>eigenvectors</em> and their corresponding <em>eigenvalues.</em> There are the same number of eigenvalues (and eigenvectors) as there are columns in a matrix. In demography, the two of the most useful pieces are the <em>dominant right eigenvalue</em> and its <em>corresponding right eigenvector</em>.</p>
<p>Eigenanalysis is a technique that finds all the solutions for <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(\mathbf{w}\)</span> of
<span class="math display" id="eq:eigsol">\[
\tag{4.5}
\mathbf{Aw}=\lambda \mathbf{w}
\]</span></p>
<p>where <span class="math inline">\(\mathbf{w}\)</span> is a column vector with the same number of rows as <span class="math inline">\(\mathbf{A}\)</span>. If we write out eq. <a href="DID.html#eq:eigsol">(4.5)</a> for a <span class="math inline">\(2 \times 2\)</span> matrix, we would have</p>
<p><span class="math display" id="eq:eigsollong">\[
 \tag{4.6}
 \left(
 \begin{array}{ccc}
  a_{11} &amp; a_{12} \\
  a_{21} &amp; a_{22}\\
 \end{array} 
 \right) 
 \left(
  \begin{array}[c]{c}
   w_{11}\\
   w_{21}
  \end{array}
  \right)
  =\lambda \left(
  \begin{array}[c]{c}
   w_{11}\\
   w_{21}
  \end{array}
  \right)
\]</span>
For instance, we can perform eigenanalysis on this transition matrix.</p>
<div class="sourceCode" id="cb123"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">.3</span>, <span class="fl">2</span>, <span class="fl">.7</span><span class="op">)</span>, nrow<span class="op">=</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]  0.0  2.0
## [2,]  0.3  0.7</code></pre>
<div class="sourceCode" id="cb125"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">eA</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/eigen.html">eigen</a></span><span class="op">(</span><span class="va">A</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## eigen() decomposition
## $values
## [1]  1.2 -0.5
## 
## $vectors
##            [,1]       [,2]
## [1,] -0.8574929 -0.9701425
## [2,] -0.5144958  0.2425356</code></pre>
<p>This gives us one eigenvalue per column of our transition matrix (<code>values</code>). Each eigenvalue has a <em>corresponding eigenvector</em> that is the corresponding column of the <code>vectors</code> matrix.</p>
<p>Let’s use R to prove to ourselves that eq. <a href="DID.html#eq:eigsol">(4.5)</a> is what we say it is. Here we see for ourselves whether <span class="math inline">\(\mathbf{A}\mathbf{w} = \lambda \mathbf{w}\)</span> for
<span class="math inline">\(i = 1\)</span>. Below, we use the results of the previous eigenanalysis.</p>
<div class="sourceCode" id="cb127"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">lambda1</span> <span class="op">&lt;-</span> <span class="va">eA</span><span class="op">$</span><span class="va">values</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 1.2</code></pre>
<div class="sourceCode" id="cb129"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">w1</span> <span class="op">&lt;-</span> <span class="va">eA</span><span class="op">$</span><span class="va">vectors</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] -0.8574929 -0.5144958</code></pre>
<div class="sourceCode" id="cb131"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">A</span> <span class="op">%*%</span> <span class="va">w1</span>, lambda.w<span class="op">=</span><span class="va">lambda1</span> <span class="op">*</span> <span class="va">w1</span><span class="op">)</span></code></pre></div>
<pre><code>##                   lambda.w
## [1,] -1.0289915 -1.0289915
## [2,] -0.6173949 -0.6173949</code></pre>
<p>The first column is <span class="math inline">\(\mathbf{Aw}\)</span> and the second column is <span class="math inline">\(\lambda \mathbf{w}\)</span>. Sure enough, they look the same. Try doing the same exercise for the second eigenvalue and the second eigenvector, <span class="math inline">\(i=2\)</span>.</p>
<p>Typically, the first eigenvalue and its corresponding eigenvector capture the most important features of the transition matrix. We call these the dominant eigenvalue, <span class="math inline">\(\lambda_1\)</span>, and its corresponding eigenvector, <span class="math inline">\(w_1\)</span>. While first solution does not capture all of the information about our transition matrix, it is the most useful.</p>
<p>There are an infinite number of solutions to this equation because solutions can just be simple multiples of the set found with eigenanalysis. Eigenanalysis finds a set in which the solutions are all independent of each other, and which capture all of the information in <span class="math inline">\(\mathbf{A}\)</span> in a particularly useful way.</p>
<p>In this book, we will not delve into details of eigenanalysis beyond this. Here are some eigenanalysis takeaways:</p>
<ul>
<li>you can perform eigenanalysis only on square matrices (number of rows = number of columns).</li>
<li>there are the same number of eigenvalues of <strong>A</strong> as there are columns of <strong>A</strong>.</li>
<li>eigenvalues are usually complex numbers, having a real part and an imaginary part.</li>
<li>the largest eigenvalue is the one with the largest geometric mean of the real and the imaginary parts with the sign (+,-) respected.</li>
<li>the “dominant” eigenvalue is the largest one; R will return this as the first one.</li>
<li>each eigenvalue has a corresponding eigenvector.</li>
<li>the number of elements in each eigenvector is the same as the number of rows in <strong>A</strong>.</li>
</ul>
<p>What is important for us is how we use the results. Below, we describe how we use eigenanalysis to find (i) the long term asymptotic finite rate of increase <span class="math inline">\(\lambda\)</span>, (ii) the <em>stable stage distribution</em>, and the <em>reproductive values</em> of each stage.</p>
</div>
<div id="finite-rate-of-increase" class="section level3" number="4.6.2">
<h3>
<span class="header-section-number">4.6.2</span> Finite rate of increase<a class="anchor" aria-label="anchor" href="#finite-rate-of-increase"><i class="fas fa-link"></i></a>
</h3>
<p>The asymptotic annual growth rate or finite rate of increase is the dominant eigenvalue of the transition matrix. It has the same meaning as in geometric growth of an unstructured population.</p>
<p>Eigenvalues are always referred to with the Greek symbol <span class="math inline">\(\lambda\)</span>, and provide a solution to <a href="DID.html#eq:eigsol">(4.5)</a>. The dominant eigenvalue of any matrix, <span class="math inline">\(\lambda_{1}\)</span>, is the eigenvalue with the largest magnitude, and it is frequently a complex number. When we perform eigenanalysis, it is common to get complex numbers, with real and imaginary parts. The magnitude is the sum of the squared parts. With population transition matrices, <span class="math inline">\(\lambda_{1}\)</span> will always be positive and real. This will not be the case with other types of matrices we examine in later chapters.</p>
<p>The dominant eigenvalue is the biggest one. We can find which one it is by asking R to tell us the index position <span class="math inline">\(i\)</span> of the largest absolute value (the modulus) of the eigenvalues. In most cases, it is the first eigenvalue, as it is here.</p>
<div class="sourceCode" id="cb133"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span> <span class="va">dom.pos</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/which.min.html">which.max</a></span><span class="op">(</span> <span class="fu"><a href="https://rdrr.io/r/base/complex.html">Mod</a></span><span class="op">(</span><span class="va">eA</span><span class="op">[[</span><span class="st">"values"</span><span class="op">]</span><span class="op">]</span><span class="op">)</span> <span class="op">)</span>  <span class="op">)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>We use that index to extract the largest eigenvalue. We keep the real part, using <code><a href="https://rdrr.io/r/base/complex.html">Re()</a></code>, dropping the imaginary part. (Note that although the dominant eigenvalue of a real transition matrix will always be real, R will include an imaginary part equal to zero (<span class="math inline">\(0i\)</span>) as a place holder if any of the eigenvalues has a non-zero imaginary part).</p>
<div class="sourceCode" id="cb135"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># extract the dominant eigenvalue and retain only its Real part</span>
<span class="op">(</span> <span class="va">L1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/complex.html">Re</a></span><span class="op">(</span><span class="va">eA</span><span class="op">[[</span><span class="st">"values"</span><span class="op">]</span><span class="op">]</span><span class="op">[</span><span class="va">dom.pos</span><span class="op">]</span><span class="op">)</span> <span class="op">)</span></code></pre></div>
<pre><code>## [1] 1.2</code></pre>
<p><code>L1</code> is <span class="math inline">\(\lambda_1\)</span>, the asymptotic finite rate of increase. This finite rate of increase has the same biological meaning as <span class="math inline">\(\lambda\)</span> in the previous chapter.</p>
</div>
<div id="stable-stage-distribution" class="section level3" number="4.6.3">
<h3>
<span class="header-section-number">4.6.3</span> Stable stage distribution<a class="anchor" aria-label="anchor" href="#stable-stage-distribution"><i class="fas fa-link"></i></a>
</h3>
<p>The predicted long term average relative abundance of the different life history stages or ages is called the <em>stage distribution</em>, that is, the distribution of individuals among the stages. A property of a stage structured population is that, if all the demographic rates (elements of the transition matrix) remain constant, its stage structure will approach a <em>stable</em> stage distribution, a stage distribution in which the relative number of individuals in each stage is constant. Note that a population can grow, so that the absolute number of individuals increases, but the relative abundances of the stages is constant; this is the stable stage distribution. If the population is not actually growing (i.e. <span class="math inline">\(\lambda=1\)</span>) and demographic parameters remain constant, then the population is <em>stationary</em> and will achieve a <em>stationary stage distribution</em>, where neither absolute nor relative abundances change.</p>
<p>How do we find the stable stage distribution? It also turns out that <span class="math inline">\(w_1\)</span> provides the necessary information. We scale the eigenvector <span class="math inline">\(w_1\)</span> by the sum of its elements because we are interested in the <em>distribution</em>, which is defined by all stages summing to one. Therefore the stable stage distribution is
<span class="math display" id="eq:ssd">\[
 \tag{4.7}
 \frac{w_1}{\sum_{i=1}^s{w_1}}
\]</span>
where <span class="math inline">\(s\)</span> is the number of stages.</p>
<p>Once a population reaches its stable stage distribution each of the stages grows or shrinks exponentially. You might believe that if you consider that we can represent <span class="math inline">\(\mathbf{A}\)</span> with <span class="math inline">\(\lambda\)</span>.</p>
</div>
<div id="calculating-the-stable-stage-distribution" class="section level3" number="4.6.4">
<h3>
<span class="header-section-number">4.6.4</span> Calculating the stable stage distribution<a class="anchor" aria-label="anchor" href="#calculating-the-stable-stage-distribution"><i class="fas fa-link"></i></a>
</h3>
<p>The dominant eigenvector, <span class="math inline">\(w_1\)</span>, is in the same position as the dominant eigenvalue. We extract <span class="math inline">\(w_1\)</span>, keeping just the real part, and divide it by its sum to get the stable stage distribution.</p>
<div class="sourceCode" id="cb137"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># continuing from previous code...</span>
<span class="va">w1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/complex.html">Re</a></span><span class="op">(</span><span class="va">eA</span><span class="op">[[</span><span class="st">"vectors"</span><span class="op">]</span><span class="op">]</span><span class="op">[</span>,<span class="va">dom.pos</span><span class="op">]</span><span class="op">)</span>
<span class="va">ssd</span> <span class="op">&lt;-</span> <span class="va">w1</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">w1</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">ssd</span>, <span class="fl">3</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 0.625 0.375</code></pre>
<p>This shows us that if the transition matrix does not change over time, the population will eventually be composed of these relative abundances.</p>
<p>We have claimed, without evidence, that with a constant transition matrix, the projected population will eventually reach a stable stage distribution and grow exponentially with a finite rate of increase of <span class="math inline">\(\lambda_1\)</span>. Here we show an example.</p>
<div class="sourceCode" id="cb139"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">.3</span>, <span class="fl">2</span>, <span class="fl">.7</span><span class="op">)</span>, nrow<span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="co"># our tran. matrix</span>
<span class="va">N0</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>Juveniles<span class="op">=</span><span class="fl">1</span>,Adults<span class="op">=</span><span class="fl">10</span><span class="op">)</span> <span class="co"># initial population</span>
<span class="va">steps</span> <span class="op">&lt;-</span> <span class="fl">8</span> <span class="co"># number of time steps</span>
<span class="co"># combine the stages of our initial population, and a zero matrix </span>
<span class="co"># with a column for each stage and a row for each time step</span>
<span class="va">N</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">N0</span>, <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>, ncol<span class="op">=</span><span class="fl">2</span>, nrow<span class="op">=</span><span class="va">steps</span><span class="op">)</span> <span class="op">)</span>
<span class="co"># use a for-loop to project the population each year and store it.</span>
<span class="kw">for</span><span class="op">(</span><span class="va">t</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">steps</span><span class="op">)</span> <span class="op">{</span><span class="va">N</span><span class="op">[</span><span class="va">t</span><span class="op">+</span><span class="fl">1</span>,<span class="op">]</span> <span class="op">&lt;-</span> <span class="va">A</span><span class="op">%*%</span><span class="va">N</span><span class="op">[</span><span class="va">t</span>,<span class="op">]</span><span class="op">}</span>
<span class="co"># Sum the stages to get the total N</span>
<span class="va">N.total</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowSums</a></span><span class="op">(</span><span class="va">N</span><span class="op">)</span>
<span class="co"># For each year, divide each stage by the total to get </span>
<span class="co"># relative abundances and thus the distribution.</span>
<span class="va">proportions</span> <span class="op">&lt;-</span> <span class="va">N</span><span class="op">/</span><span class="va">N.total</span>
<span class="va">SD</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>Year<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="va">steps</span>, <span class="va">proportions</span><span class="op">)</span>
<span class="va">sdg</span> <span class="op">&lt;-</span> <span class="fu">gather</span><span class="op">(</span><span class="va">SD</span>, <span class="va">Stage</span>, <span class="va">Proportion</span>, <span class="op">-</span><span class="va">Year</span><span class="op">)</span>

<span class="co"># plot the distributions for succeeding years.</span>
<span class="fu">ggplot</span><span class="op">(</span><span class="va">sdg</span>, <span class="fu">aes</span><span class="op">(</span><span class="va">Stage</span>, <span class="va">Proportion</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="fu">geom_col</span><span class="op">(</span><span class="op">)</span>  <span class="op">+</span> 
  <span class="fu">facet_wrap</span><span class="op">(</span><span class="op">~</span><span class="va">Year</span>, nrow<span class="op">=</span><span class="fl">3</span>, ncol<span class="op">=</span><span class="fl">3</span><span class="op">)</span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:poweriter"></span>
<img src="figs/poweriter-1.png" alt="Dynamics over nine times steps, of relative abundances in a poplation with two stages. When we project a hypothetical population with a constant transition matrix, it will reach asymptotically the stable stage distribution. The $y$-axis is the projected relative abundance of the two stages." width="90%"><p class="caption">
Figure 4.7: Dynamics over nine times steps, of relative abundances in a poplation with two stages. When we project a hypothetical population with a constant transition matrix, it will reach asymptotically the stable stage distribution. The <span class="math inline">\(y\)</span>-axis is the projected relative abundance of the two stages.
</p>
</div>
<p>If we sum the abundances of the different stages, we calculate total population sizes. With that, we can calculate an annual rate of increase <span class="math inline">\(N_{t+1}/N_t\)</span>.</p>
<div class="sourceCode" id="cb140"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># using "-" in an index removes that element</span>
<span class="co">## N.total[-1] is the entire vector N.total EXCEPT the first element</span>
<span class="co">## N.total[-(steps+1)] is the entire vector N.total EXCEPT the last element</span>
<span class="va">lambda.t</span> <span class="op">&lt;-</span> <span class="va">N.total</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">/</span><span class="va">N.total</span><span class="op">[</span><span class="op">-</span><span class="op">(</span><span class="va">steps</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">]</span> 
<span class="fu">qplot</span><span class="op">(</span>x<span class="op">=</span><span class="fl">1</span><span class="op">:</span><span class="va">steps</span>, y<span class="op">=</span><span class="va">lambda.t</span>, geom<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"line"</span>, <span class="st">"point"</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> 
  <span class="fu">annotate</span><span class="op">(</span><span class="st">"point"</span>, x <span class="op">=</span> <span class="va">steps</span>  , y<span class="op">=</span><span class="va">L1</span>, pch<span class="op">=</span><span class="fl">1</span>, size<span class="op">=</span><span class="fl">3</span><span class="op">)</span> </code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:unnamed-chunk-42"></span>
<img src="figs/unnamed-chunk-42-1.png" alt="Calculating an annual finite rate of increase from a projected population shows that the population will approach asymptotically a constant geometric rate of increase. Solid points are annual growth rate; the circular point is lambda(1) from eigenanalysis." width="90%"><p class="caption">
Figure 4.8: Calculating an annual finite rate of increase from a projected population shows that the population will approach asymptotically a constant geometric rate of increase. Solid points are annual growth rate; the circular point is lambda(1) from eigenanalysis.
</p>
</div>
<p>Iterating the transition matrix to approximate <span class="math inline">\(\lambda_1\)</span> and <span class="math inline">\(w_1\)</span> is actually called the <em>power iteration method</em> for eigenanalysis.</p>
</div>
<div id="reproductive-value" class="section level3" number="4.6.5">
<h3>
<span class="header-section-number">4.6.5</span> Reproductive value<a class="anchor" aria-label="anchor" href="#reproductive-value"><i class="fas fa-link"></i></a>
</h3>
<p>
If the stage structure gives us one measure of the importance of a stage (its relative abundance), then the <em>reproductive value</em> gives us one measure of the importance of an <em>individual</em> in each stage. Reproductive value is the expected contribution of each individual to future reproduction. We characterize all individuals in a stage using the same expected reproductive value.</p>
<p>We calculate the reproductive value associated with each stage by solving for the dominant <em>left</em> eigenvector <span class="math inline">\(\mathbf{v}\)</span>, where
<span class="math display" id="eq:rv">\[
 \tag{4.8}
 \mathbf{vA}=\lambda\mathbf{v}.
\]</span>
Like the relation between the dominant right eigenvector and the stable stage distribution, this vector is actually <em>proportional</em> to the reproductive values. Unlike the stable stage distribution, we scale it so that all reproductive values are relative to that of the first stage (e.g. juveniles or seeds).
<span class="math display" id="eq:rv2">\[
 \tag{4.9}
  \frac{v_1}{v_{1[1]}}
\]</span>
We find the left eigenvalues and -vectors by performing eigenanalysis on the <em>transpose</em> of the transition matrix. Transposition flips rows and columns, so that row 1 becomes column 1 and vice versa. We perform eigenanalysis, extracting just the dominant left eigenvector; we then scale it, so the stage 1 has a reproductive value of 1.</p>
<div class="sourceCode" id="cb141"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">tA</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">A</span><span class="op">)</span> <span class="co"># transpose</span>
<span class="va">etA</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/eigen.html">eigen</a></span><span class="op">(</span><span class="va">tA</span><span class="op">)</span>
<span class="va">dom.pos</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/which.min.html">which.max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/complex.html">Mod</a></span><span class="op">(</span><span class="va">etA</span><span class="op">$</span><span class="va">values</span><span class="op">)</span><span class="op">)</span>
<span class="va">v1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/complex.html">Re</a></span><span class="op">(</span><span class="va">etA</span><span class="op">$</span><span class="va">vectors</span><span class="op">[</span>,<span class="va">dom.pos</span><span class="op">]</span><span class="op">)</span>
<span class="op">(</span> <span class="va">rv</span> <span class="op">&lt;-</span> <span class="va">v1</span><span class="op">/</span><span class="va">v1</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">)</span></code></pre></div>
<pre><code>## [1] 1 4</code></pre>
<p>Here we see that reproductive value, <code>rv</code>, increases with age or stage. This means that the expected reproductive value of an individual in the second stage is <code>4</code> times as great as that of an individual in the first stage. In general, reproductive value of individuals in a stage increases with increasing probability of reaching fecund stages.</p>
</div>
<div id="sensitivity-and-elasticity" class="section level3" number="4.6.6">
<h3>
<span class="header-section-number">4.6.6</span> Sensitivity and elasticity<a class="anchor" aria-label="anchor" href="#sensitivity-and-elasticity"><i class="fas fa-link"></i></a>
</h3>
<p>Sensitivity and elasticity tell us the relative importance of each transition (i.e. each arrow of the life cycle graph or element of the matrix) in determining <span class="math inline">\(\lambda\)</span>. They do so by combining information on the stable stage structure and reproductive values.</p>
<p>The stage structure and reproductive values each in their own way contribute to the importance of each stage in determining <span class="math inline">\(\lambda\)</span>. The stable stage distribution provides the relative abundance of individuals in each stage. Reproductive value provides the expected contribution to future population growth of individuals in each stage. Sensitivity and elasticity combine these to tell us the relative importance of each transition in determining <span class="math inline">\(\lambda_1\)</span>.</p>
<p>Sensitivities are the direct contributions of each transition to determining <span class="math inline">\(\lambda_1\)</span>. The sensitivity for the element <span class="math inline">\(a_{ij}\)</span> of a transition matrix is the change in <span class="math inline">\(\lambda_1\)</span> that occurs when we change <span class="math inline">\(a_{ij}\)</span> a small amount, or
<span class="math display">\[\delta \lambda / \delta a_{ij}\]</span>.
It isn’t surprising, then, these are derived from the stable stage distribution and the reproductive values. Specifically, the sensitivities are calculated as</p>
<p><span class="math display" id="eq:sens">\[
\frac{\delta \lambda}{\delta a_{ij}}=\frac{v_{1[i]}w_{1[j]}}{v_1\cdot w_1} 
\tag{4.10}
\]</span>
where <span class="math inline">\(v_{i}w_{j}\)</span> is the product of each pairwise combination of elements of the dominant left and right eigenvectors, <span class="math inline">\(v\)</span> and <span class="math inline">\(w\)</span>. Specifically, the numerator is generated by the reproductive value of the target stage and the stable stage distribution of the source stage,
<span class="math display">\[
\begin{pmatrix} v_1\\v_2 \end{pmatrix} \begin{pmatrix} w_1 &amp; w_2 \end{pmatrix}=
\begin{pmatrix} 
v_1 w_1 &amp; v_1 w_2 \\
v_2 w_1 &amp; v_2 w_2
\end{pmatrix}
\]</span>
In the denominator, the <em>dot product</em>, <span class="math inline">\(\mathbf{v} \cdot \mathbf{w}\)</span>, is the sum of the pairwise products of each vector element,
<span class="math display">\[v_{11}w_{11} + v_{12}w_{12} + \ldots + v_{1n}w_{1n}\]</span>.
Dividing the numerator by this sum causes the sensitivities to be relative to the magnitudes of <span class="math inline">\(v\)</span> and <span class="math inline">\(w\)</span>.</p>
<p>Let’s calculate sensitivities now. Because the stable stage distribution and the reproductive values are merely scaled versions of the dominant right and left eigenvectors, it doesn’t matter whether we use the unscaled eigenvectors, or the scaled stable stage distribution and reproductive values.</p>
<div class="sourceCode" id="cb143"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">vw</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="va">rv</span>, nr<span class="op">=</span><span class="fl">2</span>, nc<span class="op">=</span><span class="fl">1</span><span class="op">)</span> <span class="op">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="va">ssd</span>, nr<span class="op">=</span><span class="fl">1</span>, nc<span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="co"># or vw &lt;- v1 %*% t(w1); the numerator</span>
<span class="va">dot.prod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">rv</span><span class="op">*</span><span class="va">ssd</span><span class="op">)</span> <span class="co"># or dot.prod &lt;- sum(v1 * w1) denominator</span>
<span class="op">(</span><span class="va">s</span> <span class="op">&lt;-</span> <span class="va">vw</span><span class="op">/</span><span class="va">dot.prod</span><span class="op">)</span></code></pre></div>
<pre><code>##           [,1]      [,2]
## [1,] 0.2941176 0.1764706
## [2,] 1.1764706 0.7058824</code></pre>
<p>These are the sensitivities, <span class="math inline">\(\delta \lambda / \delta a_{ij}\)</span>, of each corresponding transition element. You will always get a sensitivity for every position in this matrix, even when the transition is zero, <span class="math inline">\(a_{ij}=0\)</span>. We just ignore those, but by convention, usually include them.
These sensitivities are the relative change in <span class="math inline">\(\lambda_1\)</span> for an absolute change in the element. For instance, it is the relative effect on lambda of increasing <span class="math inline">\(a_{21}\)</span> from 0.3 to 0.31, or <span class="math inline">\(a_{22}\)</span> from 0.7 to 0.71.</p>
<p>The largest of the sensitivities we just calculated is that for <span class="math inline">\(p_{21}\)</span>, surviving from the first stage to the second stage. This means that small changes to <span class="math inline">\(p_{21}\)</span> have larger effects on <span class="math inline">\(\lambda_1\)</span> than do small changes to <span class="math inline">\(F_2\)</span> or <span class="math inline">\(p_{22}\)</span>.</p>
As <span class="math inline">\(\delta \lambda / \delta a_{ij}\)</span>, the sensitivities are the slope of the line relating the magnitude of <span class="math inline">\(\lambda_1\)</span> to the matrix element.
<div class="figure">
<span style="display:block;" id="fig:unnamed-chunk-45"></span>
<img src="figs/unnamed-chunk-45-1.png" alt="Sensitivities of lambda to transition elements are slopes. The dotted line is the calculated sensitivity of lambda to A[2,1], because it is the slope evaluated at A[2,1]." width="75%"><p class="caption">
Figure 4.9: Sensitivities of lambda to transition elements are slopes. The dotted line is the calculated sensitivity of lambda to A[2,1], because it is the slope evaluated at A[2,1].
</p>
</div>
<p><strong>Elasticities</strong> are sensitivities that have been weighted by the transition probabilities. Recall that sensitivities are the effects on lambda of a small absolute change in transition matrix elements. In contrast, elasticities are the effects on lambda of a <em>proportional</em> change in a transition element influences <span class="math inline">\(\lambda_1\)</span>—how does a 1% increase in seed production, or a 1% decline in juvenile survival influence <span class="math inline">\(\lambda_1\)</span>? For these answers, we need to adjust sensitivities to account for the relative magnitudes of the transition elements, and this provides the elasticities, <span class="math inline">\(e_{ij}\)</span>. Elasticities are <em>relative sensitivities</em>, and are defined as</p>
<p><span class="math display">\[
e_{ij}=\frac{\delta \lambda/\lambda}{\delta a_{ij}/a_{ij}} = \frac{a_{ij}}{\lambda}\frac{\delta \lambda}{\delta a_{ij}}.
\]</span>
These are also equal to
<span class="math display">\[e_{ij}= \frac{\delta \log \lambda}{\delta \log a_{ij}}.\]</span>
Like sensitivities, we can think of elasticities as slopes.</p>
<p>Calculating these in R is easy.</p>
<div class="sourceCode" id="cb145"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">e</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">A</span><span class="op">/</span><span class="va">L1</span><span class="op">)</span> <span class="op">*</span> <span class="va">s</span>
<span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">e</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>##       [,1]  [,2]
## [1,] 0.000 0.294
## [2,] 0.294 0.412</code></pre>
<p>Now we see that survival by adults (<span class="math inline">\(p_{22}\)</span>) has the biggest effect on <span class="math inline">\(\lambda_1\)</span>. Why the difference between sensitivities and elasticities? Because the elasticities reflect the effect of a <em>proportional change</em> (e.g., 1%) of the elements, whereas sensitivities reflect the effect of a change by a constant amount (e.g., 0.01) of each element.</p>
<p>Note that elasticities are relative to each other, in that they sum to 1. This is an especially nice feature of elasticities because it makes it easier to compare elasticities among different matrices and different organisms.</p>
<p>Once we have the sensitivities and elasticities, we can really begin to see what is controlling the growth rate of a structured population. They provide us with the predicted effects on <span class="math inline">\(\lambda_1\)</span> of a proportional change in a demographic rate. This is particularly important in the management of invasive (or endangered) species where we seek to have the maximum impact for the minimum amount of effort and resources <span class="citation">(<a href="references.html#ref-Caswell:2001gu" role="doc-biblioref">Caswell 2001</a>; <a href="references.html#ref-Ellner:2006qe" role="doc-biblioref">S. P. Ellner and Guckenheimer 2006</a>)</span>. We can use these to help predict how a population might respond to natural phenomena or management practices that affect one stage or another.</p>
</div>
</div>
<div id="matrix-models-can-be-challenging" class="section level2" number="4.7">
<h2>
<span class="header-section-number">4.7</span> Matrix models can be challenging<a class="anchor" aria-label="anchor" href="#matrix-models-can-be-challenging"><i class="fas fa-link"></i></a>
</h2>
<p><em>All of these details can get very confusing</em>, and smart people don’t always get it right. <span class="citation">(<a href="#ref-Kendall2019" role="doc-biblioref"><strong>Kendall2019?</strong></a>)</span> reviewed approximately 125 published, peer-reviewed studies of birth-pulse matrix population models of animal populations to assess them for errors. They found that a surprisingly large number of studies made errors in model construction. The three most common errors were:</p>
<ol style="list-style-type: decimal">
<li>failing to include survival in the fertility coefficient; post-breeding models typically require adult survival, while pre-breeding models typically require seed/egg/larval transitions in fertility coefficients.</li>
<li>introducing a one-year delay in age at first reproduction; when juveniles transition to adult, this often creates a fertility coefficient for juveniles because they become adult and then breed within the year.</li>
<li>calculating incorrectly the growth rate out of a multi-age stage class; this can be tricky <span class="citation">(<a href="#ref-Kendall2019" role="doc-biblioref"><strong>Kendall2019?</strong></a>)</span>.</li>
</ol>
<p>Rely on expert advice <span class="citation">(<a href="references.html#ref-Caswell:2001gu" role="doc-biblioref">Caswell 2001</a>; <a href="references.html#ref-Ellner:2006qe" role="doc-biblioref">S. P. Ellner and Guckenheimer 2006</a>; <a href="#ref-Kendall2019" role="doc-biblioref"><strong>Kendall2019?</strong></a>)</span>, and remember that the stages of life cycle graph and matrix are the stages that you collect at one point in time, and an arrow or transition element has to include everything that happens from one census period to the next.</p>
</div>
<div id="integral-projection" class="section level2" number="4.8">
<h2>
<span class="header-section-number">4.8</span> Integral projection<a class="anchor" aria-label="anchor" href="#integral-projection"><i class="fas fa-link"></i></a>
</h2>
<p>[Make sure <code>primer</code> and <code>tidyverse</code> packages are loaded.]
What do we do if our stages seem like arbitrary categories along a continuous scale? What if size is easy to measure accurately and is a really good predictor of demographic rates, and these rates vary continuously with size? How do we decide on size classes? How do we draw seemingly arbitrary divisions between different sizes?</p>
<p>One way to avoid arbitrary stages is to use <em>integral projection</em>. With integral projection models <span class="citation">(<a href="references.html#ref-Ellner:2016aa" role="doc-biblioref">Stephen P. Ellner, Childs, and Rees 2016</a>)</span>, as opposed to matrix projection models, we no longer have to worry about a particular number of stages or age classes. We select an individual-level state variable, such as body mass, that varies continuously and use that. We could also use length, stem diameter, or even location, if any of these provide a useful predictor of demographic rates.</p>
<p>When we use a continuously varying state variable in place of stages or age classes, we can use statistical methods such as linear regression to describe the relations between the individual-level state variable and survival, growth, and fecundity. We then combine those relations to model how individuals in a population are likely to change from one generation to the next.</p>
<p>In many organisms, size is often a relatively good predictor of survival and fecundity. Within a population, size is often associated with age, learning, and resource acquisition. Size is also related to the onset of reproductive maturity and initiation of development of reproductive structures. Among reproductive individuals, size is often strongly correlated with per capita reproductive output. Integral projection can use size to model size-dependent demography.</p>
<p>Integral projection models (IPMs) are based on the calculus of integration across continuous variables to combine information about size-dependent demographic rates and size distributions to project population abundances and sizes in the future.</p>
<p>In practice, we rarely use the tools of integral calculus on which IPMs are so solidly grounded <span class="citation">(<a href="references.html#ref-Metcalf:2014ab" role="doc-biblioref">Metcalf et al. 2014</a>; <a href="references.html#ref-Merow2014" role="doc-biblioref">Merow et al. 2014</a>; <a href="references.html#ref-Ellner:2016aa" role="doc-biblioref">Stephen P. Ellner, Childs, and Rees 2016</a>)</span>. Instead, we approximate integration using very large matrices. As a simple example of this approximation, consider plant height that we measure using a meter stick. We assume that plant height is, in principle, a continuous variable that could take any real value between 0 and infinity. However, imagine that we only measure height to the nearest centimeter, and thereby create 100 height categories. This measurement process chops up continuous variation into very small discrete categories. For instance, if we use height as our measure plant size, and we estimate height to the nearest centimeter, then we have turned a continuous variable into a discrete variable, and could make a matrix in which each row and column represents all individuals who are within 1 cm of each other.</p>
<p>You will see below that when we implement integral projection models, we typically combine different techniques that are associated with continuous variation (e.g., linear regression) and with discrete variation (e.g., matrix algebra).</p>
<p>The continuous probability density analog of a matrix is referred to as a “kernel.” Regardless, the goal is the same – we want to use our understanding of growth, survival, and fecundity to estimate a matrix or kernel <strong>K</strong> where,
<span class="math display">\[\mathbf{K = GS + F}\]</span>.</p>
<p>The details require some understanding of probability densities, rather than probabilities, per se, but they are conceptually analogous, and our IPMs will take care of the details, if we build them right.</p>
<div id="on-probability-density" class="section level3" number="4.8.1">
<h3>
<span class="header-section-number">4.8.1</span> On probability density<a class="anchor" aria-label="anchor" href="#on-probability-density"><i class="fas fa-link"></i></a>
</h3>
<p>Probabilities sum to 1:</p>
<ul>
<li>The probabilities of heads and tails on a two-sided coin are each 0.5.</li>
<li>The probabilities of a 1, 2, 3, 4, 5, or 6 on a six-sided die are each 1/6.</li>
<li>The area under a normal distribution is 1.</li>
</ul>
<p>This is intuitive for discrete distributions like coins and dice. It gets confusing for continuous distributions, because the probability of getting a point value, such as precisely 1.00010101 goes to zero.</p>
<div class="sourceCode" id="cb147"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">ggplot</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.7</span><span class="op">)</span><span class="op">)</span>, <span class="fu">aes</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu">stat_function</span><span class="op">(</span>fun <span class="op">=</span> <span class="va">dnorm</span>, args<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>m<span class="op">=</span><span class="fl">.4</span>, sd<span class="op">=</span><span class="fl">.1</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> 
  <span class="fu">stat_function</span><span class="op">(</span>fun <span class="op">=</span> <span class="va">dnorm</span>, args<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>m<span class="op">=</span><span class="fl">.4</span>, sd<span class="op">=</span><span class="fl">.1</span><span class="op">)</span>,
                xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">.4</span>, <span class="fl">.5</span><span class="op">)</span>,
                geom <span class="op">=</span> <span class="st">"area"</span>, fill<span class="op">=</span><span class="st">"lightgrey"</span><span class="op">)</span> <span class="op">+</span> 
  <span class="fu">labs</span><span class="op">(</span>y<span class="op">=</span><span class="st">"Prob. density"</span>, x<span class="op">=</span><span class="st">"grams"</span>,
       title<span class="op">=</span><span class="st">"Hypothetical bumblebee mass"</span><span class="op">)</span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:probdens"></span>
<img src="figs/probdens-1.png" alt="With continuous variables, probabilities are calculated by calculating the area under the curve for the region of interest. According to this probability density, the probability of finding bee that weighs between 0.4 and 0.5 g is represented by the shaded area, or about 34%." width="90%"><p class="caption">
Figure 4.10: With continuous variables, probabilities are calculated by calculating the area under the curve for the region of interest. According to this probability density, the probability of finding bee that weighs between 0.4 and 0.5 g is represented by the shaded area, or about 34%.
</p>
</div>
<div class="sourceCode" id="cb148"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## two ways to estimate the area under the curve</span>
<span class="co">## with precision</span>
<span class="va">area.under.curve.precise</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">pnorm</a></span><span class="op">(</span><span class="fl">0.5</span>, m<span class="op">=</span><span class="fl">.4</span>, sd<span class="op">=</span><span class="fl">.1</span><span class="op">)</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">pnorm</a></span><span class="op">(</span><span class="fl">0.4</span>, m<span class="op">=</span><span class="fl">.4</span>, sd<span class="op">=</span><span class="fl">.1</span><span class="op">)</span>
<span class="co">## approximation using the midpoint rule</span>
<span class="va">midpoint</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="fl">.5</span> <span class="op">+</span> <span class="fl">.4</span><span class="op">)</span><span class="op">/</span><span class="fl">2</span>
<span class="va">width</span> <span class="op">&lt;-</span> <span class="fl">.5</span> <span class="op">-</span> <span class="fl">.4</span>
<span class="va">area.under.curve.midpoint</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="va">midpoint</span>, m<span class="op">=</span><span class="fl">.4</span>, sd<span class="op">=</span><span class="fl">.1</span><span class="op">)</span> <span class="op">*</span> <span class="va">width</span></code></pre></div>
<p>Probability density functions give us the unimodal curves that we are used to visiualising (e.g., the bell-shaped normal distribution). Cumulative probability functions are the integrals of these and allow us to calculate probabilities that a value will be in a particular region.</p>
<div class="sourceCode" id="cb149"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">ggplot</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.7</span><span class="op">)</span><span class="op">)</span>, <span class="fu">aes</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu">stat_function</span><span class="op">(</span>fun <span class="op">=</span> <span class="va">dnorm</span>, args<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>m<span class="op">=</span><span class="fl">.4</span>, sd<span class="op">=</span><span class="fl">.1</span><span class="op">)</span>, linetype<span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="op">+</span> 
  <span class="fu">stat_function</span><span class="op">(</span>fun <span class="op">=</span> <span class="va">pnorm</span>, args<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>m<span class="op">=</span><span class="fl">.4</span>, sd<span class="op">=</span><span class="fl">.1</span><span class="op">)</span><span class="op">)</span>  <span class="op">+</span> 
  <span class="fu">labs</span><span class="op">(</span>y<span class="op">=</span><span class="st">"Prob. density and cumulative prob."</span>,
       x<span class="op">=</span><span class="st">"grams"</span>, title<span class="op">=</span><span class="st">"Hypothetical bumblebee mass"</span><span class="op">)</span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:dnormpnrom"></span>
<img src="figs/dnormpnrom-1.png" alt="The solid line is the cumulative probabilility function, and tells us the area under the probability density function, from the lowest value up to a particular value of the variable $x$. You will notice that at the mean (0.4), the cumulative probability function equals 0.5, indicating that there would be a 50% chance of observing a value of $x$ that is less than the mean. At the right of the figure, the cumulative probability equals nearly 1, indicating that we have a near 100% chance of observing a value of $x$ that is less than 0.8." width="90%"><p class="caption">
Figure 4.11: The solid line is the cumulative probabilility function, and tells us the area under the probability density function, from the lowest value up to a particular value of the variable <span class="math inline">\(x\)</span>. You will notice that at the mean (0.4), the cumulative probability function equals 0.5, indicating that there would be a 50% chance of observing a value of <span class="math inline">\(x\)</span> that is less than the mean. At the right of the figure, the cumulative probability equals nearly 1, indicating that we have a near 100% chance of observing a value of <span class="math inline">\(x\)</span> that is less than 0.8.
</p>
</div>
<p>R provides a suite of probability functions, abbreviated with d-, p-, q-, and r-. For the Gaussian distribution these are</p>
<ul>
<li>
<code><a href="https://rdrr.io/r/stats/Normal.html">dnorm()</a></code>: the probability density function.</li>
<li>
<code>pnrom()</code>: the cumulative probability function.</li>
<li>
<code><a href="https://rdrr.io/r/stats/Normal.html">qnorm()</a></code>: the normal quantile function.</li>
<li>
<code><a href="https://rdrr.io/r/stats/Normal.html">rnorm()</a></code>: random draws from a normal distribution.</li>
</ul>
<p>See <code><a href="https://rdrr.io/r/stats/Normal.html">?dnorm</a></code> for details.</p>
<p>So,…probability densities are like probabilities, but you have to calculate the area under the curves to get probabilities. IPMs do that.</p>
</div>
<div id="a-size-based-ipm-of-smooth-coneflower" class="section level3" number="4.8.2">
<h3>
<span class="header-section-number">4.8.2</span> A size-based IPM of smooth coneflower<a class="anchor" aria-label="anchor" href="#a-size-based-ipm-of-smooth-coneflower"><i class="fas fa-link"></i></a>
</h3>
<p>Rachel Collins and colleagues have been studying populations of an endangered coneflower, <em>Echinecea laevigata</em>, in southwest Virginia, USA. Smooth coneflower is a perennial rhizomatous herbaceous plant that is sparsely distributed across mid-Atlantic and southeastern states (<a href="https://plants.usda.gov/">https://plants.usda.gov/</a>). It requires open spaces with little canopy cover, such as meadows or early successional habitat.</p>
Collins marked each individual in selected populations, measured size of individual coneflower plants using total leaf area, which ranged from 3-950 cm<span class="math inline">\(^2\)</span>. Because she tagged individuals and tracked changes over time, she was able estimate survival and fecundity of different sized individuals. She also measured seed set (number of seeds per inflorescence) and recruitment. Recruitment is emergence from the seed, that is, germination, growth, and survival in the first year.
<div class="figure">
<span style="display:block;" id="fig:cflh"></span>
<img src="figs/coneflowerLH.png" alt="Smooth coneflower, *Echinecea laevigata*, is an endangered plant that lives in only a few places on poor soils. It enjoys open, sunny habitats, long walks in the rain, and reading a good book by the fire (prescribed or wild)." width="100%"><p class="caption">
Figure 4.12: Smooth coneflower, <em>Echinecea laevigata</em>, is an endangered plant that lives in only a few places on poor soils. It enjoys open, sunny habitats, long walks in the rain, and reading a good book by the fire (prescribed or wild).
</p>
</div>
<p>In what follows, we graph empirical data on growth, survival, and fecundity (<em>y</em>-axis) as functions of log-size (<em>x</em>-axis). These continuous data will allow us to produce matrices with very narrow size classes.</p>
<p>In IPMs, it is common to use the logarithm of size rather than the original linear scale. This is because many processes scale with log-size <span class="citation">(<a href="references.html#ref-Ellner:2016aa" role="doc-biblioref">Stephen P. Ellner, Childs, and Rees 2016</a>)</span>. That is what we do here - all sizes are the base 10 logarithm of leaf area.</p>
<div class="sourceCode" id="cb150"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># vegetative coneflower data.</span>
<span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">coneflower</span><span class="op">)</span>
<span class="va">cf</span> <span class="op">&lt;-</span> <span class="va">coneflower</span>
<span class="co"># seed set</span>
<span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">coneflowerseeds</span><span class="op">)</span>
<span class="va">sf</span> <span class="op">&lt;-</span> <span class="va">coneflowerseeds</span>
<span class="co"># recruit sizes - not shown</span>
<span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">coneflowerrecruits</span><span class="op">)</span>
<span class="va">rs</span> <span class="op">&lt;-</span> <span class="va">coneflowerrecruits</span>
<span class="co"># recruit sizes - not shown</span></code></pre></div>
<div id="graphing-size-dependent-transitions" class="section level4" number="4.8.2.1">
<h4>
<span class="header-section-number">4.8.2.1</span> Graphing size-dependent transitions<a class="anchor" aria-label="anchor" href="#graphing-size-dependent-transitions"><i class="fas fa-link"></i></a>
</h4>
<p>Survival, <strong>S</strong>, from one year to the next depends on size.</p>
<div class="sourceCode" id="cb151"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">eda_s</span> <span class="op">&lt;-</span> <span class="fu">ggplot</span><span class="op">(</span><span class="va">cf</span>, <span class="fu">aes</span><span class="op">(</span><span class="va">logA</span>, <span class="va">surv</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="fu">lims</span><span class="op">(</span>x<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.5</span>, <span class="fl">2.75</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu">geom_jitter</span><span class="op">(</span>height<span class="op">=</span><span class="fl">.02</span>, alpha<span class="op">=</span><span class="fl">0.5</span><span class="op">)</span> <span class="op">+</span> 
  <span class="fu">geom_smooth</span><span class="op">(</span>method<span class="op">=</span><span class="st">"glm"</span>, method.args <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>family <span class="op">=</span> <span class="st">"binomial"</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="fu">labs</span><span class="op">(</span>title<span class="op">=</span><span class="st">"Survival"</span><span class="op">)</span>
<span class="va">eda_s</span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:unnamed-chunk-47"></span>
<img src="figs/unnamed-chunk-47-1.png" alt="Survival is represented as surviving (1) or not surviving (0). The probability of surviving to the next year, given a size in the first year, is estimated using logistic regression. The fitted line gives us a point estimate for survival for any log-size. The grey band represents uncertainty." width="67%"><p class="caption">
Figure 4.13: Survival is represented as surviving (1) or not surviving (0). The probability of surviving to the next year, given a size in the first year, is estimated using logistic regression. The fitted line gives us a point estimate for survival for any log-size. The grey band represents uncertainty.
</p>
</div>
<p>Using logistic regression provides a straightforward way to estimate size-dependent survival and its uncertainty. We can use both the estimate and its uncertainty in our projections.</p>
<p>Growth, <strong>G</strong>, is how the size of a plant in one year depends on its size in the previous year.</p>
<div class="sourceCode" id="cb152"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># use (filter) only the plants alive in both years</span>
<span class="va">cfs</span> <span class="op">&lt;-</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">cf</span>, <span class="va">surv</span><span class="op">==</span><span class="fl">1</span> <span class="op">&amp;</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span><span class="op">(</span><span class="va">logAp</span><span class="op">)</span><span class="op">)</span>
<span class="va">eda_g</span> <span class="op">&lt;-</span> <span class="fu">ggplot</span><span class="op">(</span><span class="va">cfs</span>, <span class="fu">aes</span><span class="op">(</span><span class="va">logA</span>, <span class="va">logAp</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="fu">geom_point</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu">geom_abline</span><span class="op">(</span>intercept<span class="op">=</span><span class="fl">0</span>, slope<span class="op">=</span><span class="fl">1</span>, lty<span class="op">=</span><span class="fl">2</span>, col<span class="op">=</span><span class="st">"blue"</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu">labs</span><span class="op">(</span>title<span class="op">=</span><span class="st">"Growth, Stasis, Regr."</span><span class="op">)</span> <span class="op">+</span> 
  <span class="fu">geom_smooth</span><span class="op">(</span>method<span class="op">=</span><span class="st">"lm"</span>,col<span class="op">=</span><span class="st">"red"</span>, se<span class="op">=</span><span class="op">)</span>
<span class="va">eda_g</span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:growth"></span>
<img src="figs/growth-1.png" alt="Growth is the relation between size at one time vs. size in another. The fitted estimate includes the 95% confidence interval. The dashed line is the 1:1 line; above this line is growth, while below it is regression to a smaller size. We include only those individuals that survive." width="67%"><p class="caption">
Figure 4.14: Growth is the relation between size at one time vs. size in another. The fitted estimate includes the 95% confidence interval. The dashed line is the 1:1 line; above this line is growth, while below it is regression to a smaller size. We include only those individuals that survive.
</p>
</div>
<p>Notice two features of this relation. First, the slope is less than 1:1. That means that smaller individuals tend to grow relatively more each year than large individuals. That is not surprising. Second, larger individuals actually tend to to regress to smaller sizes in a given year. This is not necessarily surprising either, but is useful to keep in mind. There might be some indication of a systematic tendancy to shrink after a year of flowering.</p>
<p>Next we tackle fecundity, <strong>F</strong>, which for us is estimated using</p>
<ul>
<li>the size-dependent probability of flowering,</li>
<li>the size-dependent number of seeds produced by a flowering individual,</li>
<li>the probability of a seed germinating and surviving to be a new recruit, and</li>
<li>the size-distribution of new recruits.</li>
</ul>
<p>Typically, bigger individuals have a greater chance of flowering, and smooth coneflower is no exception. We estimate that chance using logistic regression.</p>
<div class="sourceCode" id="cb153"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">cff</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/filter.html">filter</a></span><span class="op">(</span><span class="va">cf</span>, <span class="va">surv</span><span class="op">==</span><span class="fl">1</span> <span class="op">)</span>
<span class="va">eda_f</span> <span class="op">&lt;-</span> <span class="fu">ggplot</span><span class="op">(</span><span class="va">cfs</span>, <span class="fu">aes</span><span class="op">(</span><span class="va">logA</span>, <span class="va">flower_p</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> 
  <span class="fu">geom_jitter</span><span class="op">(</span>height<span class="op">=</span><span class="fl">.02</span>, alpha<span class="op">=</span><span class="fl">0.5</span><span class="op">)</span> <span class="op">+</span> 
  <span class="fu">geom_smooth</span><span class="op">(</span>method<span class="op">=</span><span class="st">"glm"</span>, method.args <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>family <span class="op">=</span> <span class="st">"binomial"</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="fu">labs</span><span class="op">(</span>title<span class="op">=</span><span class="st">"Flowering"</span><span class="op">)</span>
<span class="va">eda_f</span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:flowering"></span>
<img src="figs/flowering-1.png" alt="Plants that are larger in the first year have a greater chance of flowering in the next year." width="67%"><p class="caption">
Figure 4.15: Plants that are larger in the first year have a greater chance of flowering in the next year.
</p>
</div>
<p>One feature of these data is that most individuals do no flower at all and the even large individuals do not necessarily flower.</p>
<p>We will also check whether bigger plants might produce more seeds.</p>
<div class="sourceCode" id="cb154"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">eda_sd</span> <span class="op">&lt;-</span> <span class="fu">ggplot</span><span class="op">(</span><span class="va">sf</span>, <span class="fu">aes</span><span class="op">(</span><span class="va">logAs</span>, <span class="va">seeds</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="fu">geom_point</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu">geom_smooth</span><span class="op">(</span>method<span class="op">=</span><span class="st">"lm"</span><span class="op">)</span> <span class="op">+</span> <span class="fu">labs</span><span class="op">(</span>title<span class="op">=</span><span class="st">"Seed set"</span><span class="op">)</span>
<span class="va">eda_sd</span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:seed"></span>
<img src="figs/seed-1.png" alt="No compelling evidence that size influences seed set. Nonetheless, we will use this approach in estiamting fecundity, F." width="67%"><p class="caption">
Figure 4.16: No compelling evidence that size influences seed set. Nonetheless, we will use this approach in estiamting fecundity, F.
</p>
</div>
<p>These data don’t provide strong evidence that larger plants produce more seeds. However, using this relation regardless will allow us to include the observation variation in seed production among those individuals to do flower.</p>
<p>We also need to estimate <em>establishment probability</em>, or the chance that a seed germinates and survives until the following summer. Collins estimated that using seed baskets. These are mesh baskets filled with soil into which she placed a known number of seeds. They are placed in the ground and seedlings or recruits are counted the following year.</p>
<div class="sourceCode" id="cb155"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># 50 seeds into each of baskets</span>
<span class="va">N</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">50</span>, <span class="fl">9</span><span class="op">)</span>
<span class="co"># no. of seeds planted in the fall that popped up and</span>
<span class="co"># survived into June</span>
<span class="va">success</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">5</span>,<span class="fl">8</span>,<span class="fl">11</span>,<span class="fl">10</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">4</span>,<span class="fl">5</span>,<span class="fl">5</span><span class="op">)</span>
<span class="va">Y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">success</span>, failure<span class="op">=</span><span class="va">N</span><span class="op">-</span><span class="va">success</span><span class="op">)</span>
<span class="va">germ.est</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span><span class="op">(</span><span class="va">Y</span> <span class="op">~</span> <span class="fl">1</span>, family<span class="op">=</span><span class="st">"binomial"</span><span class="op">)</span>
<span class="co"># the point estimate of establishment success</span>
<span class="co"># backtransform from logistic regression.</span>
<span class="va">pr</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">/</span><span class="op">(</span><span class="fl">1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">germ.est</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>

<span class="co"># plot the probability distribution of establishment </span>
<span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">Y</span><span class="op">[</span>,<span class="st">"success"</span><span class="op">]</span><span class="op">)</span>
<span class="va">nx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">Y</span><span class="op">[</span>,<span class="st">"failure"</span><span class="op">]</span><span class="op">)</span>
<span class="co"># Use the Jeffreys interval, which is based on the Beta distribution </span>
<span class="co"># with priors of (1/2, 1/2) being the conjugate prior for the binomial.</span>
<span class="va">eda_pr</span> <span class="op">&lt;-</span> <span class="fu">ggplot</span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span>, <span class="fu">aes</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu">stat_function</span><span class="op">(</span>fun <span class="op">=</span> <span class="va">dbeta</span>, n <span class="op">=</span> <span class="fl">501</span>, 
                args <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>shape1 <span class="op">=</span> <span class="va">x</span><span class="op">+</span><span class="fl">1</span><span class="op">/</span><span class="fl">2</span>, shape2<span class="op">=</span><span class="va">nx</span><span class="op">+</span><span class="fl">1</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> 
    <span class="fu">labs</span><span class="op">(</span>x<span class="op">=</span><span class="st">"Prob(recruiting)"</span>, y<span class="op">=</span><span class="st">"Probability density"</span>, title<span class="op">=</span><span class="st">"Seed basket recruitment"</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu">scale_y_continuous</span><span class="op">(</span>breaks <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span>
<span class="va">eda_pr</span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:pr"></span>
<img src="figs/pr-1.png" alt="Probability that seeds in one year establish as new recruits the following summer." width="67%"><p class="caption">
Figure 4.17: Probability that seeds in one year establish as new recruits the following summer.
</p>
</div>
<p>We can use other data (not shown) to characterize the size distribution of new recruits, which are approximately log-normally distributed.</p>
<div class="sourceCode" id="cb156"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">m.log</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log10</a></span><span class="op">(</span><span class="va">rs</span><span class="op">$</span><span class="va">area17</span><span class="op">)</span><span class="op">)</span> <span class="co"># mean of log-area of new recruits</span>
<span class="va">std.log</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log10</a></span><span class="op">(</span><span class="va">rs</span><span class="op">$</span><span class="va">area17</span><span class="op">)</span><span class="op">)</span> <span class="co"># st. dev. of log-area of new recruits</span>
<span class="va">eda_C</span> <span class="op">&lt;-</span> <span class="fu">ggplot</span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.4</span>, <span class="fl">1.4</span><span class="op">)</span><span class="op">)</span>, <span class="fu">aes</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu">stat_function</span><span class="op">(</span>fun <span class="op">=</span> <span class="va">dnorm</span>, n <span class="op">=</span> <span class="fl">101</span>, 
                args <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>mean <span class="op">=</span> <span class="va">m.log</span>, sd <span class="op">=</span> <span class="va">std.log</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu">labs</span><span class="op">(</span>y<span class="op">=</span><span class="st">"Prob(recruit log-size x)"</span>, 
       title<span class="op">=</span><span class="st">"Distr. of recruit sizes"</span><span class="op">)</span> <span class="op">+</span> 
  <span class="fu">scale_y_continuous</span><span class="op">(</span>breaks <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span>
<span class="va">eda_C</span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:recruits"></span>
<img src="figs/recruits-1.png" alt="The size distribution of new recruits; we assume that this is independent of plant size in year t." width="67%"><p class="caption">
Figure 4.18: The size distribution of new recruits; we assume that this is independent of plant size in year t.
</p>
</div>
</div>
<div id="statistical-modeling-of-size-dependent-transitions" class="section level4" number="4.8.2.2">
<h4>
<span class="header-section-number">4.8.2.2</span> Statistical modeling of size-dependent transitions<a class="anchor" aria-label="anchor" href="#statistical-modeling-of-size-dependent-transitions"><i class="fas fa-link"></i></a>
</h4>
<p>First we estimate something from data, then we use it to build functions. I use code handed down on stone tablets from Ellner, Merow, and others.</p>
<p>We start with a data frame to hold summaries.</p>
<div class="sourceCode" id="cb157"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## this sets up a list of the model parameters. </span>
<span class="co">## These parameters will be estimated below and stored in 'params'.</span>
<span class="va">params</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>
    surv.int<span class="op">=</span><span class="cn">NA</span>, <span class="co"># y-intercept of the survival regresion</span>
    surv.slope<span class="op">=</span><span class="cn">NA</span>, <span class="co"># slope of the survival regresion</span>
    growth.int<span class="op">=</span><span class="cn">NA</span>,
    growth.slope<span class="op">=</span><span class="cn">NA</span>,
    growth.sd<span class="op">=</span><span class="cn">NA</span>,
    flowering.int<span class="op">=</span><span class="cn">NA</span>,
    flowering.slope<span class="op">=</span><span class="cn">NA</span>,
    seed.int<span class="op">=</span><span class="cn">NA</span>,
    seed.slope<span class="op">=</span><span class="cn">NA</span>,
    seed.sd<span class="op">=</span><span class="cn">NA</span>,
    recruit.size.mean<span class="op">=</span><span class="cn">NA</span>,
    recruit.size.sd<span class="op">=</span><span class="cn">NA</span>,
    establishment.prob<span class="op">=</span><span class="cn">NA</span>
<span class="op">)</span></code></pre></div>
<p>Next, we perform the analyses from which we extract means, linear relationships, and variation, and put these values into the above data frame.</p>
<p>For survival probability, <span class="math inline">\(s\)</span>, we use logistic regression, also known as a <em>general linearized model</em> with a binomial error distribution and a logit link function. Genaralized linear models are a broad class of models that allow the use of a wide variety of types of data and error distributions
<span class="math display">\[\log \left( \frac{s}{1-s} \right) = b_0 + b_1 \mathrm{size} + \mathrm{error}\]</span>
where <span class="math inline">\(0 \le s \le 1\)</span> because it is a probability. The data for a logistic regression are ones and zeroes, or successes and failures.</p>
<div class="sourceCode" id="cb158"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#survival regression</span>
<span class="co">## the model statement</span>
<span class="va">surv.reg</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span><span class="op">(</span><span class="va">surv</span><span class="op">~</span><span class="va">logA</span>,data<span class="op">=</span><span class="va">cf</span>,family<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/stats/family.html">binomial</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>

<span class="co">## saving the intercept and slope of the line</span>
<span class="va">params</span><span class="op">$</span><span class="va">surv.int</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">surv.reg</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>
<span class="va">params</span><span class="op">$</span><span class="va">surv.slope</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">surv.reg</span><span class="op">)</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>
<span class="co">## the uncertainty is built into the model</span></code></pre></div>
<p>We can model growth in a linear model, with a normal error distribution - the type of regression we are most familiar with,
<span class="math display">\[ z^\prime = b_0 + b_1 z + \mathrm{error}\]</span>
where <span class="math inline">\(z\)</span> and <span class="math inline">\(z^\prime\)</span> are log-leaf area in one year and the next year.</p>
<div class="sourceCode" id="cb159"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## Model statement</span>
<span class="va">gr.reg</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">logAp</span> <span class="op">~</span> <span class="va">logA</span>, data<span class="op">=</span><span class="va">cf</span><span class="op">)</span>
<span class="co">## Saving the intercept and slope</span>
<span class="va">params</span><span class="op">$</span><span class="va">growth.int</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">gr.reg</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>
<span class="va">params</span><span class="op">$</span><span class="va">growth.slope</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">gr.reg</span><span class="op">)</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>
<span class="co">## Saving standard deviation, our estimate of uncertainty</span>
<span class="co">## in a normal model</span>
<span class="va">params</span><span class="op">$</span><span class="va">growth.sd</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/residuals.html">resid</a></span><span class="op">(</span><span class="va">gr.reg</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>To estimate the probability that a plant flowers, we use survivors and the presence or absence of flowers to fit a logistic regression.</p>
<div class="sourceCode" id="cb160"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Flowering</span>
<span class="co">## model statement</span>
<span class="va">fl.reg</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span><span class="op">(</span><span class="va">flower_p</span><span class="op">~</span><span class="va">logA</span>, data<span class="op">=</span><span class="va">cf</span>,family<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/stats/family.html">binomial</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>
<span class="co">## saving the intercept and slope</span>
<span class="va">params</span><span class="op">$</span><span class="va">flowering.int</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">fl.reg</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>
<span class="va">params</span><span class="op">$</span><span class="va">flowering.slope</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">fl.reg</span><span class="op">)</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span></code></pre></div>
<p>To estimate seed set, or the number of seeds per individual, we can once again rely on a linear model with normal errors.</p>
<div class="sourceCode" id="cb161"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## Seed set</span>
<span class="co">## model statement</span>
<span class="va">seed.reg</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">seeds</span> <span class="op">~</span> <span class="va">logAs</span>, data<span class="op">=</span><span class="va">sf</span><span class="op">)</span>
<span class="co">## Saving the intercept and the slope</span>
<span class="va">params</span><span class="op">$</span><span class="va">seed.int</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">seed.reg</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>
<span class="va">params</span><span class="op">$</span><span class="va">seed.slope</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">seed.reg</span><span class="op">)</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>
<span class="co">## Our estimate of uncertainty, the standard deviation</span>
<span class="va">params</span><span class="op">$</span><span class="va">seed.sd</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/residuals.html">resid</a></span><span class="op">(</span><span class="va">seed.reg</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>We estimated the probability of recruitment and the recruit size distribution above, when we made graphs. See the code above for details. Here we save the estimates in our list called <code>params</code>.</p>
<div class="sourceCode" id="cb162"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># recruitment - see above for details</span>
<span class="va">params</span><span class="op">$</span><span class="va">establishment.prob</span> <span class="op">&lt;-</span> <span class="va">pr</span>

<span class="co"># recruit size distr.</span>
<span class="va">params</span><span class="op">$</span><span class="va">recruit.size.mean</span> <span class="op">&lt;-</span> <span class="va">m.log</span>
<span class="va">params</span><span class="op">$</span><span class="va">recruit.size.sd</span> <span class="op">&lt;-</span> <span class="va">std.log</span></code></pre></div>
</div>
<div id="generating-the-projection-kernel" class="section level4" number="4.8.2.3">
<h4>
<span class="header-section-number">4.8.2.3</span> Generating the projection kernel<a class="anchor" aria-label="anchor" href="#generating-the-projection-kernel"><i class="fas fa-link"></i></a>
</h4>
<p>First, we make functions that will use the above relationships and the data frame to make the kernel. the variable <code>z</code> is size in the first year and <code>zp</code> is “z prime,” size in the next year. Then we use those to fill out the kernel. The kernel is, in principle, continuous, but in practice is matrix with very narrow size stages.</p>
<p>We begin by creating a function to estimate the probability of surviving, <span class="math inline">\(s\)</span>, given a size <span class="math inline">\(z\)</span>. This is a back transformation of the logistic function, where
<span class="math display">\[s = \frac{\exp (\beta_0 + \beta_1 z)}{1 + \exp (\beta_0 + \beta_1 z)}\]</span></p>
<div class="sourceCode" id="cb163"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">s.z</span><span class="op">=</span><span class="kw">function</span><span class="op">(</span><span class="va">z</span>,<span class="va">params</span><span class="op">)</span> <span class="op">{</span>
  <span class="co"># calculate survival probability by</span>
  <span class="co"># backtransforming glm regression params for the </span>
  <span class="co"># intercept and slope of the regression</span>
    <span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">params</span><span class="op">$</span><span class="va">surv.int</span> <span class="op">+</span> <span class="va">params</span><span class="op">$</span><span class="va">surv.slope</span><span class="op">*</span><span class="va">z</span><span class="op">)</span>
    <span class="va">s</span> <span class="op">&lt;-</span> <span class="va">u</span><span class="op">/</span><span class="op">(</span><span class="fl">1</span><span class="op">+</span><span class="va">u</span><span class="op">)</span>
    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">s</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<p>Next we create a function to estimate the probability of growing from size <span class="math inline">\(z\)</span> to size <span class="math inline">\(z^\prime\)</span>. This could be an increase or a decrease in size. The regression we did relied on the normal distribution, and so requires an intercept, a slope, and a standard deviation.</p>
<div class="sourceCode" id="cb164"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">g.zpz</span><span class="op">=</span><span class="kw">function</span><span class="op">(</span><span class="va">zp</span>,<span class="va">z</span>,<span class="va">params</span><span class="op">)</span> <span class="op">{</span> 
  <span class="co"># describe the normal linear relation between size at t=0 vs. t=1.</span>
  <span class="co"># size(t+1) = y.intercept + slope*size(t) + e; e~N(0,sigma^2)</span>
  <span class="co"># dnorm returns the probability density, given those parameters</span>
    <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="va">zp</span>,
          mean<span class="op">=</span><span class="va">params</span><span class="op">$</span><span class="va">growth.int</span><span class="op">+</span><span class="va">params</span><span class="op">$</span><span class="va">growth.slope</span><span class="op">*</span><span class="va">z</span>,
          sd<span class="op">=</span><span class="va">params</span><span class="op">$</span><span class="va">growth.sd</span><span class="op">)</span>
  <span class="co"># 'mean' is the mean log-size, </span>
  <span class="co"># 'sd' is the standard deviation, and thus describes the </span>
  <span class="co"># variety of sizes that will occur</span>
<span class="op">}</span></code></pre></div>
<p>Next we create a function to estimate the probability of having a particular “fecundity,” which in these models is far more than just offspring production because it encompasses an entire year. It includes a lot:</p>
<ul>
<li>size-dependent flowering probability</li>
<li>seeds per flowering head (maybe size dependent)</li>
<li>germination probability</li>
<li>survival of new recruits from germination to first census</li>
<li>size distribution of new recruits</li>
</ul>
<div class="sourceCode" id="cb165"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">f.zpz</span><span class="op">=</span><span class="kw">function</span><span class="op">(</span><span class="va">zp</span>,<span class="va">z</span>,<span class="va">params</span><span class="op">)</span> <span class="op">{</span>
  <span class="co"># size-dep prob of flowering times...</span>
    <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">params</span><span class="op">$</span><span class="va">flowering.int</span> <span class="op">+</span> <span class="va">params</span><span class="op">$</span><span class="va">flowering.slope</span><span class="op">*</span><span class="va">z</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1</span><span class="op">+</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">params</span><span class="op">$</span><span class="va">flowering.int</span> <span class="op">+</span> <span class="va">params</span><span class="op">$</span><span class="va">flowering.slope</span><span class="op">*</span><span class="va">z</span><span class="op">)</span><span class="op">)</span> <span class="op">*</span>
    <span class="co"># size-dep number of seeds times...</span>
    <span class="op">(</span><span class="va">params</span><span class="op">$</span><span class="va">seed.int</span><span class="op">+</span><span class="va">params</span><span class="op">$</span><span class="va">seed.slope</span><span class="op">*</span><span class="va">z</span><span class="op">)</span> <span class="op">*</span>
    <span class="co"># p(r), prob of recruitment (germination and establishment) times...</span>
    <span class="va">params</span><span class="op">$</span><span class="va">establishment.prob</span> <span class="op">*</span>
    <span class="co"># distribution of sizes in the first year</span>
    <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="va">zp</span>, mean<span class="op">=</span><span class="va">params</span><span class="op">$</span><span class="va">recruit.size.mean</span>, sd<span class="op">=</span><span class="va">params</span><span class="op">$</span><span class="va">recruit.size.sd</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<p>Finally, we begin to create our finite analogue of the continuous kernel: our discretized kernel, <span class="math inline">\(K\)</span>. We determine</p>
<ul>
<li>the upper and lower size bounds on log-plant size,</li>
<li>the number of discrete cells or size intervals,</li>
<li>the bounds of each discrete size interval, and</li>
<li>the midpoints of each interval, and</li>
<li>the width of interval.</li>
</ul>
<div class="sourceCode" id="cb166"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># 1. boundary points b, mesh points y and step size h</span>
<span class="co"># integration limits - these limits span the range of sizes observed in the data set, and then some.</span>
<span class="va">min.size</span><span class="op">=</span><span class="fl">.9</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log10</a></span><span class="op">(</span><span class="va">rs</span><span class="op">$</span><span class="va">area17</span><span class="op">)</span>, <span class="va">cf</span><span class="op">$</span><span class="va">logA</span>, <span class="va">cf</span><span class="op">$</span><span class="va">logAp</span><span class="op">)</span>,na.rm<span class="op">=</span><span class="cn">T</span><span class="op">)</span>
<span class="va">max.size</span><span class="op">=</span><span class="fl">1.1</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log10</a></span><span class="op">(</span><span class="va">rs</span><span class="op">$</span><span class="va">area19</span><span class="op">)</span>, <span class="va">cf</span><span class="op">$</span><span class="va">logA</span>,<span class="va">cf</span><span class="op">$</span><span class="va">logAp</span><span class="op">)</span>,na.rm<span class="op">=</span><span class="cn">T</span><span class="op">)</span>
<span class="co"># number of cells or interval in the discretized kernel</span>
<span class="va">n</span><span class="op">=</span><span class="fl">100</span> 
<span class="co"># boundary points (the edges of the cells defining the kernel)</span>
<span class="va">b</span> <span class="op">=</span> <span class="va">min.size</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="va">n</span><span class="op">)</span><span class="op">*</span><span class="op">(</span><span class="va">max.size</span><span class="op">-</span><span class="va">min.size</span><span class="op">)</span><span class="op">/</span><span class="va">n</span> 
<span class="co"># mesh points (midpoints of the cells)</span>
<span class="va">y</span> <span class="op">=</span> <span class="op">(</span> <span class="va">b</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">n</span><span class="op">]</span> <span class="op">+</span> <span class="va">b</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="va">n</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">]</span> <span class="op">)</span> <span class="op">/</span> <span class="fl">2</span>
<span class="co"># width of the cells</span>
<span class="va">h</span> <span class="op">=</span> <span class="va">y</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">-</span><span class="va">y</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span></code></pre></div>
<p>Our discretized kernel, will be a 100 x 100 matrix (n=100). Thus we are dividing up a log-size range of 2.32 (0.629–2.949) into 100 equal size categories or size stages. That is more finely divided than Collins and her colleagues actually used in their sizes estimates and ensures that we are not simplifying their data.</p>
<p>Here we use the functions we made above to fill out growth, survival and fecundity elements of the full kernel, <span class="math inline">\(K\)</span>.</p>
<div class="sourceCode" id="cb167"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## Growth kernel</span>
<span class="co"># 'outer()'  yields an outer matrix product where each element is can be an arbitrary function.</span>
<span class="va">G</span><span class="op">=</span><span class="va">h</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/outer.html">outer</a></span><span class="op">(</span><span class="va">y</span>, <span class="va">y</span>, FUN<span class="op">=</span><span class="va">g.zpz</span>, params<span class="op">=</span><span class="va">params</span><span class="op">)</span>   <span class="co"># 100 x 100 growth kernel</span>

<span class="co">## Survival kernel</span>
<span class="va">S</span><span class="op">=</span><span class="fu">s.z</span><span class="op">(</span><span class="va">y</span>,params<span class="op">=</span><span class="va">params</span><span class="op">)</span>   <span class="co"># 100 x 100 survival kernel</span>

<span class="co">## Growth X Survival kernel</span>
<span class="va">P</span> <span class="op">=</span> <span class="va">G</span> <span class="co"># placeholder;redefine P on the next line</span>
<span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">n</span><span class="op">)</span> <span class="va">P</span><span class="op">[</span>,<span class="va">i</span><span class="op">]</span><span class="op">=</span><span class="va">G</span><span class="op">[</span>,<span class="va">i</span><span class="op">]</span><span class="op">*</span><span class="va">S</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>  <span class="co"># 100 x 100 growth*survival kernel</span>

<span class="co">## Fecundity kernel</span>
<span class="va">Fec</span><span class="op">=</span><span class="va">h</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/outer.html">outer</a></span><span class="op">(</span><span class="va">y</span>, <span class="va">y</span>, <span class="va">f.zpz</span>, params<span class="op">=</span><span class="va">params</span><span class="op">)</span>  <span class="co"># 100 x 100 fecundity</span>

<span class="co">## the full projection kernel</span>
<span class="va">K</span><span class="op">=</span><span class="va">P</span><span class="op">+</span><span class="va">Fec</span> <span class="co"># full 100 x 100 discretized kernel</span></code></pre></div>
<p>Finally, we plot the component and full kernels so that we can visualize them and thereby better appreciate what the result is.</p>
<div class="sourceCode" id="cb168"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## create a 2 x 2 array of subfigures</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span>
<span class="co">## plot Growth</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/image.html">image</a></span><span class="op">(</span><span class="va">y</span>,<span class="va">y</span>,<span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">G</span><span class="op">)</span>,main<span class="op">=</span><span class="st">'G'</span><span class="op">)</span>        <span class="co"># plot it</span>
<span class="co">## Plot growth X survival</span>
<span class="op">{</span><span class="fu"><a href="https://rdrr.io/r/graphics/image.html">image</a></span><span class="op">(</span><span class="va">y</span>,<span class="va">y</span>,<span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">P</span><span class="op">)</span>, main<span class="op">=</span><span class="st">'GS'</span><span class="op">)</span>   <span class="co"># plot it</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span>,lwd<span class="op">=</span><span class="fl">3</span><span class="op">)</span> <span class="op">}</span><span class="co"># plot 1:1, which represents stasis</span>
<span class="co">## plot fecundity</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/image.html">image</a></span><span class="op">(</span><span class="va">y</span>,<span class="va">y</span>,<span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">Fec</span><span class="op">)</span>,main<span class="op">=</span><span class="st">'F'</span><span class="op">)</span> <span class="co"># plot it</span>
<span class="co">## We could just use image(y,y,t(K),main='full kernel')</span>
<span class="co"># however, sometimes it's hard to see both because</span>
<span class="co"># fecundity swamps the growth/survival part, </span>
<span class="co"># so here's a plotting trick to level out the kernel</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/image.html">image</a></span><span class="op">(</span><span class="va">y</span>,<span class="va">y</span>,<span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">K</span><span class="op">)</span><span class="op">^</span><span class="fl">.33</span>,main<span class="op">=</span><span class="st">'K'</span>, 
      col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/grDevices/gray.colors.html">grey.colors</a></span><span class="op">(</span><span class="fl">12</span>, start<span class="op">=</span><span class="fl">0</span>, end<span class="op">=</span><span class="fl">1</span>, rev <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:kernels"></span>
<img src="figs/kernels-1.png" alt="The component kernels G, S, and F, that make up the full demographic projection kernel, K, for smooth cone flower. By convention and unlike projection matrices, kernels scale both axes to start at the smallest size in the lower left corner. The color scaling of the full kernel differs slightly so that we can see the contributions of G, S, and F." width="90%"><p class="caption">
Figure 4.19: The component kernels G, S, and F, that make up the full demographic projection kernel, K, for smooth cone flower. By convention and unlike projection matrices, kernels scale both axes to start at the smallest size in the lower left corner. The color scaling of the full kernel differs slightly so that we can see the contributions of G, S, and F.
</p>
</div>
<p>So there we have it: a discretized projection kernel that allows us to start with reasonably intuitive data on size, and size-dependent life history and demography of survival, growth, and more, and arrive at a way to predict future status and understand the roles of different life history stages on population dynamics.</p>
</div>
</div>
<div id="population-summaries" class="section level3" number="4.8.3">
<h3>
<span class="header-section-number">4.8.3</span> Population summaries<a class="anchor" aria-label="anchor" href="#population-summaries"><i class="fas fa-link"></i></a>
</h3>
<p>Any question that we could answer using matrices, we can answer using discretized kernels (i.e., finely divided matrices).</p>
<p>We estimate the finite rate of increase, <span class="math inline">\(\lambda\)</span>, the same way we did before.</p>
<div class="sourceCode" id="cb169"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">lambda</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/complex.html">Re</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/eigen.html">eigen</a></span><span class="op">(</span><span class="va">K</span><span class="op">)</span><span class="op">$</span><span class="va">values</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>[1] 1.061195</p>
<p>The same is true for the stable size distribution, reproductive value, and elasticity.</p>
<div class="sourceCode" id="cb170"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">w.eigen</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/complex.html">Re</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/eigen.html">eigen</a></span><span class="op">(</span><span class="va">K</span><span class="op">)</span><span class="op">$</span><span class="va">vectors</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span>
<span class="va">stable.dist</span><span class="op">=</span><span class="va">w.eigen</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">w.eigen</span><span class="op">)</span> 
<span class="va">v.eigen</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/complex.html">Re</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/eigen.html">eigen</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">K</span><span class="op">)</span><span class="op">)</span><span class="op">$</span><span class="va">vectors</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span>
<span class="va">repro.val</span><span class="op">=</span><span class="va">v.eigen</span><span class="op">/</span><span class="va">v.eigen</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> 


<span class="co"># The eigen-things can be combined to obtain the sensitivity and elasticity matrices.</span>
<span class="co"># 2. compute elasticity and sensitivity matrices</span>
<span class="va">v.dot.w</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">stable.dist</span><span class="op">*</span><span class="va">repro.val</span><span class="op">)</span><span class="op">*</span><span class="va">h</span>
<span class="va">sens</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/outer.html">outer</a></span><span class="op">(</span><span class="va">repro.val</span>,<span class="va">stable.dist</span><span class="op">)</span><span class="op">/</span><span class="va">v.dot.w</span>
<span class="va">elas</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/vector.html">as.vector</a></span><span class="op">(</span><span class="va">sens</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/vector.html">as.vector</a></span><span class="op">(</span><span class="va">K</span><span class="op">)</span><span class="op">/</span><span class="va">lambda</span>,nrow<span class="op">=</span><span class="va">n</span><span class="op">)</span>

<span class="co"># 3. plot results </span>
<span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span> 
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">y</span>,<span class="va">stable.dist</span>,xlab<span class="op">=</span><span class="st">"Size"</span>,type<span class="op">=</span><span class="st">"l"</span>,main<span class="op">=</span><span class="st">"Stable size distribution"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">y</span>,<span class="va">repro.val</span>,xlab<span class="op">=</span><span class="st">"Size"</span>,type<span class="op">=</span><span class="st">"l"</span>,main<span class="op">=</span><span class="st">"Reproductive values"</span><span class="op">)</span> 
<span class="op">{</span><span class="fu"><a href="https://rdrr.io/r/graphics/image.html">image</a></span><span class="op">(</span><span class="va">y</span>,<span class="va">y</span>,<span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">elas</span><span class="op">)</span>,xlab<span class="op">=</span><span class="st">"Size (t)"</span>,ylab<span class="op">=</span><span class="st">"Size (t+1)"</span>,main<span class="op">=</span><span class="st">"Elasticity"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1.5</span>,<span class="fl">2</span>,<span class="fl">2.5</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">.75</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1.5</span>,<span class="fl">2</span>,<span class="fl">2.5</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">.75</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<div class="figure">
<span style="display:block;" id="fig:Ksolutions"></span>
<img src="figs/Ksolutions-1.png" alt="Descriptions of smooth coneflower demographics." width="90%"><p class="caption">
Figure 4.20: Descriptions of smooth coneflower demographics.
</p>
</div>
<p>There is a ton more stuff we can do. Way more <span class="citation">(<a href="references.html#ref-Ellner:2016aa" role="doc-biblioref">Stephen P. Ellner, Childs, and Rees 2016</a>)</span>.</p>
</div>
</div>
<div id="r-packges-for-demography" class="section level2" number="4.9">
<h2>
<span class="header-section-number">4.9</span> R packges for demography<a class="anchor" aria-label="anchor" href="#r-packges-for-demography"><i class="fas fa-link"></i></a>
</h2>
<p><span class="citation"><a href="references.html#ref-Caswell:2001gu" role="doc-biblioref">Caswell</a> (<a href="references.html#ref-Caswell:2001gu" role="doc-biblioref">2001</a>)</span> is a definitive reference text for matrix models. <span class="citation"><a href="references.html#ref-Ellner:2006qe" role="doc-biblioref">S. P. Ellner and Guckenheimer</a> (<a href="references.html#ref-Ellner:2006qe" role="doc-biblioref">2006</a>)</span> provides an excellent introduction, and I am sure there are many other excellent texts as well.</p>
<p><span class="citation"><a href="references.html#ref-Stubben:2007" role="doc-biblioref">Stubben and Milligan</a> (<a href="references.html#ref-Stubben:2007" role="doc-biblioref">2007</a>)</span> and <span class="citation"><a href="references.html#ref-Stott:2018" role="doc-biblioref">Stott, Hodgson, and Townley</a> (<a href="references.html#ref-Stott:2018" role="doc-biblioref">2018</a>)</span>, and <span class="citation"><a href="references.html#ref-delaCruz:2019" role="doc-biblioref">de la Cruz</a> (<a href="references.html#ref-delaCruz:2019" role="doc-biblioref">2019</a>)</span> provide R packages for stage-based matrix models with methods that go well beyond this text. In addition, there are several other packages for analyzing life tables and human demography.</p>
<p><span class="citation"><a href="references.html#ref-Ellner:2016aa" role="doc-biblioref">Stephen P. Ellner, Childs, and Rees</a> (<a href="references.html#ref-Ellner:2016aa" role="doc-biblioref">2016</a>)</span> is probably the best source for understanding IPMs. The R package IPMpack <span class="citation">(<a href="references.html#ref-Metcalf:2014ab" role="doc-biblioref">Metcalf et al. 2014</a>)</span> is an excellent package to implement and analyze IPMs.</p>
</div>
<div id="loggerhead-sea-turtle-a-classic-example" class="section level2" number="4.10">
<h2>
<span class="header-section-number">4.10</span> Loggerhead Sea Turtle: a classic example<a class="anchor" aria-label="anchor" href="#loggerhead-sea-turtle-a-classic-example"><i class="fas fa-link"></i></a>
</h2>
<p><span class="citation"><a href="references.html#ref-Crouse1987" role="doc-biblioref">Crouse, Crowder, and Caswell</a> (<a href="references.html#ref-Crouse1987" role="doc-biblioref">1987</a>)</span> performed a demographic analysis of an endangered sea turtle species, the loggerhead (<em>Caretta caretta</em>). Management of loggerhead populations seemed essential for their long term survival, and a popular management strategy had been and still is to protect nesting females, eggs, and hatchlings. The ground breaking work by Crouse<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Crouse was a graduate student at the time—graduate students are the life-blood of modern science, doing cutting edge work and pushing their fields forward.&lt;/p&gt;"><sup>29</sup></a> and her colleagues compiled data to create a stage-based projection matrix to analyze quantitatively which stages are most important and least important in influencing long-term growth rate. This work led to US Federal laws requiring that US shrimp fishermen use nets that include Turtle Excluder Devices (TEDs, <a href="https://www.fisheries.noaa.gov/southeast/bycatch/turtle-excluder-device-regulations" class="uri">https://www.fisheries.noaa.gov/southeast/bycatch/turtle-excluder-device-regulations</a> ). Crouse et al. determined a transition matrix, <strong>A</strong>, for their loggerhead population:</p>
<p><span class="math display">\[\begin{array}{c}
H\\J_s\\J_l \\sub \\ B_1 \\B_2 \\ M
\end{array}
 \left(
\begin{array}{cccccccc}
     0&amp;      0&amp;      0&amp;      0&amp;    127&amp;      4&amp; 80\\
0.6747&amp; 0.7370&amp;      0&amp;      0&amp;      0&amp;      0&amp; 0\\
     0&amp; 0.0486&amp; 0.6610&amp;      0&amp;      0&amp;      0&amp; 0\\
     0&amp;      0&amp; 0.0147&amp; 0.6907&amp;      0&amp;      0&amp; 0\\
     0&amp;      0&amp;      0&amp; 0.0518&amp;      0&amp;      0&amp; 0\\
      0&amp;      0&amp;      0&amp;      0&amp; 0.8091&amp;      0&amp; 0\\
      0&amp;      0&amp;      0&amp;      0&amp;      0&amp; 0.8091&amp; 0.8089
\end{array} 
\right)\]</span></p>
<div class="sourceCode" id="cb171"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>
  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0</span>,    <span class="fl">127</span>,      <span class="fl">4</span>,    <span class="fl">80</span>,
    <span class="fl">0.6747</span>, <span class="fl">0.7370</span>, <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0</span>,     <span class="fl">0</span>,
    <span class="fl">0</span>,      <span class="fl">0.0486</span>, <span class="fl">0.6610</span>, <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0</span>,     <span class="fl">0</span>,
    <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0.0147</span>, <span class="fl">0.6907</span>, <span class="fl">0</span>,      <span class="fl">0</span>,     <span class="fl">0</span>,
    <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0.0518</span>, <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0</span>,
    <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0.8091</span>, <span class="fl">0</span>,      <span class="fl">0</span>,
    <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0</span>,      <span class="fl">0.8091</span>, <span class="fl">0.8089</span><span class="op">)</span>, 
nrow<span class="op">=</span><span class="fl">7</span>, ncol<span class="op">=</span><span class="fl">7</span>, byrow<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/eigen.html">eigen</a></span><span class="op">(</span><span class="va">A</span><span class="op">)</span><span class="op">$</span><span class="va">values</span></code></pre></div>
<pre><code>## [1]  0.9450310+0.0000000i  0.7461702+0.2130565i  0.7461702-0.2130565i
## [4]  0.3716668+0.0000000i  0.2654528+0.0000000i -0.0884455+0.1195997i
## [7] -0.0884455-0.1195997i</code></pre>
<ol style="list-style-type: decimal">
<li>Draw by hand two different types of life cycle graphs for this loggerhead population. Include the matrix elements associated with each transition.</li>
<li>Use eigenanalysis to determine <span class="math inline">\(\lambda_1\)</span>. Explain what this tells us about the population, including any assumptions regarding the stable stage distribution.</li>
<li>Use eigenanalysis to determine the stable stage distribution.</li>
<li>Use eigenanalysis to determine the elasticities. Which transition(s) are most influential in determining growth rate?</li>
<li>What is the predicted long-term relative abundance of all stages? What do we call this?</li>
<li>If your interest is to maximize long-term growth rate, in which stage(s) should you invest protection measures? Which stages are least likely to enhance long-term growth rate, regardless of protective measures?</li>
<li>Start with <span class="math inline">\(\mathbf{N} = \left(1000\,10\,10\,10\,10\,10\,10\right)\)</span> and graph dynamics for all stages for 20 years.</li>
</ol>
</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="expo.html"><span class="header-section-number">3</span> Simple density-independent growth</a></div>
<div class="next"><a href="DDgrowth.html"><span class="header-section-number">5</span> Density-dependent growth</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#DID"><span class="header-section-number">4</span> Density-independent Demography</a></li>
<li><a class="nav-link" href="#a-two-stage-matrix-model"><span class="header-section-number">4.1</span> A two stage matrix model</a></li>
<li><a class="nav-link" href="#a-brief-primer-on-matrices"><span class="header-section-number">4.2</span> A brief primer on matrices</a></li>
<li><a class="nav-link" href="#decomposing-a"><span class="header-section-number">4.3</span> Decomposing A</a></li>
<li><a class="nav-link" href="#a-three-stage-model"><span class="header-section-number">4.4</span> A three stage model</a></li>
<li><a class="nav-link" href="#projection"><span class="header-section-number">4.5</span> Projection</a></li>
<li>
<a class="nav-link" href="#analyzing-the-transition-matrix"><span class="header-section-number">4.6</span> Analyzing the transition matrix</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#eigenanalysis"><span class="header-section-number">4.6.1</span> Eigenanalysis</a></li>
<li><a class="nav-link" href="#finite-rate-of-increase"><span class="header-section-number">4.6.2</span> Finite rate of increase</a></li>
<li><a class="nav-link" href="#stable-stage-distribution"><span class="header-section-number">4.6.3</span> Stable stage distribution</a></li>
<li><a class="nav-link" href="#calculating-the-stable-stage-distribution"><span class="header-section-number">4.6.4</span> Calculating the stable stage distribution</a></li>
<li><a class="nav-link" href="#reproductive-value"><span class="header-section-number">4.6.5</span> Reproductive value</a></li>
<li><a class="nav-link" href="#sensitivity-and-elasticity"><span class="header-section-number">4.6.6</span> Sensitivity and elasticity</a></li>
</ul>
</li>
<li><a class="nav-link" href="#matrix-models-can-be-challenging"><span class="header-section-number">4.7</span> Matrix models can be challenging</a></li>
<li>
<a class="nav-link" href="#integral-projection"><span class="header-section-number">4.8</span> Integral projection</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#on-probability-density"><span class="header-section-number">4.8.1</span> On probability density</a></li>
<li><a class="nav-link" href="#a-size-based-ipm-of-smooth-coneflower"><span class="header-section-number">4.8.2</span> A size-based IPM of smooth coneflower</a></li>
<li><a class="nav-link" href="#population-summaries"><span class="header-section-number">4.8.3</span> Population summaries</a></li>
</ul>
</li>
<li><a class="nav-link" href="#r-packges-for-demography"><span class="header-section-number">4.9</span> R packges for demography</a></li>
<li><a class="nav-link" href="#loggerhead-sea-turtle-a-classic-example"><span class="header-section-number">4.10</span> Loggerhead Sea Turtle: a classic example</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Primer of Ecology using R</strong>" was written by Hank Stevens. It was last built on 2021-12-31.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
